# Assembler

The assembler takes a Turkey assembly code and compiles it into Turkey bytecode.

## Usage
The assembler takes a file containing assembly code as input and produces a module containing bytecode.

Usage is:
node Assembler.js -v -d [input] [output]

Input and output paths are mandatory!
- -v is an optional argument.
- -d produces debugging information.

## Comments
Comments begin with # and may appear anywhere in an assembly file - the rest of the line is ignored (unless the # is inside of a string.)

## Functions
Functions are high level unit of the program. The very first function specified in a file is what is executed when the module loads. You can define a function with the keyword 'function' followed by a name, any instructions, metadata, or labels below are part of that function, until the next 'function' appears. For example:

```
Function somename
   # instructions, labels, metadata here
   
Function someotherfunc
   # instructions, labels, metadata here
```

Anything above the first function is ignored. Function names must be unique (as they can be referenced from other functions) and can contain any character except for a whitespace or a comment symbol.

## Metadata
Metadata is unique to a function, and specifies metadata about the function or to control the assembler. You can use it for describing parameters, variables, and debugging information. Metadata starts with a '-' symbol followed by a name and the parameters. For example:
```
Function somename
   -parameters 3 # function expects 3 parameters
```

Many of the metadata properties (except for -columns) is static throughout the function and if the same metadata is specified duplicate times, the latest value will be used. For example if you call '-locals 4' then change it to '-locals 2' near the end of the function, the assembler will only use the latest value ('-locals 2').

All metadata values reset when the next function begins.

### Basic Metadata

Metadata|Description
--------|-----------
-closures [num]|Specifies the number of closure variables the function uses. If this property is not provided it is assumed to be 0.
-parameters [num|Specifies the number of parameters the function takes. If this property is not provided it is assumed to be 0.

### Debugging Metadata
Debugging metadata is only useful if assembling the file with the -d parameter so that it embeds this metadata into the assembled module. This metadata is expected to be generated by a compiler, so when debugging the virtual machine can tell you information such as the name of local variables and what code it is executing.

Metadata|Description
--------|-----------
-name [name]|A descriptive name for the function. This name can contain anything but whitespaces or comment symbols. The assembler does not use this - instead it can be used by a debugger for generating a high-level language call stack. If this property is not specified it is assumed to be the same name specified at the start of the function that the assembler uses for references.
-filename [filename]|The filename this function was defined in. This name _can_ contain whitespaces but not comment symbols. If this property is not specified it is assumed to be the input filename.
-functioncolumns [start] [end]|A column index into the source code file where this function begins and ends. This is so that debuggers can highlight the currently executing function or to allow the user to jump to it. If this property is not specified it is assumed match the columns in the assembly code input file.
-columns [start] [end]|A start and end column index into the source code file where the instructions following this metadata can be found. This is so debuggers can highlight the currently executing piece of code while the user single steps through executing. This is the only property that is able to change in a function (because each instruction could be generated by a different line/column of compiled code) - and affects any instructions that appear after it. If this property is not specified, the columns in the assembly code input file are used, and will increment automatically (to match each line of the assembly code) unless this is specified. If this property is specified, it does not increment automatically - you (or your compiler) must explicitly do that.

## Labels
Labels begin with a '.' and appear on their own line. You do not need to place a dot when referencing labels in jump statements. Labels only exist within the scope of the function they appear in.

## Debugging
Pass the -d parameter to the assembler for it to assemble in debugging information into the module. This will make your module file many times larger.

## Types
Variables do not contain a type, only the values that are assigned to them. The type system matches the Turkey types. These are the follwing types:

Type|Description
----|-----------
null|A null value. Used to describe something not being assigned or missing.
boolean|A true/false boolean value.
integer|A signed integer. This is implemented with 64-bits in the virtual machine.
unsigned integer|An unsigned integer. This is implemented with 64-bits in the virtual machine.
float|A floating point number. This is implemented with 64-bits in the virtual machine.
string|A string.
object|An object with properties.
array|A dynamic array.
buffer|A static-sized memory buffer. Used for high performance operations or bit-specific manipulation.
function|A function pointer. Contains a reference to both the function and the local closure environment from where it was defined.
native function|A native function pointer. It can be called similar to a function, but calling it calls a native function in the virtual machine. While it can be passed around in Shovel or assembly code, it can only be defined in the virtual machine.

Closures (the environment attached to function pointers), objects, arrays, and buffers are garbage collected.

## Instructions
Below are a list of instructions and their bytecode representation. The Turkey virtual machine is a stack based virtual
machine. There is also a local variable, heap-allocated closure stack, and call stack. Below is a table of instructions. Most instructions operate purely on the stackbut some (such as jumping or pushing values to the stack) take operands. Instructions are case sensitive in the assembler.

Opcode|Instruction|Input|Outputs|Notes
------|-----------|-----|-------|-----
&nbsp;|**Math**|||
0|Add|A,B|Result|Adds A and B together. Calls the property "+" on an object.
1|Subtract|A,B|Result|Subtracts B from A. Calls the property "-" on an object.
2|Divide|A,B|Result|Divides A by B. Calls the property "/" on an object.
3|Multiply|A,B|Result|Multiples A and B together. Calls the property "*" on an object.
4|Modulo|A,B|Result|Divides A by B and returns the remainder. Calls the property "%" on an object.
122|Invert|A|Result|Inverts the sign of A.
5|Increment|A|Result|Increments A by one. Calls the property "++" on an object.
6|Decrement|A|Result|Decreases A by one. Calls the property "--" on an object.
&nbsp;|**Bit Operations**|||
7|Xor|A,B|Result|Performs a bitwise excluse or. Calls the property "^" on an object.
8|And|A,B|Result|Performs a bitwise and. Calls the property "&" on an object.
9|Or|A,B|Result|Performs a bitwise or. Calls the property "&#124;" on an object.
10|Not|A,B|Result|Performs a bitwise not. Calls the property "!" on an object.
11|ShiftLeft|A,B|Result|Performs a bitwise shift left. Calls the property "&lt;&lt;" on an object.
12|ShiftRight|A,B|Result|Performs a bitwise shift right. Calls the property "&gt;&gt;" on an object.
13|RotateLeft|A,B|Result|Performs a bitwise rotation left. Calls the property "&lt;&lt;&lt;" on an object.
14|RotateRight|A,B|Result|Performs a bitwise rotation right. Calls the property "&gt;&gt;&gt;" on an object.
&nbsp:|**Logical Comparison**|||
15|IsNull|A|Result|Returns true if A is null, false otherwise.
16|IsNotNull|A|Result|Returns true if A is not null, false otherwise.
17|Equals|A,B|Result|Returns true if A and B are not equal, false otherwise.
18|NotEquals|A,B|Result|Returns true if A and B are equal, false otherwise.
19|LessThan|A,B|Result|Returns true if A is less than B, false otherwise. Calls the property "&lt;" on an object.
20|GreaterThan|A,B|Result|Returns true if A is greater than B, false otherwise. Calls the property "&gt;" on an object.
21|LessThanOrEquals|A,B|Result|Returns true if A is less than or equal to B, false otherwise. Calls the property "&lt;=" on an object.
22|GreaterThanOrEquals|A,B|Result|Returns true if A is greater than or equal to B, false otherwise. Calls the property "&gt;=" on an object.
23|IsTrue|A,B|Result|Returns true if A is not zero or null, false otherwise.
24|IsFalse|A,B|Result|Returns true if A is zero or null, false otherwise.
&nbsp;|**Stack Manipulation**|||
25|Pop|A||Pops a value off the stack and discards it.
26|PopMany [count]|[count]||Pops [count]-number (up to 255) values off the stack and discards them.
27/28/29|Grab [count]||Value|Grabs an element [count] up the stack and pushes it to the bottom.
33/34/35|Store [count]|Value||Pops a value of the stack and stores it [count] positions up the stack. [count] is an index into the stack after the value to store has been popped.
36/37/38|Swap [a] [b]|||Swaps two two elements in the stack [A] and [B] positions up.
&nbsp;|**Arrays**|||
45|NewArray|Size|Array|Create an array with the size preallocated.
46|LoadElement|Key,Array|Result|Returns an element from an object (where [key] is the property), an array (where [key] is an index), or a character as an integer in a string (where[key] is the position of the character). Returns null if the key cannot be found.
47|SaveElement|Value,Key,Array||Saves an element into an object (where [key] is the property) or an array (where [key] is an index.) This resizes an array or creates an a new property on an object if the key does not already exis, otherwise it overwrites the currently assigned value for that key.
&nbsp;|**Objects**|||
48|NewObject|||Creates an object.
49|DeleteElement|Key,Object||Deletes an element from an object (where [key] is the property). Does nothing if the element does not exist.
&nbsp;|**Buffers**|||
50|NewBuffer|Size|Buffer|Create a buffer, where [size] is the number of bytes the buffer should be.
51|LoadBufferUnsigned&lt;8&gt;|Address,Buffer|Value|Loads an 8-bit unsigned integer from a buffer at [address] bytes in.
52|LoadBufferUnsigned&lt;16&gt;|Address,Buffer|Value|Loads a 16-bit unsigned integer (little endien) from a buffer at [address] bytes in.
53|LoadBufferUnsigned&lt;32&gt;|Address,Buffer|Value|Loads a 32-bit unsigned integer (little endien) from a buffer at [address] bytes in.
54|LoadBufferUnsigned&lt;64&gt;|Address,Buffer|Value|Loads a 64-bit unsigned integer (little endien) from a buffer at [address] bytes in.
55|StoreBufferUnsigned&lt;8&gt;|Value,Address,Buffer||Saves an 8-bit unsigned integer to a buffer at [address] bytes in.
56|StoreBufferUnsigned&lt;16&gt;|Value,Address,Buffer||Saves a 16-bit unsigned integer (little endien) to a buffer at [address] bytes in.
57|StoreBufferUnsigned&lt;32&gt;|Value,Address,Buffer||Saves a 32-bit unsigned integer (little endien) to a buffer at [address] bytes in.
58|StoreBufferUnsigned&lt;64&gt;|Value,Address,Buffer||Saves a 64-bit unsigned integer (little endien) to a buffer at [address] bytes in.
59|LoadBufferSigned&lt;8&gt;|Address,Buffer|Value|Loads an 8-bit signed integer (two's compliment) from a buffer at [address] bytes in.
60|LoadBufferSigned&lt;16&gt;|Address,Buffer|Value|Loads a 16-bit signed integer (two's compliment, little endien) from a buffer at [address] bytes in.
61|LoadBufferSigned&lt;32&gt;|Address,Buffer|Value|Loads a 32-bit signed integer (two's compliment, little endien) from a buffer at [address] bytes in.
62|LoadBufferSigned&lt;64&gt;|Address,Buffer|Value|Loads a 64-bit signed integer (two's compliment, little endien) from a buffer at [address] bytes in.
63|StoreBufferSigned&lt;8&gt;|Value,Address,Buffer||Saves an 8-bit signed integer (two's compliment) to a buffer at [address] bytes in.
64|StoreBufferSigned&lt;16&gt;|Value,Address,Buffer||Saves a 16-bit signed integer (two's compliment, little endien) to a buffer at [address] bytes in.
65|StoreBufferSigned&lt;32&gt;|Value,Address,Buffer||Saves a 32-bit signed integer (two's compliment, little endien) to a buffer at [address] bytes in.
66|StoreBufferSigned&lt;64&gt;|Value,Address,Buffer||Saves a 64-bit signed integer (two's compliment, little endien) to a buffer at [address] bytes in.
67|LoadBufferFloat&lt;16&gt;|Address,Buffer|Value|Loads a 16-bit floating point number from a buffer at [address] bytes in.
68|LoadBufferFloat&lt;32&gt;|Address,Buffer|Value|Loads a 32-bit floating point number from a buffer at [address] bytes in.
69|LoadBufferFloat&lt;64&gt;|Address,Buffer|Value|Loads a 64-bit floating point number from a buffer at [address] bytes in.
70|StoreBufferFloat&lt;16&gt;|Value,Address,Buffer||Saves a 16-bit floating point number to a buffer at [address] bytes in.
71|StoreBufferFloat&lt;32&gt;|Value,Address,Buffer||Saves a 32-bit floating point number to a buffer at [address] bytes in.
72|StoreBufferFloat&lt;64&gt;|Value,Address,Buffer||Saves a 64-bit floating point number to a buffer at [address] bytes in.
&nbsp;|**Integers**|||
73/74/75/76|PushInteger [x]||Value|Pushes the integer [x] onto the stack.
77|ToInteger|A|Value|Converts A to an integer. Arrays, objects, and strings are converted to the number of elements they have.
&nbsp;|**Unsigned Integers**|||
78/79/80/81|PushUnsignedInteger[x]||Value|Pushes the unsigned integer [x] onto the stack.
82|ToUnsignedInteger|A|Value|Converts A to an unsigned integer. Arrays, objects, and strings are converted to the number of elements they have.
&nbsp;|**Floating Point Numbers**|||
83|PushFloat [x]||Value|Pushes the floating point number [x] onto the stack.
84|ToFloat|Value|value|Converts the value to a floating point number. Arrays, objects, and strings are converted to the number of elements they have.
&nbsp;|**Booleans**|||
85|PushTrue||Value|Pushes a boolean with the value of true onto the stack.
86|PushFalse||Value|Pushes a boolean with the value of false onto the stack.
&nbsp;|**Nulls**|||
87|PushNull||Value|Pushes a null value onto the stack.
30|PushManyNulls [count]||[count]|Pushes [count]-number (up to 255) nulls to the stack.
&nbsp;|**Strings**|||
88/89/90|PushString [string]||Value|Pushes a string containing the text [string] onto the stack.
121|ToString|A|Value|Converts A to a string. Floats, unsigned, and signed integers convert to their base 10 representation, buffers are converted to their base 64 representation, while objects and arrays are converted to their JSON encoding.
&nbsp;|**Functions**|||
91|PushFunction [function]||Value|Pushes a function with the name [function] and the current closure stack onto the stack.
92/93|CallFunction [parameters]|[Parameters] Function|ReturnValue|Calls a function. The operand [parameters] specifies the number of parameters that you have pushed to the stack. If you do not push enough parameters, they will appear as null values to the calling function, and if you push too many - they will simply be dropped off the stack. The function's return value is pushed onto the stack - if the function does not return anything, a null value will be pushed onto the stack.
94/95|CallFunctionNoReturn [parameters]|[Parameters] Function||Calls a function without wanting anything to be returned. The operand [parameters] specifies the number of parameters that you have pushed to the stack. If you do not push enough parameters, they will appear as null values to the calling function, and if you push too many - they will simply be dropped off the stack. If the function returns anything it will simply be popped off the stack.
96|ReturnNull|||Returns to the value null and execution to the calling function.
97|Return|A||Returns A and execution to the calling function.
&nbsp;|**Types**|||
98|GetType|A|Value|Returns a string specifying what type A is.
&nbsp;|**Control Flow**|||
99/100/101|Jump [label]|||Jumps execution to [label].
102/103/104|JumpIfTrue [label]|A||Jumps execution to [label] if A is true.
105/106/107|JumpIfFalse [label]|A||Jumps execution to [label] if A is false.
108/109/110|JumpIfNull [label]|A||Jumps execution to [label] if A is null.
111/112/113|JumpIfNotNull [label]|A||Jumps execution to [label] if A is not null.
&nbsp;|**Loading**|||
114|Require|A|Value|Loads a module called [A] (which may be a library name or path to a compiled module) and calls its first function. Whatever that function returns is pushed onto the stack.

Some instructions have multiple opcodes because the operands can be of multiple sizes (such as 8-bit or 16-bit) and the assembler chooses the most appropriate form for the context provided. They are not functionally different - it only compresses the assembled bytecode where appropriate.

## Known Issues
- There's no way to embed icons yet.
- Saving and loading 64-bit integers (signed and unsigned) isn't implemented yet. Same with 16-bit floats. However 32 and 64-bit floats are fine. These features are planned but Javascript complicates implementing this.
