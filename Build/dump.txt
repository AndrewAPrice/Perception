
../fs/helloworld.app:     file format elf64-x86-64


Disassembly of section .text:

0000000000000000 <envp>:
	...

0000000000000020 <crt0_entry>:
      20:	48 bf b0 60 00 00 00 00 00 00 	movabs rdi,0x60b0
      2a:	be 00 00 00 00       	mov    esi,0x0
      2f:	48 ba 00 00 00 00 00 00 00 00 	movabs rdx,0x0
      39:	e8 12 05 00 00       	call   550 <__libc_start_main>
      3e:	bf 00 00 00 00       	mov    edi,0x0
      43:	e8 88 00 00 00       	call   d0 <__cxa_finalize>
      48:	48 bb 00 80 00 00 00 00 00 00 	movabs rbx,0x8000
      52:	eb 06                	jmp    5a <crt0_entry.checkIfWeHaveAGlobalDestructor>

0000000000000054 <crt0_entry.callGlobalDestructor>:
      54:	48 83 eb 08          	sub    rbx,0x8
      58:	ff 13                	call   QWORD PTR [rbx]

000000000000005a <crt0_entry.checkIfWeHaveAGlobalDestructor>:
      5a:	48 81 fb 00 80 00 00 	cmp    rbx,0x8000
      61:	77 f1                	ja     54 <crt0_entry.callGlobalDestructor>
      63:	bf 06 00 00 00       	mov    edi,0x6
      68:	0f 05                	syscall 

000000000000006a <call_global_constructors>:
      6a:	eb fe                	jmp    6a <call_global_constructors>
      6c:	48 bb 00 80 00 00 00 00 00 00 	movabs rbx,0x8000
      76:	eb 06                	jmp    7e <call_global_constructors.checkIfWeHaveAGlobalConstructor>

0000000000000078 <call_global_constructors.callGlobalConstructor>:
      78:	ff 13                	call   QWORD PTR [rbx]
      7a:	48 83 c3 08          	add    rbx,0x8

000000000000007e <call_global_constructors.checkIfWeHaveAGlobalConstructor>:
      7e:	48 81 fb 00 80 00 00 	cmp    rbx,0x8000
      85:	72 f1                	jb     78 <call_global_constructors.callGlobalConstructor>
      87:	c3                   	ret    
      88:	0f 1f 84 00 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]

0000000000000090 <__cxa_atexit>:
	// Used by the compiler, but what for?
	void *__dso_handle = 0;
}

// Registers an exit function. This is a function GCC expects to exist.
extern "C" int __cxa_atexit(void (function)(void *), void *object, void *dso) {
      90:	55                   	push   rbp
      91:	48 89 fd             	mov    rbp,rdi
	// We don't yet support dynamic shared objects, so we can ignore the dso argument.

	// Add a new item to the front of the linked list.
	ExitFunction* exit_function = new ExitFunction();
      94:	bf 18 00 00 00       	mov    edi,0x18
extern "C" int __cxa_atexit(void (function)(void *), void *object, void *dso) {
      99:	53                   	push   rbx
      9a:	48 89 f3             	mov    rbx,rsi
      9d:	48 83 ec 08          	sub    rsp,0x8
	ExitFunction* exit_function = new ExitFunction();
      a1:	e8 5a 01 00 00       	call   200 <operator new(unsigned long)>
	exit_function->function = function;
	exit_function->object = object;
	exit_function->next = last_exit_function;
      a6:	48 8b 15 f3 cf 00 00 	mov    rdx,QWORD PTR [rip+0xcff3]        # d0a0 <(anonymous namespace)::last_exit_function>
	exit_function->function = function;
      ad:	48 89 28             	mov    QWORD PTR [rax],rbp
	exit_function->object = object;
      b0:	48 89 58 08          	mov    QWORD PTR [rax+0x8],rbx
	exit_function->next = last_exit_function;
      b4:	48 89 50 10          	mov    QWORD PTR [rax+0x10],rdx
	last_exit_function = exit_function;
      b8:	48 89 05 e1 cf 00 00 	mov    QWORD PTR [rip+0xcfe1],rax        # d0a0 <(anonymous namespace)::last_exit_function>
	return 0;
}
      bf:	48 83 c4 08          	add    rsp,0x8
      c3:	31 c0                	xor    eax,eax
      c5:	5b                   	pop    rbx
      c6:	5d                   	pop    rbp
      c7:	c3                   	ret    
      c8:	0f 1f 84 00 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]

00000000000000d0 <__cxa_finalize>:

// Calls the exit functions.
extern "C" void __cxa_finalize(void *function) {
      d0:	41 55                	push   r13
      d2:	41 54                	push   r12
      d4:	55                   	push   rbp
      d5:	53                   	push   rbx
      d6:	48 83 ec 08          	sub    rsp,0x8
      da:	48 8b 2d bf cf 00 00 	mov    rbp,QWORD PTR [rip+0xcfbf]        # d0a0 <(anonymous namespace)::last_exit_function>
	if (function != nullptr) {
      e1:	48 85 ff             	test   rdi,rdi
      e4:	74 7d                	je     163 <__cxa_finalize+0x93>
      e6:	48 89 fb             	mov    rbx,rdi
		// Call exit functions that match the provided function.
		ExitFunction* previous = nullptr;
      e9:	45 31 e4             	xor    r12d,r12d
		ExitFunction* this_func = last_exit_function;

		while (this_func != nullptr) {
      ec:	48 85 ed             	test   rbp,rbp
      ef:	75 13                	jne    104 <__cxa_finalize+0x34>
      f1:	eb 40                	jmp    133 <__cxa_finalize+0x63>
      f3:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

				this_func = next;
			} else {
				// Skip over this exit function.
				previous = this_func;
				this_func = this_func->next;
      f8:	49 89 ec             	mov    r12,rbp
      fb:	48 8b 6d 10          	mov    rbp,QWORD PTR [rbp+0x10]
		while (this_func != nullptr) {
      ff:	48 85 ed             	test   rbp,rbp
     102:	74 2f                	je     133 <__cxa_finalize+0x63>
			if (this_func->function == function) {
     104:	48 39 5d 00          	cmp    QWORD PTR [rbp+0x0],rbx
     108:	75 ee                	jne    f8 <__cxa_finalize+0x28>
				this_func->function(this_func->object);
     10a:	48 8b 7d 08          	mov    rdi,QWORD PTR [rbp+0x8]
     10e:	ff d3                	call   rbx
				delete this_func;
     110:	be 18 00 00 00       	mov    esi,0x18
     115:	48 89 ef             	mov    rdi,rbp
				ExitFunction* next = this_func->next;
     118:	4c 8b 6d 10          	mov    r13,QWORD PTR [rbp+0x10]
				delete this_func;
     11c:	e8 ff 00 00 00       	call   220 <operator delete(void*, unsigned long)>
				if (previous != nullptr) {
     121:	4d 85 e4             	test   r12,r12
     124:	74 52                	je     178 <__cxa_finalize+0xa8>
				this_func = next;
     126:	4c 89 ed             	mov    rbp,r13
					previous->next = next;
     129:	4d 89 6c 24 10       	mov    QWORD PTR [r12+0x10],r13
		while (this_func != nullptr) {
     12e:	48 85 ed             	test   rbp,rbp
     131:	75 d1                	jne    104 <__cxa_finalize+0x34>
			delete last_exit_function;
			last_exit_function = next;
		}

	}
     133:	48 83 c4 08          	add    rsp,0x8
     137:	5b                   	pop    rbx
     138:	5d                   	pop    rbp
     139:	41 5c                	pop    r12
     13b:	41 5d                	pop    r13
     13d:	c3                   	ret    
     13e:	66 90                	xchg   ax,ax
			last_exit_function->function(last_exit_function->object);
     140:	48 8b 7d 08          	mov    rdi,QWORD PTR [rbp+0x8]
     144:	ff 55 00             	call   QWORD PTR [rbp+0x0]
			ExitFunction* next = last_exit_function->next;
     147:	48 8b 3d 52 cf 00 00 	mov    rdi,QWORD PTR [rip+0xcf52]        # d0a0 <(anonymous namespace)::last_exit_function>
			delete last_exit_function;
     14e:	be 18 00 00 00       	mov    esi,0x18
			ExitFunction* next = last_exit_function->next;
     153:	48 8b 6f 10          	mov    rbp,QWORD PTR [rdi+0x10]
			delete last_exit_function;
     157:	e8 c4 00 00 00       	call   220 <operator delete(void*, unsigned long)>
			last_exit_function = next;
     15c:	48 89 2d 3d cf 00 00 	mov    QWORD PTR [rip+0xcf3d],rbp        # d0a0 <(anonymous namespace)::last_exit_function>
		while (last_exit_function != nullptr) {
     163:	48 85 ed             	test   rbp,rbp
     166:	75 d8                	jne    140 <__cxa_finalize+0x70>
     168:	48 83 c4 08          	add    rsp,0x8
     16c:	5b                   	pop    rbx
     16d:	5d                   	pop    rbp
     16e:	41 5c                	pop    r12
     170:	41 5d                	pop    r13
     172:	c3                   	ret    
     173:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
					last_exit_function = next;
     178:	4c 89 2d 21 cf 00 00 	mov    QWORD PTR [rip+0xcf21],r13        # d0a0 <(anonymous namespace)::last_exit_function>
				this_func = next;
     17f:	4c 89 ed             	mov    rbp,r13
     182:	e9 78 ff ff ff       	jmp    ff <__cxa_finalize+0x2f>
     187:	66 0f 1f 84 00 00 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]

0000000000000190 <perception::AllocateMemoryPages(unsigned long)>:
#include <unistd.h>
#endif

namespace perception {

void* AllocateMemoryPages(size_t number) {
     190:	48 89 f8             	mov    rax,rdi
#if PERCEPTION
	volatile register size_t syscall_num asm ("rdi") = 12;
     193:	bf 0c 00 00 00       	mov    edi,0xc
	volatile register size_t param1 asm ("rax") = number;
	volatile register size_t return_val asm ("rax");

	__asm__ __volatile__ ("syscall\n":"=r"(return_val):"r"(syscall_num), "r"(param1): "rcx", "r11");
     198:	0f 05                	syscall 
	return (void*)return_val;
#else
	return malloc(kPageSize * number);
#endif
}
     19a:	c3                   	ret    
     19b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

00000000000001a0 <perception::ReleaseMemoryPages(void*, unsigned long)>:

void ReleaseMemoryPages(void* ptr, size_t number) {
     1a0:	53                   	push   rbx
     1a1:	48 89 f8             	mov    rax,rdi
     1a4:	48 89 f3             	mov    rbx,rsi
#if PERCEPTION
	volatile register size_t syscall_num asm ("rdi") = 13;
     1a7:	bf 0d 00 00 00       	mov    edi,0xd
	volatile register size_t param1 asm ("rax") = (size_t)ptr;
	volatile register size_t param2 asm ("rbx") = number;

	__asm__ __volatile__ ("syscall\n"::"r"(syscall_num), "r"(param1), "r"(param2): "rcx", "r11");
     1ac:	0f 05                	syscall 
#else
	return free(ptr);
#endif
}
     1ae:	5b                   	pop    rbx
     1af:	c3                   	ret    

00000000000001b0 <perception::MaybeResizePages(void**, unsigned long, unsigned long)>:
		return false;
	
	*ptr = maybe_new_ptr;
	return true;
#endif
}
     1b0:	31 c0                	xor    eax,eax
     1b2:	c3                   	ret    
     1b3:	66 66 2e 0f 1f 84 00 00 00 00 00 	data16 nop WORD PTR cs:[rax+rax*1+0x0]
     1be:	66 90                	xchg   ax,ax

00000000000001c0 <perception::GetFreeSystemMemory()>:

size_t GetFreeSystemMemory() {
#if PERCEPTION
	volatile register size_t syscall_num asm ("rdi") = 14;
     1c0:	bf 0e 00 00 00       	mov    edi,0xe
	volatile register size_t return_val asm ("rax");

	__asm__ __volatile__ ("syscall\n":"=r"(return_val):"r"(syscall_num): "rcx", "r11");
     1c5:	0f 05                	syscall 
	return return_val;
#else
	return 0;
#endif
}
     1c7:	c3                   	ret    
     1c8:	0f 1f 84 00 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]

00000000000001d0 <perception::GetTotalSystemMemory()>:

size_t GetTotalSystemMemory() {
#if PERCEPTION
	volatile register size_t syscall_num asm ("rdi") = 16;
     1d0:	bf 10 00 00 00       	mov    edi,0x10
	volatile register size_t return_val asm ("rax");

	__asm__ __volatile__ ("syscall\n":"=r"(return_val):"r"(syscall_num): "rcx", "r11");
     1d5:	0f 05                	syscall 
#else
	long pages = sysconf(_SC_PHYS_PAGES);
    long page_size = sysconf(_SC_PAGE_SIZE);
    return pages * page_size;
#endif
}
     1d7:	c3                   	ret    
     1d8:	0f 1f 84 00 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]

00000000000001e0 <perception::GetMemoryUsedByProcess()>:

size_t GetMemoryUsedByProcess() {
#if PERCEPTION
	volatile register size_t syscall_num asm ("rdi") = 15;
     1e0:	bf 0f 00 00 00       	mov    edi,0xf
	volatile register size_t return_val asm ("rax");

	__asm__ __volatile__ ("syscall\n":"=r"(return_val):"r"(syscall_num): "rcx", "r11");
     1e5:	0f 05                	syscall 
	return return_val;
#else
	return 0;
#endif
}
     1e7:	c3                   	ret    
     1e8:	0f 1f 84 00 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]

00000000000001f0 <__cxa_pure_virtual>:
}

#ifdef PERCEPTION
// Function that runs if a virtual function implementation is missing. Should never be called but
// needs to exist.
extern "C" void __cxa_pure_virtual() {}
     1f0:	c3                   	ret    
     1f1:	66 66 2e 0f 1f 84 00 00 00 00 00 	data16 nop WORD PTR cs:[rax+rax*1+0x0]
     1fc:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

0000000000000200 <operator new(unsigned long)>:

// Functions to support new/delete.
void *operator new(long unsigned int size) {
    return malloc(size);
     200:	e9 6b 0f 00 00       	jmp    1170 <malloc>
     205:	66 66 2e 0f 1f 84 00 00 00 00 00 	data16 nop WORD PTR cs:[rax+rax*1+0x0]

0000000000000210 <operator new[](unsigned long)>:
     210:	e9 5b 0f 00 00       	jmp    1170 <malloc>
     215:	66 66 2e 0f 1f 84 00 00 00 00 00 	data16 nop WORD PTR cs:[rax+rax*1+0x0]

0000000000000220 <operator delete(void*, unsigned long)>:
void *operator new[](long unsigned int size) {
    return malloc(size);
}
 
void operator delete(void *address, long unsigned int size) {
    free(address);
     220:	e9 1b 19 00 00       	jmp    1b40 <free>
     225:	66 66 2e 0f 1f 84 00 00 00 00 00 	data16 nop WORD PTR cs:[rax+rax*1+0x0]

0000000000000230 <operator delete[](void*, unsigned long)>:
     230:	e9 0b 19 00 00       	jmp    1b40 <free>
     235:	66 2e 0f 1f 84 00 00 00 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
     23f:	90                   	nop

0000000000000240 <_init>:
#include <unistd.h>
#include "syscall.h"
#include "atomic.h"
#include "libc.h"

static void dummy(void) {}
     240:	c3                   	ret    
     241:	66 66 2e 0f 1f 84 00 00 00 00 00 	data16 nop WORD PTR cs:[rax+rax*1+0x0]
     24c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

0000000000000250 <__init_ssp>:
weak_alias(dummy, _init);

extern weak hidden void (*const __init_array_start)(void), (*const __init_array_end)(void);

static void dummy1(void *p) {}
     250:	c3                   	ret    
     251:	66 66 2e 0f 1f 84 00 00 00 00 00 	data16 nop WORD PTR cs:[rax+rax*1+0x0]
     25c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

0000000000000260 <__init_libc>:

#ifdef __GNUC__
__attribute__((__noinline__))
#endif
void __init_libc(char **envp, char *pn)
{
     260:	48 81 ec 58 01 00 00 	sub    rsp,0x158
     267:	48 89 fa             	mov    rdx,rdi
	size_t i, *auxv, aux[AUX_CNT] = { 0 };
     26a:	31 c0                	xor    eax,eax
     26c:	b9 26 00 00 00       	mov    ecx,0x26
     271:	4c 8d 44 24 20       	lea    r8,[rsp+0x20]
	__environ = envp;
	for (i=0; envp[i]; i++);
     276:	48 83 3a 00          	cmp    QWORD PTR [rdx],0x0
	__environ = envp;
     27a:	48 89 15 8f d4 00 00 	mov    QWORD PTR [rip+0xd48f],rdx        # d710 <__environ>
	size_t i, *auxv, aux[AUX_CNT] = { 0 };
     281:	4c 89 c7             	mov    rdi,r8
     284:	f3 48 ab             	rep stos QWORD PTR es:[rdi],rax
	for (i=0; envp[i]; i++);
     287:	0f 84 4b 02 00 00    	je     4d8 <__init_libc+0x278>
     28d:	0f 1f 00             	nop    DWORD PTR [rax]
     290:	48 89 c1             	mov    rcx,rax
     293:	48 83 c0 01          	add    rax,0x1
     297:	48 83 3c c2 00       	cmp    QWORD PTR [rdx+rax*8],0x0
     29c:	75 f2                	jne    290 <__init_libc+0x30>
     29e:	48 8d 04 cd 10 00 00 00 	lea    rax,[rcx*8+0x10]
	libc.auxv = auxv = (void *)(envp+i+1);
     2a6:	48 01 d0             	add    rax,rdx
	for (i=0; auxv[i]; i+=2) if (auxv[i]<AUX_CNT) aux[auxv[i]] = auxv[i+1];
     2a9:	48 8b 10             	mov    rdx,QWORD PTR [rax]
	libc.auxv = auxv = (void *)(envp+i+1);
     2ac:	48 89 05 7d cd 00 00 	mov    QWORD PTR [rip+0xcd7d],rax        # d030 <__libc+0x10>
	for (i=0; auxv[i]; i+=2) if (auxv[i]<AUX_CNT) aux[auxv[i]] = auxv[i+1];
     2b3:	48 83 c0 08          	add    rax,0x8
     2b7:	48 85 d2             	test   rdx,rdx
     2ba:	0f 84 28 02 00 00    	je     4e8 <__init_libc+0x288>
     2c0:	48 83 fa 25          	cmp    rdx,0x25
     2c4:	0f 87 1e 01 00 00    	ja     3e8 <__init_libc+0x188>
     2ca:	48 8b 08             	mov    rcx,QWORD PTR [rax]
     2cd:	48 83 c0 10          	add    rax,0x10
     2d1:	48 89 4c d4 20       	mov    QWORD PTR [rsp+rdx*8+0x20],rcx
     2d6:	48 8b 50 f8          	mov    rdx,QWORD PTR [rax-0x8]
     2da:	48 85 d2             	test   rdx,rdx
     2dd:	75 e1                	jne    2c0 <__init_libc+0x60>
	__hwcap = aux[AT_HWCAP];
     2df:	48 8b 8c 24 a0 00 00 00 	mov    rcx,QWORD PTR [rsp+0xa0]
     2e7:	48 8b 84 24 20 01 00 00 	mov    rax,QWORD PTR [rsp+0x120]
     2ef:	48 8b 54 24 50       	mov    rdx,QWORD PTR [rsp+0x50]
     2f4:	48 89 0d 05 cd 00 00 	mov    QWORD PTR [rip+0xcd05],rcx        # d000 <__hwcap>
	if (aux[AT_SYSINFO]) __sysinfo = aux[AT_SYSINFO];
     2fb:	48 85 c0             	test   rax,rax
     2fe:	74 07                	je     307 <__init_libc+0xa7>
     300:	48 89 05 f9 6c 00 00 	mov    QWORD PTR [rip+0x6cf9],rax        # 7000 <__sysinfo>
	libc.page_size = aux[AT_PAGESZ];
     307:	48 89 15 4a cd 00 00 	mov    QWORD PTR [rip+0xcd4a],rdx        # d058 <__libc+0x38>

	if (!pn) pn = (void*)aux[AT_EXECFN];
     30e:	48 85 f6             	test   rsi,rsi
     311:	0f 84 79 01 00 00    	je     490 <__init_libc+0x230>
	if (!pn) pn = "";
	__progname = __progname_full = pn;
     317:	48 89 35 8a cd 00 00 	mov    QWORD PTR [rip+0xcd8a],rsi        # d0a8 <__progname_full>
     31e:	48 89 35 8b cd 00 00 	mov    QWORD PTR [rip+0xcd8b],rsi        # d0b0 <__progname>
	for (i=0; pn[i]; i++) if (pn[i]=='/') __progname = pn+i+1;
     325:	0f b6 06             	movzx  eax,BYTE PTR [rsi]
     328:	84 c0                	test   al,al
     32a:	74 17                	je     343 <__init_libc+0xe3>
     32c:	48 83 c6 01          	add    rsi,0x1
     330:	3c 2f                	cmp    al,0x2f
     332:	0f 84 c8 00 00 00    	je     400 <__init_libc+0x1a0>
     338:	0f b6 06             	movzx  eax,BYTE PTR [rsi]
     33b:	48 83 c6 01          	add    rsi,0x1
     33f:	84 c0                	test   al,al
     341:	75 ed                	jne    330 <__init_libc+0xd0>

	__init_tls(aux);
     343:	4c 89 c7             	mov    rdi,r8
     346:	e8 d5 29 00 00       	call   2d20 <__init_tls>
	__init_ssp((void *)aux[AT_RANDOM]);
     34b:	48 8b bc 24 e8 00 00 00 	mov    rdi,QWORD PTR [rsp+0xe8]
     353:	e8 f8 fe ff ff       	call   250 <__init_ssp>

	if (aux[AT_UID]==aux[AT_EUID] && aux[AT_GID]==aux[AT_EGID]
     358:	48 8b 84 24 80 00 00 00 	mov    rax,QWORD PTR [rsp+0x80]
     360:	48 39 44 24 78       	cmp    QWORD PTR [rsp+0x78],rax
     365:	75 16                	jne    37d <__init_libc+0x11d>
     367:	48 8b 84 24 90 00 00 00 	mov    rax,QWORD PTR [rsp+0x90]
     36f:	48 39 84 24 88 00 00 00 	cmp    QWORD PTR [rsp+0x88],rax
     377:	0f 84 43 01 00 00    	je     4c0 <__init_libc+0x260>
		&& !aux[AT_SECURE]) return;

	struct pollfd pfd[3] = { {.fd=0}, {.fd=1}, {.fd=2} };
     37d:	66 0f ef c0          	pxor   xmm0,xmm0
	int r =
#ifdef SYS_poll
	__syscall(SYS_poll, pfd, 3, 0);
     381:	31 c9                	xor    ecx,ecx
     383:	ba 03 00 00 00       	mov    edx,0x3
     388:	48 89 e6             	mov    rsi,rsp
     38b:	bf 07 00 00 00       	mov    edi,0x7
	struct pollfd pfd[3] = { {.fd=0}, {.fd=1}, {.fd=2} };
     390:	0f 29 04 24          	movaps XMMWORD PTR [rsp],xmm0
     394:	48 c7 44 24 10 00 00 00 00 	mov    QWORD PTR [rsp+0x10],0x0
     39d:	c7 44 24 08 01 00 00 00 	mov    DWORD PTR [rsp+0x8],0x1
     3a5:	c7 44 24 10 02 00 00 00 	mov    DWORD PTR [rsp+0x10],0x2
	__syscall(SYS_poll, pfd, 3, 0);
     3ad:	e8 6e 23 00 00       	call   2720 <__syscall3>
#else
	__syscall(SYS_ppoll, pfd, 3, &(struct timespec){0}, 0, _NSIG/8);
#endif
	if (r<0) a_crash();
     3b2:	85 c0                	test   eax,eax
     3b4:	79 01                	jns    3b7 <__init_libc+0x157>
}

#define a_crash a_crash
static inline void a_crash()
{
	__asm__ __volatile__( "hlt" : : : "memory" );
     3b6:	f4                   	hlt    
	for (i=0; i<3; i++) if (pfd[i].revents&POLLNVAL)
     3b7:	f6 44 24 06 20       	test   BYTE PTR [rsp+0x6],0x20
     3bc:	0f 85 a6 00 00 00    	jne    468 <__init_libc+0x208>
     3c2:	f6 44 24 0e 20       	test   BYTE PTR [rsp+0xe],0x20
     3c7:	75 77                	jne    440 <__init_libc+0x1e0>
     3c9:	f6 44 24 16 20       	test   BYTE PTR [rsp+0x16],0x20
     3ce:	75 50                	jne    420 <__init_libc+0x1c0>
		if (__sys_open("/dev/null", O_RDWR)<0)
			a_crash();
	libc.secure = 1;
     3d0:	c7 05 4e cc 00 00 01 00 00 00 	mov    DWORD PTR [rip+0xcc4e],0x1        # d028 <__libc+0x8>
}
     3da:	48 81 c4 58 01 00 00 	add    rsp,0x158
     3e1:	c3                   	ret    
     3e2:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
	for (i=0; auxv[i]; i+=2) if (auxv[i]<AUX_CNT) aux[auxv[i]] = auxv[i+1];
     3e8:	48 8b 50 08          	mov    rdx,QWORD PTR [rax+0x8]
     3ec:	48 83 c0 10          	add    rax,0x10
     3f0:	48 85 d2             	test   rdx,rdx
     3f3:	0f 85 c7 fe ff ff    	jne    2c0 <__init_libc+0x60>
     3f9:	e9 e1 fe ff ff       	jmp    2df <__init_libc+0x7f>
     3fe:	66 90                	xchg   ax,ax
	for (i=0; pn[i]; i++) if (pn[i]=='/') __progname = pn+i+1;
     400:	48 89 35 a9 cc 00 00 	mov    QWORD PTR [rip+0xcca9],rsi        # d0b0 <__progname>
     407:	0f b6 06             	movzx  eax,BYTE PTR [rsi]
     40a:	48 83 c6 01          	add    rsi,0x1
     40e:	84 c0                	test   al,al
     410:	0f 85 1a ff ff ff    	jne    330 <__init_libc+0xd0>
     416:	e9 28 ff ff ff       	jmp    343 <__init_libc+0xe3>
     41b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
		if (__sys_open("/dev/null", O_RDWR)<0)
     420:	ba 02 00 00 00       	mov    edx,0x2
     425:	be 00 80 00 00       	mov    esi,0x8000
     42a:	bf 02 00 00 00       	mov    edi,0x2
     42f:	e8 cc 22 00 00       	call   2700 <__syscall2>
     434:	48 85 c0             	test   rax,rax
     437:	79 97                	jns    3d0 <__init_libc+0x170>
     439:	f4                   	hlt    
}
     43a:	eb 94                	jmp    3d0 <__init_libc+0x170>
     43c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
     440:	ba 02 00 00 00       	mov    edx,0x2
     445:	be 00 80 00 00       	mov    esi,0x8000
     44a:	bf 02 00 00 00       	mov    edi,0x2
     44f:	e8 ac 22 00 00       	call   2700 <__syscall2>
     454:	48 85 c0             	test   rax,rax
     457:	0f 89 6c ff ff ff    	jns    3c9 <__init_libc+0x169>
	__asm__ __volatile__( "hlt" : : : "memory" );
     45d:	f4                   	hlt    
     45e:	e9 66 ff ff ff       	jmp    3c9 <__init_libc+0x169>
     463:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
     468:	ba 02 00 00 00       	mov    edx,0x2
     46d:	be 00 80 00 00       	mov    esi,0x8000
     472:	bf 02 00 00 00       	mov    edi,0x2
     477:	e8 84 22 00 00       	call   2700 <__syscall2>
     47c:	48 85 c0             	test   rax,rax
     47f:	0f 89 3d ff ff ff    	jns    3c2 <__init_libc+0x162>
     485:	f4                   	hlt    
     486:	e9 37 ff ff ff       	jmp    3c2 <__init_libc+0x162>
     48b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
	if (!pn) pn = (void*)aux[AT_EXECFN];
     490:	48 8b b4 24 18 01 00 00 	mov    rsi,QWORD PTR [rsp+0x118]
	if (!pn) pn = "";
     498:	48 85 f6             	test   rsi,rsi
     49b:	0f 85 76 fe ff ff    	jne    317 <__init_libc+0xb7>
	__progname = __progname_full = pn;
     4a1:	48 c7 05 fc cb 00 00 b8 a2 00 00 	mov    QWORD PTR [rip+0xcbfc],0xa2b8        # d0a8 <__progname_full>
     4ac:	48 c7 05 f9 cb 00 00 b8 a2 00 00 	mov    QWORD PTR [rip+0xcbf9],0xa2b8        # d0b0 <__progname>
	for (i=0; pn[i]; i++) if (pn[i]=='/') __progname = pn+i+1;
     4b7:	e9 87 fe ff ff       	jmp    343 <__init_libc+0xe3>
     4bc:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
		&& !aux[AT_SECURE]) return;
     4c0:	48 83 bc 24 d8 00 00 00 00 	cmp    QWORD PTR [rsp+0xd8],0x0
     4c9:	0f 85 ae fe ff ff    	jne    37d <__init_libc+0x11d>
     4cf:	e9 06 ff ff ff       	jmp    3da <__init_libc+0x17a>
     4d4:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
	for (i=0; envp[i]; i++);
     4d8:	b8 08 00 00 00       	mov    eax,0x8
     4dd:	e9 c4 fd ff ff       	jmp    2a6 <__init_libc+0x46>
     4e2:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
	__hwcap = aux[AT_HWCAP];
     4e8:	48 c7 05 0d cb 00 00 00 00 00 00 	mov    QWORD PTR [rip+0xcb0d],0x0        # d000 <__hwcap>
	if (aux[AT_SYSINFO]) __sysinfo = aux[AT_SYSINFO];
     4f3:	e9 0f fe ff ff       	jmp    307 <__init_libc+0xa7>
     4f8:	0f 1f 84 00 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]

0000000000000500 <__libc_start_init>:
{
	/*_init();
	uintptr_t a = (uintptr_t)&__init_array_start;
	for (; a<(uintptr_t)&__init_array_end; a+=sizeof(void(*)()))
		(*(void (**)(void))a)();*/
	call_global_constructors();
     500:	31 c0                	xor    eax,eax
     502:	e9 63 fb ff ff       	jmp    6a <call_global_constructors>
     507:	66 0f 1f 84 00 00 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]

0000000000000510 <libc_start_main_stage2>:
	__asm__ ( "" : "+r"(stage2) : : "memory" );
	return stage2(main, argc, argv);
}

static int libc_start_main_stage2(int (*main)(int,char **,char **), int argc, char **argv)
{
     510:	41 55                	push   r13
     512:	48 63 c6             	movsxd rax,esi
     515:	41 54                	push   r12
	char **envp = argv+argc+1;
     517:	4c 8d 6c c2 08       	lea    r13,[rdx+rax*8+0x8]
{
     51c:	49 89 d4             	mov    r12,rdx
     51f:	55                   	push   rbp
     520:	48 89 c5             	mov    rbp,rax
     523:	53                   	push   rbx
     524:	48 89 fb             	mov    rbx,rdi
     527:	48 83 ec 08          	sub    rsp,0x8
	__libc_start_init();
     52b:	e8 d0 ff ff ff       	call   500 <__libc_start_init>

	/* Pass control to the application */
	return main(argc, argv, envp);
}
     530:	48 83 c4 08          	add    rsp,0x8
	return main(argc, argv, envp);
     534:	4c 89 ea             	mov    rdx,r13
     537:	4c 89 e6             	mov    rsi,r12
     53a:	89 ef                	mov    edi,ebp
     53c:	48 89 d8             	mov    rax,rbx
}
     53f:	5b                   	pop    rbx
     540:	5d                   	pop    rbp
     541:	41 5c                	pop    r12
     543:	41 5d                	pop    r13
	return main(argc, argv, envp);
     545:	ff e0                	jmp    rax
     547:	66 0f 1f 84 00 00 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]

0000000000000550 <__libc_start_main>:
{
     550:	41 55                	push   r13
     552:	48 63 c6             	movsxd rax,esi
     555:	49 89 fd             	mov    r13,rdi
     558:	41 54                	push   r12
	char **envp = argv+argc+1;
     55a:	48 8d 7c c2 08       	lea    rdi,[rdx+rax*8+0x8]
{
     55f:	49 89 d4             	mov    r12,rdx
     562:	55                   	push   rbp
	__init_libc(envp, argv[0]);
     563:	48 8b 32             	mov    rsi,QWORD PTR [rdx]
{
     566:	48 89 c5             	mov    rbp,rax
	__init_libc(envp, argv[0]);
     569:	e8 f2 fc ff ff       	call   260 <__init_libc>
	__asm__ ( "" : "+r"(stage2) : : "memory" );
     56e:	b8 10 05 00 00       	mov    eax,0x510
	return stage2(main, argc, argv);
     573:	4c 89 e2             	mov    rdx,r12
     576:	89 ee                	mov    esi,ebp
     578:	4c 89 ef             	mov    rdi,r13
}
     57b:	5d                   	pop    rbp
     57c:	41 5c                	pop    r12
     57e:	41 5d                	pop    r13
	return stage2(main, argc, argv);
     580:	ff e0                	jmp    rax
     582:	cd 80                	int    0x80
     584:	c3                   	ret    
     585:	66 2e 0f 1f 84 00 00 00 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
     58f:	90                   	nop

0000000000000590 <__simple_malloc>:
#include "malloc_impl.h"

#define ALIGN 16

static void *__simple_malloc(size_t n)
{
     590:	41 54                	push   r12
     592:	55                   	push   rbp
     593:	bd 01 00 00 00       	mov    ebp,0x1
     598:	53                   	push   rbx
     599:	48 83 ec 10          	sub    rsp,0x10
     59d:	48 85 ff             	test   rdi,rdi
     5a0:	48 0f 45 ef          	cmovne rbp,rdi
	static volatile int lock[1];
	size_t align=1, pad;
	void *p;

	if (!n) n++;
	while (align<n && align<ALIGN)
     5a4:	48 83 ff 01          	cmp    rdi,0x1
     5a8:	0f 86 c2 00 00 00    	jbe    670 <__simple_malloc+0xe0>
     5ae:	49 89 fc             	mov    r12,rdi
     5b1:	bb 01 00 00 00       	mov    ebx,0x1
     5b6:	66 2e 0f 1f 84 00 00 00 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
		align += align;
     5c0:	48 01 db             	add    rbx,rbx
	while (align<n && align<ALIGN)
     5c3:	48 39 dd             	cmp    rbp,rbx
     5c6:	76 06                	jbe    5ce <__simple_malloc+0x3e>
     5c8:	48 83 fb 0f          	cmp    rbx,0xf
     5cc:	76 f2                	jbe    5c0 <__simple_malloc+0x30>

	LOCK(lock);
     5ce:	bf c8 d0 00 00       	mov    edi,0xd0c8

	pad = -(uintptr_t)cur & align-1;
     5d3:	48 83 eb 01          	sub    rbx,0x1
	LOCK(lock);
     5d7:	e8 94 22 00 00       	call   2870 <__lock>
	pad = -(uintptr_t)cur & align-1;
     5dc:	48 8b 15 dd ca 00 00 	mov    rdx,QWORD PTR [rip+0xcadd]        # d0c0 <cur.1814>
     5e3:	48 89 d0             	mov    rax,rdx
     5e6:	48 f7 d8             	neg    rax
     5e9:	48 21 c3             	and    rbx,rax

	if (n <= SIZE_MAX/2 + ALIGN) n += pad;
     5ec:	48 b8 0f 00 00 00 00 00 00 80 	movabs rax,0x800000000000000f
     5f6:	49 39 c4             	cmp    r12,rax
     5f9:	0f 86 84 00 00 00    	jbe    683 <__simple_malloc+0xf3>

	if (n > end-cur) {
     5ff:	48 8b 05 b2 ca 00 00 	mov    rax,QWORD PTR [rip+0xcab2]        # d0b8 <end.1815>
     606:	4c 8d 24 1a          	lea    r12,[rdx+rbx*1]
     60a:	48 29 d0             	sub    rax,rdx
     60d:	48 39 e8             	cmp    rax,rbp
     610:	73 3d                	jae    64f <__simple_malloc+0xbf>
		size_t m = n;
		char *new = __expand_heap(&m);
     612:	48 8d 7c 24 08       	lea    rdi,[rsp+0x8]
		size_t m = n;
     617:	48 89 6c 24 08       	mov    QWORD PTR [rsp+0x8],rbp
		char *new = __expand_heap(&m);
     61c:	e8 af 2a 00 00       	call   30d0 <__expand_heap>
		if (!new) {
     621:	48 85 c0             	test   rax,rax
     624:	74 65                	je     68b <__simple_malloc+0xfb>
			UNLOCK(lock);
			return 0;
		}
		if (new != end) {
     626:	48 8b 15 93 ca 00 00 	mov    rdx,QWORD PTR [rip+0xca93]        # d0c0 <cur.1814>
     62d:	48 39 05 84 ca 00 00 	cmp    QWORD PTR [rip+0xca84],rax        # d0b8 <end.1815>
     634:	4c 8d 24 1a          	lea    r12,[rdx+rbx*1]
     638:	74 09                	je     643 <__simple_malloc+0xb3>
			cur = new;
			n -= pad;
     63a:	48 29 dd             	sub    rbp,rbx
     63d:	49 89 c4             	mov    r12,rax
     640:	48 89 c2             	mov    rdx,rax
			pad = 0;
		}
		end = new + m;
     643:	48 03 44 24 08       	add    rax,QWORD PTR [rsp+0x8]
     648:	48 89 05 69 ca 00 00 	mov    QWORD PTR [rip+0xca69],rax        # d0b8 <end.1815>
	}

	p = cur + pad;
	cur += n;
     64f:	48 01 d5             	add    rbp,rdx
	UNLOCK(lock);
     652:	bf c8 d0 00 00       	mov    edi,0xd0c8
	cur += n;
     657:	48 89 2d 62 ca 00 00 	mov    QWORD PTR [rip+0xca62],rbp        # d0c0 <cur.1814>
	UNLOCK(lock);
     65e:	e8 5d 24 00 00       	call   2ac0 <__unlock>
	return p;
}
     663:	48 83 c4 10          	add    rsp,0x10
     667:	4c 89 e0             	mov    rax,r12
     66a:	5b                   	pop    rbx
     66b:	5d                   	pop    rbp
     66c:	41 5c                	pop    r12
     66e:	c3                   	ret    
     66f:	90                   	nop
	LOCK(lock);
     670:	bf c8 d0 00 00       	mov    edi,0xd0c8
	pad = -(uintptr_t)cur & align-1;
     675:	31 db                	xor    ebx,ebx
	LOCK(lock);
     677:	e8 f4 21 00 00       	call   2870 <__lock>
	pad = -(uintptr_t)cur & align-1;
     67c:	48 8b 15 3d ca 00 00 	mov    rdx,QWORD PTR [rip+0xca3d]        # d0c0 <cur.1814>
	if (n <= SIZE_MAX/2 + ALIGN) n += pad;
     683:	48 01 dd             	add    rbp,rbx
     686:	e9 74 ff ff ff       	jmp    5ff <__simple_malloc+0x6f>
			UNLOCK(lock);
     68b:	bf c8 d0 00 00       	mov    edi,0xd0c8
			return 0;
     690:	45 31 e4             	xor    r12d,r12d
			UNLOCK(lock);
     693:	e8 28 24 00 00       	call   2ac0 <__unlock>
			return 0;
     698:	eb c9                	jmp    663 <__simple_malloc+0xd3>
     69a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

00000000000006a0 <__simple_calloc>:

weak_alias(__simple_malloc, malloc);

static void *__simple_calloc(size_t m, size_t n)
{
	if (n && m > (size_t)-1/n) {
     6a0:	48 85 f6             	test   rsi,rsi
     6a3:	74 08                	je     6ad <__simple_calloc+0xd>
     6a5:	48 89 f8             	mov    rax,rdi
     6a8:	48 f7 e6             	mul    rsi
     6ab:	70 09                	jo     6b6 <__simple_calloc+0x16>
		errno = ENOMEM;
		return 0;
	}
	return __simple_malloc(n * m);
     6ad:	48 0f af fe          	imul   rdi,rsi
     6b1:	e9 da fe ff ff       	jmp    590 <__simple_malloc>
{
     6b6:	50                   	push   rax
		errno = ENOMEM;
     6b7:	e8 c4 29 00 00       	call   3080 <__errno_location>
     6bc:	c7 00 0c 00 00 00    	mov    DWORD PTR [rax],0xc
}
     6c2:	31 c0                	xor    eax,eax
     6c4:	5a                   	pop    rdx
     6c5:	c3                   	ret    
     6c6:	66 2e 0f 1f 84 00 00 00 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]

00000000000006d0 <alloc_fwd>:
	c->csize |= C_INUSE;
	NEXT_CHUNK(c)->psize |= C_INUSE;
}

static int alloc_fwd(struct chunk *c)
{
     6d0:	41 57                	push   r15
     6d2:	41 56                	push   r14
     6d4:	41 55                	push   r13
     6d6:	41 54                	push   r12
     6d8:	55                   	push   rbp
     6d9:	53                   	push   rbx
     6da:	48 83 ec 18          	sub    rsp,0x18
     6de:	48 89 7c 24 08       	mov    QWORD PTR [rsp+0x8],rdi
	int i;
	size_t k;
	while (!((k=c->csize) & C_INUSE)) {
     6e3:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
     6e8:	48 8b 44 24 08       	mov    rax,QWORD PTR [rsp+0x8]
     6ed:	4c 8b 78 08          	mov    r15,QWORD PTR [rax+0x8]
     6f1:	41 f6 c7 01          	test   r15b,0x1
     6f5:	0f 85 62 01 00 00    	jne    85d <alloc_fwd+0x18d>
	x = x / SIZE_ALIGN - 1;
     6fb:	4c 89 f8             	mov    rax,r15
     6fe:	48 c1 e8 05          	shr    rax,0x5
     702:	48 83 e8 01          	sub    rax,0x1
	if (x <= 32) return x;
     706:	48 83 f8 20          	cmp    rax,0x20
     70a:	0f 86 60 01 00 00    	jbe    870 <alloc_fwd+0x1a0>
	if (x < 512) return bin_tab[x/8-4];
     710:	48 3d ff 01 00 00    	cmp    rax,0x1ff
     716:	0f 86 74 01 00 00    	jbe    890 <alloc_fwd+0x1c0>
	if (x > 0x1c00) return 63;
     71c:	48 3d 00 1c 00 00    	cmp    rax,0x1c00
     722:	0f 87 90 01 00 00    	ja     8b8 <alloc_fwd+0x1e8>
	return bin_tab[x/128-4] + 16;
     728:	48 c1 e8 07          	shr    rax,0x7
     72c:	44 0f b6 a8 1c 80 00 00 	movzx  r13d,BYTE PTR [rax+0x801c]
     734:	41 83 c5 10          	add    r13d,0x10
     738:	4d 63 e5             	movsxd r12,r13d
     73b:	4f 8d 34 64          	lea    r14,[r12+r12*2]
     73f:	49 c1 e6 03          	shl    r14,0x3
     743:	49 8d 46 08          	lea    rax,[r14+0x8]
	if (libc.threads_minus_1)
     747:	8b 15 df c8 00 00    	mov    edx,DWORD PTR [rip+0xc8df]        # d02c <__libc+0xc>
	lock(mal.bins[i].lock);
     74d:	48 8d a8 00 d1 00 00 	lea    rbp,[rax+0xd100]
	if (libc.threads_minus_1)
     754:	85 d2                	test   edx,edx
     756:	0f 84 b4 00 00 00    	je     810 <alloc_fwd+0x140>
	__asm__ __volatile__(
     75c:	ba 01 00 00 00       	mov    edx,0x1
     761:	87 90 00 d1 00 00    	xchg   DWORD PTR [rax+0xd100],edx
	return v;
     767:	48 8d 5d 04          	lea    rbx,[rbp+0x4]
		while(a_swap(lk, 1)) __wait(lk, lk+1, 1, 1);
     76b:	85 d2                	test   edx,edx
     76d:	74 22                	je     791 <alloc_fwd+0xc1>
     76f:	90                   	nop
     770:	b9 01 00 00 00       	mov    ecx,0x1
     775:	ba 01 00 00 00       	mov    edx,0x1
     77a:	48 89 de             	mov    rsi,rbx
     77d:	48 89 ef             	mov    rdi,rbp
     780:	e8 9b 23 00 00       	call   2b20 <__wait>
	__asm__ __volatile__(
     785:	b8 01 00 00 00       	mov    eax,0x1
     78a:	87 45 00             	xchg   DWORD PTR [rbp+0x0],eax
     78d:	85 c0                	test   eax,eax
     78f:	75 df                	jne    770 <alloc_fwd+0xa0>
	if (!mal.bins[i].head)
     791:	48 8b 44 24 08       	mov    rax,QWORD PTR [rsp+0x8]
     796:	4b 8d 14 64          	lea    rdx,[r12+r12*2]
     79a:	48 83 3c d5 10 d1 00 00 00 	cmp    QWORD PTR [rdx*8+0xd110],0x0
     7a3:	48 8b 40 08          	mov    rax,QWORD PTR [rax+0x8]
     7a7:	74 7d                	je     826 <alloc_fwd+0x156>
		i = bin_index(k);
		lock_bin(i);
		if (c->csize == k) {
     7a9:	49 39 c7             	cmp    r15,rax
     7ac:	0f 84 26 01 00 00    	je     8d8 <alloc_fwd+0x208>
	if (lk[0]) {
     7b2:	8b 55 00             	mov    edx,DWORD PTR [rbp+0x0]
     7b5:	85 d2                	test   edx,edx
     7b7:	0f 84 93 00 00 00    	je     850 <alloc_fwd+0x180>
	__asm__ __volatile__(
     7bd:	31 c0                	xor    eax,eax
     7bf:	89 45 00             	mov    DWORD PTR [rbp+0x0],eax
     7c2:	f0 83 0c 24 00       	lock or DWORD PTR [rsp],0x0
		if (lk[1]) __wake(lk, 1, 1);
     7c7:	8b 45 04             	mov    eax,DWORD PTR [rbp+0x4]
     7ca:	85 c0                	test   eax,eax
     7cc:	0f 84 16 ff ff ff    	je     6e8 <alloc_fwd+0x18>
hidden void __wait(volatile int *, volatile int *, int, int);
static inline void __wake(volatile void *addr, int cnt, int priv)
{
	if (priv) priv = FUTEX_PRIVATE;
	if (cnt<0) cnt = INT_MAX;
	__syscall(SYS_futex, addr, FUTEX_WAKE|priv, cnt) != -ENOSYS ||
     7d2:	b9 01 00 00 00       	mov    ecx,0x1
     7d7:	ba 81 00 00 00       	mov    edx,0x81
     7dc:	48 89 ee             	mov    rsi,rbp
     7df:	bf ca 00 00 00       	mov    edi,0xca
     7e4:	e8 37 1f 00 00       	call   2720 <__syscall3>
     7e9:	48 83 f8 da          	cmp    rax,0xffffffffffffffda
     7ed:	0f 85 f5 fe ff ff    	jne    6e8 <alloc_fwd+0x18>
	__syscall(SYS_futex, addr, FUTEX_WAKE, cnt);
     7f3:	b9 01 00 00 00       	mov    ecx,0x1
     7f8:	ba 01 00 00 00       	mov    edx,0x1
     7fd:	48 89 ee             	mov    rsi,rbp
     800:	bf ca 00 00 00       	mov    edi,0xca
     805:	e8 16 1f 00 00       	call   2720 <__syscall3>
     80a:	e9 d9 fe ff ff       	jmp    6e8 <alloc_fwd+0x18>
     80f:	90                   	nop
	if (!mal.bins[i].head)
     810:	4b 8d 04 64          	lea    rax,[r12+r12*2]
     814:	48 83 3c c5 10 d1 00 00 00 	cmp    QWORD PTR [rax*8+0xd110],0x0
     81d:	0f 85 b5 00 00 00    	jne    8d8 <alloc_fwd+0x208>
     823:	4c 89 f8             	mov    rax,r15
		mal.bins[i].head = mal.bins[i].tail = BIN_TO_CHUNK(i);
     826:	4b 8d 14 64          	lea    rdx,[r12+r12*2]
     82a:	49 81 c6 00 d1 00 00 	add    r14,0xd100
     831:	48 8d 14 d5 00 d1 00 00 	lea    rdx,[rdx*8+0xd100]
     839:	4c 89 72 18          	mov    QWORD PTR [rdx+0x18],r14
     83d:	4c 89 72 10          	mov    QWORD PTR [rdx+0x10],r14
     841:	e9 63 ff ff ff       	jmp    7a9 <alloc_fwd+0xd9>
     846:	66 2e 0f 1f 84 00 00 00 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
     850:	49 89 c7             	mov    r15,rax
	while (!((k=c->csize) & C_INUSE)) {
     853:	41 f6 c7 01          	test   r15b,0x1
     857:	0f 84 9e fe ff ff    	je     6fb <alloc_fwd+0x2b>
			return 1;
		}
		unlock_bin(i);
	}
	return 0;
}
     85d:	48 83 c4 18          	add    rsp,0x18
	return 0;
     861:	31 c0                	xor    eax,eax
}
     863:	5b                   	pop    rbx
     864:	5d                   	pop    rbp
     865:	41 5c                	pop    r12
     867:	41 5d                	pop    r13
     869:	41 5e                	pop    r14
     86b:	41 5f                	pop    r15
     86d:	c3                   	ret    
     86e:	66 90                	xchg   ax,ax
	if (x <= 32) return x;
     870:	4c 8d 34 40          	lea    r14,[rax+rax*2]
     874:	4c 63 e0             	movsxd r12,eax
     877:	49 c1 e6 03          	shl    r14,0x3
     87b:	4d 89 e5             	mov    r13,r12
     87e:	49 8d 46 08          	lea    rax,[r14+0x8]
     882:	e9 c0 fe ff ff       	jmp    747 <alloc_fwd+0x77>
     887:	66 0f 1f 84 00 00 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
	if (x < 512) return bin_tab[x/8-4];
     890:	48 c1 e8 03          	shr    rax,0x3
     894:	44 0f b6 a8 1c 80 00 00 	movzx  r13d,BYTE PTR [rax+0x801c]
     89c:	41 0f b6 c5          	movzx  eax,r13b
     8a0:	4d 89 ec             	mov    r12,r13
     8a3:	4c 8d 34 40          	lea    r14,[rax+rax*2]
     8a7:	49 c1 e6 03          	shl    r14,0x3
     8ab:	49 8d 46 08          	lea    rax,[r14+0x8]
     8af:	e9 93 fe ff ff       	jmp    747 <alloc_fwd+0x77>
     8b4:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
     8b8:	41 be e8 05 00 00    	mov    r14d,0x5e8
     8be:	b8 f0 05 00 00       	mov    eax,0x5f0
	if (x > 0x1c00) return 63;
     8c3:	41 bd 3f 00 00 00    	mov    r13d,0x3f
     8c9:	41 bc 3f 00 00 00    	mov    r12d,0x3f
     8cf:	e9 73 fe ff ff       	jmp    747 <alloc_fwd+0x77>
     8d4:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
	if (c->prev == c->next)
     8d8:	48 8b 44 24 08       	mov    rax,QWORD PTR [rsp+0x8]
     8dd:	48 8b 50 18          	mov    rdx,QWORD PTR [rax+0x18]
     8e1:	48 8b 40 10          	mov    rax,QWORD PTR [rax+0x10]
     8e5:	48 39 c2             	cmp    rdx,rax
     8e8:	0f 84 8a 00 00 00    	je     978 <alloc_fwd+0x2a8>
	c->prev->next = c->next;
     8ee:	48 89 42 10          	mov    QWORD PTR [rdx+0x10],rax
	c->csize |= C_INUSE;
     8f2:	48 8b 74 24 08       	mov    rsi,QWORD PTR [rsp+0x8]
	c->next->prev = c->prev;
     8f7:	48 89 50 18          	mov    QWORD PTR [rax+0x18],rdx
	c->csize |= C_INUSE;
     8fb:	4c 89 f8             	mov    rax,r15
	NEXT_CHUNK(c)->psize |= C_INUSE;
     8fe:	49 83 e7 fe          	and    r15,0xfffffffffffffffe
	c->csize |= C_INUSE;
     902:	48 83 c8 01          	or     rax,0x1
     906:	48 89 46 08          	mov    QWORD PTR [rsi+0x8],rax
	if (lk[0]) {
     90a:	8b 45 00             	mov    eax,DWORD PTR [rbp+0x0]
	NEXT_CHUNK(c)->psize |= C_INUSE;
     90d:	4a 83 0c 3e 01       	or     QWORD PTR [rsi+r15*1],0x1
	if (lk[0]) {
     912:	85 c0                	test   eax,eax
     914:	74 11                	je     927 <alloc_fwd+0x257>
     916:	31 c0                	xor    eax,eax
     918:	89 45 00             	mov    DWORD PTR [rbp+0x0],eax
     91b:	f0 83 0c 24 00       	lock or DWORD PTR [rsp],0x0
		if (lk[1]) __wake(lk, 1, 1);
     920:	8b 45 04             	mov    eax,DWORD PTR [rbp+0x4]
     923:	85 c0                	test   eax,eax
     925:	75 14                	jne    93b <alloc_fwd+0x26b>
}
     927:	48 83 c4 18          	add    rsp,0x18
			return 1;
     92b:	b8 01 00 00 00       	mov    eax,0x1
}
     930:	5b                   	pop    rbx
     931:	5d                   	pop    rbp
     932:	41 5c                	pop    r12
     934:	41 5d                	pop    r13
     936:	41 5e                	pop    r14
     938:	41 5f                	pop    r15
     93a:	c3                   	ret    
	__syscall(SYS_futex, addr, FUTEX_WAKE|priv, cnt) != -ENOSYS ||
     93b:	b9 01 00 00 00       	mov    ecx,0x1
     940:	ba 81 00 00 00       	mov    edx,0x81
     945:	48 89 ee             	mov    rsi,rbp
     948:	bf ca 00 00 00       	mov    edi,0xca
     94d:	e8 ce 1d 00 00       	call   2720 <__syscall3>
     952:	48 83 f8 da          	cmp    rax,0xffffffffffffffda
     956:	75 cf                	jne    927 <alloc_fwd+0x257>
	__syscall(SYS_futex, addr, FUTEX_WAKE, cnt);
     958:	b9 01 00 00 00       	mov    ecx,0x1
     95d:	ba 01 00 00 00       	mov    edx,0x1
     962:	48 89 ee             	mov    rsi,rbp
     965:	bf ca 00 00 00       	mov    edi,0xca
     96a:	e8 b1 1d 00 00       	call   2720 <__syscall3>
     96f:	eb b6                	jmp    927 <alloc_fwd+0x257>
     971:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
		a_and_64(&mal.binmap, ~(1ULL<<i));
     978:	44 89 e9             	mov    ecx,r13d
     97b:	48 c7 c0 fe ff ff ff 	mov    rax,0xfffffffffffffffe
     982:	48 d3 c0             	rol    rax,cl
	__asm__ __volatile(
     985:	f0 48 21 05 73 c7 00 00 	lock and QWORD PTR [rip+0xc773],rax        # d100 <mal>
     98d:	48 8b 4c 24 08       	mov    rcx,QWORD PTR [rsp+0x8]
     992:	48 8b 51 18          	mov    rdx,QWORD PTR [rcx+0x18]
     996:	48 8b 41 10          	mov    rax,QWORD PTR [rcx+0x10]
     99a:	4c 8b 79 08          	mov    r15,QWORD PTR [rcx+0x8]
}
     99e:	e9 4b ff ff ff       	jmp    8ee <alloc_fwd+0x21e>
     9a3:	66 66 2e 0f 1f 84 00 00 00 00 00 	data16 nop WORD PTR cs:[rax+rax*1+0x0]
     9ae:	66 90                	xchg   ax,ax

00000000000009b0 <alloc_rev>:

static int alloc_rev(struct chunk *c)
{
     9b0:	41 57                	push   r15
     9b2:	41 56                	push   r14
     9b4:	41 55                	push   r13
     9b6:	41 54                	push   r12
     9b8:	55                   	push   rbp
     9b9:	53                   	push   rbx
     9ba:	48 83 ec 18          	sub    rsp,0x18
     9be:	48 89 7c 24 08       	mov    QWORD PTR [rsp+0x8],rdi
	int i;
	size_t k;
	while (!((k=c->psize) & C_INUSE)) {
     9c3:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
     9c8:	48 8b 44 24 08       	mov    rax,QWORD PTR [rsp+0x8]
     9cd:	4c 8b 38             	mov    r15,QWORD PTR [rax]
     9d0:	41 f6 c7 01          	test   r15b,0x1
     9d4:	0f 85 63 01 00 00    	jne    b3d <alloc_rev+0x18d>
	x = x / SIZE_ALIGN - 1;
     9da:	4c 89 f8             	mov    rax,r15
     9dd:	48 c1 e8 05          	shr    rax,0x5
     9e1:	48 83 e8 01          	sub    rax,0x1
	if (x <= 32) return x;
     9e5:	48 83 f8 20          	cmp    rax,0x20
     9e9:	0f 86 61 01 00 00    	jbe    b50 <alloc_rev+0x1a0>
	if (x < 512) return bin_tab[x/8-4];
     9ef:	48 3d ff 01 00 00    	cmp    rax,0x1ff
     9f5:	0f 86 75 01 00 00    	jbe    b70 <alloc_rev+0x1c0>
	if (x > 0x1c00) return 63;
     9fb:	48 3d 00 1c 00 00    	cmp    rax,0x1c00
     a01:	0f 87 91 01 00 00    	ja     b98 <alloc_rev+0x1e8>
	return bin_tab[x/128-4] + 16;
     a07:	48 c1 e8 07          	shr    rax,0x7
     a0b:	44 0f b6 a8 1c 80 00 00 	movzx  r13d,BYTE PTR [rax+0x801c]
     a13:	41 83 c5 10          	add    r13d,0x10
     a17:	4d 63 e5             	movsxd r12,r13d
     a1a:	4f 8d 34 64          	lea    r14,[r12+r12*2]
     a1e:	49 c1 e6 03          	shl    r14,0x3
     a22:	49 8d 46 08          	lea    rax,[r14+0x8]
	if (libc.threads_minus_1)
     a26:	8b 15 00 c6 00 00    	mov    edx,DWORD PTR [rip+0xc600]        # d02c <__libc+0xc>
	lock(mal.bins[i].lock);
     a2c:	48 8d a8 00 d1 00 00 	lea    rbp,[rax+0xd100]
	if (libc.threads_minus_1)
     a33:	85 d2                	test   edx,edx
     a35:	0f 84 b5 00 00 00    	je     af0 <alloc_rev+0x140>
	__asm__ __volatile__(
     a3b:	ba 01 00 00 00       	mov    edx,0x1
     a40:	87 90 00 d1 00 00    	xchg   DWORD PTR [rax+0xd100],edx
	return v;
     a46:	48 8d 5d 04          	lea    rbx,[rbp+0x4]
		while(a_swap(lk, 1)) __wait(lk, lk+1, 1, 1);
     a4a:	85 d2                	test   edx,edx
     a4c:	74 23                	je     a71 <alloc_rev+0xc1>
     a4e:	66 90                	xchg   ax,ax
     a50:	b9 01 00 00 00       	mov    ecx,0x1
     a55:	ba 01 00 00 00       	mov    edx,0x1
     a5a:	48 89 de             	mov    rsi,rbx
     a5d:	48 89 ef             	mov    rdi,rbp
     a60:	e8 bb 20 00 00       	call   2b20 <__wait>
	__asm__ __volatile__(
     a65:	b8 01 00 00 00       	mov    eax,0x1
     a6a:	87 45 00             	xchg   DWORD PTR [rbp+0x0],eax
     a6d:	85 c0                	test   eax,eax
     a6f:	75 df                	jne    a50 <alloc_rev+0xa0>
	if (!mal.bins[i].head)
     a71:	48 8b 44 24 08       	mov    rax,QWORD PTR [rsp+0x8]
     a76:	4b 8d 14 64          	lea    rdx,[r12+r12*2]
     a7a:	48 83 3c d5 10 d1 00 00 00 	cmp    QWORD PTR [rdx*8+0xd110],0x0
     a83:	48 8b 00             	mov    rax,QWORD PTR [rax]
     a86:	74 7e                	je     b06 <alloc_rev+0x156>
		i = bin_index(k);
		lock_bin(i);
		if (c->psize == k) {
     a88:	49 39 c7             	cmp    r15,rax
     a8b:	0f 84 27 01 00 00    	je     bb8 <alloc_rev+0x208>
	if (lk[0]) {
     a91:	8b 55 00             	mov    edx,DWORD PTR [rbp+0x0]
     a94:	85 d2                	test   edx,edx
     a96:	0f 84 94 00 00 00    	je     b30 <alloc_rev+0x180>
	__asm__ __volatile__(
     a9c:	31 c0                	xor    eax,eax
     a9e:	89 45 00             	mov    DWORD PTR [rbp+0x0],eax
     aa1:	f0 83 0c 24 00       	lock or DWORD PTR [rsp],0x0
		if (lk[1]) __wake(lk, 1, 1);
     aa6:	8b 45 04             	mov    eax,DWORD PTR [rbp+0x4]
     aa9:	85 c0                	test   eax,eax
     aab:	0f 84 17 ff ff ff    	je     9c8 <alloc_rev+0x18>
	__syscall(SYS_futex, addr, FUTEX_WAKE|priv, cnt) != -ENOSYS ||
     ab1:	b9 01 00 00 00       	mov    ecx,0x1
     ab6:	ba 81 00 00 00       	mov    edx,0x81
     abb:	48 89 ee             	mov    rsi,rbp
     abe:	bf ca 00 00 00       	mov    edi,0xca
     ac3:	e8 58 1c 00 00       	call   2720 <__syscall3>
     ac8:	48 83 f8 da          	cmp    rax,0xffffffffffffffda
     acc:	0f 85 f6 fe ff ff    	jne    9c8 <alloc_rev+0x18>
	__syscall(SYS_futex, addr, FUTEX_WAKE, cnt);
     ad2:	b9 01 00 00 00       	mov    ecx,0x1
     ad7:	ba 01 00 00 00       	mov    edx,0x1
     adc:	48 89 ee             	mov    rsi,rbp
     adf:	bf ca 00 00 00       	mov    edi,0xca
     ae4:	e8 37 1c 00 00       	call   2720 <__syscall3>
     ae9:	e9 da fe ff ff       	jmp    9c8 <alloc_rev+0x18>
     aee:	66 90                	xchg   ax,ax
	if (!mal.bins[i].head)
     af0:	4b 8d 04 64          	lea    rax,[r12+r12*2]
     af4:	48 83 3c c5 10 d1 00 00 00 	cmp    QWORD PTR [rax*8+0xd110],0x0
     afd:	0f 85 b5 00 00 00    	jne    bb8 <alloc_rev+0x208>
     b03:	4c 89 f8             	mov    rax,r15
		mal.bins[i].head = mal.bins[i].tail = BIN_TO_CHUNK(i);
     b06:	4b 8d 14 64          	lea    rdx,[r12+r12*2]
     b0a:	49 81 c6 00 d1 00 00 	add    r14,0xd100
     b11:	48 8d 14 d5 00 d1 00 00 	lea    rdx,[rdx*8+0xd100]
     b19:	4c 89 72 18          	mov    QWORD PTR [rdx+0x18],r14
     b1d:	4c 89 72 10          	mov    QWORD PTR [rdx+0x10],r14
     b21:	e9 62 ff ff ff       	jmp    a88 <alloc_rev+0xd8>
     b26:	66 2e 0f 1f 84 00 00 00 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
     b30:	49 89 c7             	mov    r15,rax
	while (!((k=c->psize) & C_INUSE)) {
     b33:	41 f6 c7 01          	test   r15b,0x1
     b37:	0f 84 9d fe ff ff    	je     9da <alloc_rev+0x2a>
			return 1;
		}
		unlock_bin(i);
	}
	return 0;
}
     b3d:	48 83 c4 18          	add    rsp,0x18
	return 0;
     b41:	31 c0                	xor    eax,eax
}
     b43:	5b                   	pop    rbx
     b44:	5d                   	pop    rbp
     b45:	41 5c                	pop    r12
     b47:	41 5d                	pop    r13
     b49:	41 5e                	pop    r14
     b4b:	41 5f                	pop    r15
     b4d:	c3                   	ret    
     b4e:	66 90                	xchg   ax,ax
	if (x <= 32) return x;
     b50:	4c 8d 34 40          	lea    r14,[rax+rax*2]
     b54:	4c 63 e0             	movsxd r12,eax
     b57:	49 c1 e6 03          	shl    r14,0x3
     b5b:	4d 89 e5             	mov    r13,r12
     b5e:	49 8d 46 08          	lea    rax,[r14+0x8]
     b62:	e9 bf fe ff ff       	jmp    a26 <alloc_rev+0x76>
     b67:	66 0f 1f 84 00 00 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
	if (x < 512) return bin_tab[x/8-4];
     b70:	48 c1 e8 03          	shr    rax,0x3
     b74:	44 0f b6 a8 1c 80 00 00 	movzx  r13d,BYTE PTR [rax+0x801c]
     b7c:	41 0f b6 c5          	movzx  eax,r13b
     b80:	4d 89 ec             	mov    r12,r13
     b83:	4c 8d 34 40          	lea    r14,[rax+rax*2]
     b87:	49 c1 e6 03          	shl    r14,0x3
     b8b:	49 8d 46 08          	lea    rax,[r14+0x8]
     b8f:	e9 92 fe ff ff       	jmp    a26 <alloc_rev+0x76>
     b94:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
     b98:	41 be e8 05 00 00    	mov    r14d,0x5e8
     b9e:	b8 f0 05 00 00       	mov    eax,0x5f0
	if (x > 0x1c00) return 63;
     ba3:	41 bd 3f 00 00 00    	mov    r13d,0x3f
     ba9:	41 bc 3f 00 00 00    	mov    r12d,0x3f
     baf:	e9 72 fe ff ff       	jmp    a26 <alloc_rev+0x76>
     bb4:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
			unbin(PREV_CHUNK(c), i);
     bb8:	48 8b 5c 24 08       	mov    rbx,QWORD PTR [rsp+0x8]
     bbd:	49 83 e7 fe          	and    r15,0xfffffffffffffffe
     bc1:	4c 29 fb             	sub    rbx,r15
	if (c->prev == c->next)
     bc4:	48 8b 53 18          	mov    rdx,QWORD PTR [rbx+0x18]
     bc8:	48 8b 43 10          	mov    rax,QWORD PTR [rbx+0x10]
     bcc:	48 39 c2             	cmp    rdx,rax
     bcf:	0f 84 8b 00 00 00    	je     c60 <alloc_rev+0x2b0>
	c->prev->next = c->next;
     bd5:	48 89 42 10          	mov    QWORD PTR [rdx+0x10],rax
	c->next->prev = c->prev;
     bd9:	48 89 50 18          	mov    QWORD PTR [rax+0x18],rdx
	c->csize |= C_INUSE;
     bdd:	48 8b 43 08          	mov    rax,QWORD PTR [rbx+0x8]
     be1:	48 89 c2             	mov    rdx,rax
	NEXT_CHUNK(c)->psize |= C_INUSE;
     be4:	48 83 e0 fe          	and    rax,0xfffffffffffffffe
	c->csize |= C_INUSE;
     be8:	48 83 ca 01          	or     rdx,0x1
     bec:	48 89 53 08          	mov    QWORD PTR [rbx+0x8],rdx
	NEXT_CHUNK(c)->psize |= C_INUSE;
     bf0:	48 83 0c 03 01       	or     QWORD PTR [rbx+rax*1],0x1
	if (lk[0]) {
     bf5:	8b 45 00             	mov    eax,DWORD PTR [rbp+0x0]
     bf8:	85 c0                	test   eax,eax
     bfa:	74 11                	je     c0d <alloc_rev+0x25d>
     bfc:	31 c0                	xor    eax,eax
     bfe:	89 45 00             	mov    DWORD PTR [rbp+0x0],eax
     c01:	f0 83 0c 24 00       	lock or DWORD PTR [rsp],0x0
		if (lk[1]) __wake(lk, 1, 1);
     c06:	8b 45 04             	mov    eax,DWORD PTR [rbp+0x4]
     c09:	85 c0                	test   eax,eax
     c0b:	75 14                	jne    c21 <alloc_rev+0x271>
}
     c0d:	48 83 c4 18          	add    rsp,0x18
			return 1;
     c11:	b8 01 00 00 00       	mov    eax,0x1
}
     c16:	5b                   	pop    rbx
     c17:	5d                   	pop    rbp
     c18:	41 5c                	pop    r12
     c1a:	41 5d                	pop    r13
     c1c:	41 5e                	pop    r14
     c1e:	41 5f                	pop    r15
     c20:	c3                   	ret    
	__syscall(SYS_futex, addr, FUTEX_WAKE|priv, cnt) != -ENOSYS ||
     c21:	b9 01 00 00 00       	mov    ecx,0x1
     c26:	ba 81 00 00 00       	mov    edx,0x81
     c2b:	48 89 ee             	mov    rsi,rbp
     c2e:	bf ca 00 00 00       	mov    edi,0xca
     c33:	e8 e8 1a 00 00       	call   2720 <__syscall3>
     c38:	48 83 f8 da          	cmp    rax,0xffffffffffffffda
     c3c:	75 cf                	jne    c0d <alloc_rev+0x25d>
	__syscall(SYS_futex, addr, FUTEX_WAKE, cnt);
     c3e:	b9 01 00 00 00       	mov    ecx,0x1
     c43:	ba 01 00 00 00       	mov    edx,0x1
     c48:	48 89 ee             	mov    rsi,rbp
     c4b:	bf ca 00 00 00       	mov    edi,0xca
     c50:	e8 cb 1a 00 00       	call   2720 <__syscall3>
     c55:	eb b6                	jmp    c0d <alloc_rev+0x25d>
     c57:	66 0f 1f 84 00 00 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
		a_and_64(&mal.binmap, ~(1ULL<<i));
     c60:	44 89 e9             	mov    ecx,r13d
     c63:	48 c7 c0 fe ff ff ff 	mov    rax,0xfffffffffffffffe
     c6a:	48 d3 c0             	rol    rax,cl
	__asm__ __volatile(
     c6d:	f0 48 21 05 8b c4 00 00 	lock and QWORD PTR [rip+0xc48b],rax        # d100 <mal>
     c75:	48 8b 53 18          	mov    rdx,QWORD PTR [rbx+0x18]
     c79:	48 8b 43 10          	mov    rax,QWORD PTR [rbx+0x10]
}
     c7d:	e9 53 ff ff ff       	jmp    bd5 <alloc_rev+0x225>
     c82:	66 66 2e 0f 1f 84 00 00 00 00 00 	data16 nop WORD PTR cs:[rax+rax*1+0x0]
     c8d:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000000c90 <__bin_chunk>:
	free(CHUNK_TO_MEM(self));
	return new;
}

void __bin_chunk(struct chunk *self)
{
     c90:	41 57                	push   r15
     c92:	49 89 ff             	mov    r15,rdi
     c95:	41 56                	push   r14
     c97:	41 55                	push   r13
     c99:	41 54                	push   r12
     c9b:	55                   	push   rbp
     c9c:	53                   	push   rbx
     c9d:	48 83 ec 28          	sub    rsp,0x28
	struct chunk *next = NEXT_CHUNK(self);
     ca1:	48 8b 47 08          	mov    rax,QWORD PTR [rdi+0x8]
     ca5:	48 89 c1             	mov    rcx,rax
     ca8:	48 83 e1 fe          	and    rcx,0xfffffffffffffffe
     cac:	48 8d 1c 0f          	lea    rbx,[rdi+rcx*1]
     cb0:	48 89 4c 24 08       	mov    QWORD PTR [rsp+0x8],rcx
	int i;

	final_size = new_size = CHUNK_SIZE(self);

	/* Crash on corrupted footer (likely from buffer overflow) */
	if (next->psize != self->csize) a_crash();
     cb5:	48 3b 03             	cmp    rax,QWORD PTR [rbx]
     cb8:	74 01                	je     cbb <__bin_chunk+0x2b>
	__asm__ __volatile__( "hlt" : : : "memory" );
     cba:	f4                   	hlt    
{
     cbb:	c7 44 24 18 00 00 00 00 	mov    DWORD PTR [rsp+0x18],0x0
     cc3:	48 8b 6c 24 08       	mov    rbp,QWORD PTR [rsp+0x8]
	__asm__ __volatile__(
     cc8:	41 bd 01 00 00 00    	mov    r13d,0x1
     cce:	66 90                	xchg   ax,ax

	for (;;) {
		if (self->psize & next->csize & C_INUSE) {
     cd0:	49 8b 07             	mov    rax,QWORD PTR [r15]
     cd3:	48 23 43 08          	and    rax,QWORD PTR [rbx+0x8]
     cd7:	a8 01                	test   al,0x1
     cd9:	0f 84 58 01 00 00    	je     e37 <__bin_chunk+0x1a7>
			self->csize = final_size | C_INUSE;
     cdf:	48 89 e8             	mov    rax,rbp
     ce2:	48 83 c8 01          	or     rax,0x1
     ce6:	49 89 47 08          	mov    QWORD PTR [r15+0x8],rax
			next->psize = final_size | C_INUSE;
     cea:	48 89 03             	mov    QWORD PTR [rbx],rax
	x = x / SIZE_ALIGN - 1;
     ced:	48 89 e8             	mov    rax,rbp
     cf0:	48 c1 e8 05          	shr    rax,0x5
     cf4:	48 83 e8 01          	sub    rax,0x1
	if (x <= 32) return x;
     cf8:	48 83 f8 20          	cmp    rax,0x20
     cfc:	0f 86 c6 01 00 00    	jbe    ec8 <__bin_chunk+0x238>
	if (x < 512) return bin_tab[x/8-4];
     d02:	48 3d ff 01 00 00    	cmp    rax,0x1ff
     d08:	0f 86 02 02 00 00    	jbe    f10 <__bin_chunk+0x280>
	if (x > 0x1c00) return 63;
     d0e:	48 3d 00 1c 00 00    	cmp    rax,0x1c00
     d14:	0f 87 66 03 00 00    	ja     1080 <__bin_chunk+0x3f0>
	return bin_tab[x/128-4] + 16;
     d1a:	48 c1 e8 07          	shr    rax,0x7
     d1e:	0f b6 80 1c 80 00 00 	movzx  eax,BYTE PTR [rax+0x801c]
     d25:	83 c0 10             	add    eax,0x10
     d28:	4c 63 e0             	movsxd r12,eax
     d2b:	89 44 24 1c          	mov    DWORD PTR [rsp+0x1c],eax
     d2f:	4f 8d 34 64          	lea    r14,[r12+r12*2]
     d33:	4a 8d 04 f5 00 00 00 00 	lea    rax,[r14*8+0x0]
     d3b:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
     d40:	48 8d 50 08          	lea    rdx,[rax+0x8]
	if (libc.threads_minus_1)
     d44:	8b 05 e2 c2 00 00    	mov    eax,DWORD PTR [rip+0xc2e2]        # d02c <__libc+0xc>
	lock(mal.bins[i].lock);
     d4a:	4c 8d b2 00 d1 00 00 	lea    r14,[rdx+0xd100]
	if (libc.threads_minus_1)
     d51:	85 c0                	test   eax,eax
     d53:	74 3b                	je     d90 <__bin_chunk+0x100>
     d55:	44 89 e8             	mov    eax,r13d
     d58:	87 82 00 d1 00 00    	xchg   DWORD PTR [rdx+0xd100],eax
		while(a_swap(lk, 1)) __wait(lk, lk+1, 1, 1);
     d5e:	85 c0                	test   eax,eax
     d60:	74 2e                	je     d90 <__bin_chunk+0x100>
     d62:	49 8d 46 04          	lea    rax,[r14+0x4]
     d66:	48 89 04 24          	mov    QWORD PTR [rsp],rax
     d6a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
     d70:	48 8b 34 24          	mov    rsi,QWORD PTR [rsp]
     d74:	b9 01 00 00 00       	mov    ecx,0x1
     d79:	ba 01 00 00 00       	mov    edx,0x1
     d7e:	4c 89 f7             	mov    rdi,r14
     d81:	e8 9a 1d 00 00       	call   2b20 <__wait>
     d86:	44 89 e8             	mov    eax,r13d
     d89:	41 87 06             	xchg   DWORD PTR [r14],eax
     d8c:	85 c0                	test   eax,eax
     d8e:	75 e0                	jne    d70 <__bin_chunk+0xe0>
	if (!mal.bins[i].head)
     d90:	4b 8d 04 64          	lea    rax,[r12+r12*2]
     d94:	48 8d 04 c5 00 d1 00 00 	lea    rax,[rax*8+0xd100]
     d9c:	48 83 78 10 00       	cmp    QWORD PTR [rax+0x10],0x0
     da1:	0f 84 49 01 00 00    	je     ef0 <__bin_chunk+0x260>
	if (libc.threads_minus_1)
     da7:	8b 05 7f c2 00 00    	mov    eax,DWORD PTR [rip+0xc27f]        # d02c <__libc+0xc>
     dad:	85 c0                	test   eax,eax
     daf:	74 35                	je     de6 <__bin_chunk+0x156>
     db1:	44 89 e8             	mov    eax,r13d
     db4:	87 05 4e c9 00 00    	xchg   DWORD PTR [rip+0xc94e],eax        # d708 <mal+0x608>
		while(a_swap(lk, 1)) __wait(lk, lk+1, 1, 1);
     dba:	85 c0                	test   eax,eax
     dbc:	74 28                	je     de6 <__bin_chunk+0x156>
     dbe:	66 90                	xchg   ax,ax
     dc0:	b9 01 00 00 00       	mov    ecx,0x1
     dc5:	ba 01 00 00 00       	mov    edx,0x1
     dca:	be 0c d7 00 00       	mov    esi,0xd70c
     dcf:	bf 08 d7 00 00       	mov    edi,0xd708
     dd4:	e8 47 1d 00 00       	call   2b20 <__wait>
     dd9:	44 89 e8             	mov    eax,r13d
     ddc:	87 05 26 c9 00 00    	xchg   DWORD PTR [rip+0xc926],eax        # d708 <mal+0x608>
     de2:	85 c0                	test   eax,eax
     de4:	75 da                	jne    dc0 <__bin_chunk+0x130>
			i = bin_index(final_size);
			lock_bin(i);
			lock(mal.free_lock);
			if (self->psize & next->csize & C_INUSE)
     de6:	49 8b 07             	mov    rax,QWORD PTR [r15]
     de9:	48 23 43 08          	and    rax,QWORD PTR [rbx+0x8]
     ded:	a8 01                	test   al,0x1
     def:	0f 85 d3 01 00 00    	jne    fc8 <__bin_chunk+0x338>
	if (lk[0]) {
     df5:	8b 05 0d c9 00 00    	mov    eax,DWORD PTR [rip+0xc90d]        # d708 <mal+0x608>
     dfb:	85 c0                	test   eax,eax
     dfd:	74 1b                	je     e1a <__bin_chunk+0x18a>
	__asm__ __volatile__(
     dff:	31 c0                	xor    eax,eax
     e01:	89 05 01 c9 00 00    	mov    DWORD PTR [rip+0xc901],eax        # d708 <mal+0x608>
     e07:	f0 83 0c 24 00       	lock or DWORD PTR [rsp],0x0
		if (lk[1]) __wake(lk, 1, 1);
     e0c:	8b 05 fa c8 00 00    	mov    eax,DWORD PTR [rip+0xc8fa]        # d70c <mal+0x60c>
     e12:	85 c0                	test   eax,eax
     e14:	0f 85 26 01 00 00    	jne    f40 <__bin_chunk+0x2b0>
	if (lk[0]) {
     e1a:	41 8b 06             	mov    eax,DWORD PTR [r14]
     e1d:	85 c0                	test   eax,eax
     e1f:	74 16                	je     e37 <__bin_chunk+0x1a7>
     e21:	31 c0                	xor    eax,eax
     e23:	41 89 06             	mov    DWORD PTR [r14],eax
     e26:	f0 83 0c 24 00       	lock or DWORD PTR [rsp],0x0
		if (lk[1]) __wake(lk, 1, 1);
     e2b:	41 8b 46 04          	mov    eax,DWORD PTR [r14+0x4]
     e2f:	85 c0                	test   eax,eax
     e31:	0f 85 51 01 00 00    	jne    f88 <__bin_chunk+0x2f8>
				break;
			unlock(mal.free_lock);
			unlock_bin(i);
		}

		if (alloc_rev(self)) {
     e37:	4c 89 ff             	mov    rdi,r15
     e3a:	e8 71 fb ff ff       	call   9b0 <alloc_rev>
     e3f:	85 c0                	test   eax,eax
     e41:	74 39                	je     e7c <__bin_chunk+0x1ec>
			self = PREV_CHUNK(self);
     e43:	49 8b 07             	mov    rax,QWORD PTR [r15]
			size = CHUNK_SIZE(self);
			final_size += size;
			if (new_size+size > RECLAIM && (new_size+size^size) > size)
     e46:	48 8b 4c 24 08       	mov    rcx,QWORD PTR [rsp+0x8]
			self = PREV_CHUNK(self);
     e4b:	48 83 e0 fe          	and    rax,0xfffffffffffffffe
     e4f:	49 29 c7             	sub    r15,rax
			size = CHUNK_SIZE(self);
     e52:	49 8b 47 08          	mov    rax,QWORD PTR [r15+0x8]
     e56:	48 83 e0 fe          	and    rax,0xfffffffffffffffe
			if (new_size+size > RECLAIM && (new_size+size^size) > size)
     e5a:	48 8d 14 01          	lea    rdx,[rcx+rax*1]
			final_size += size;
     e5e:	48 01 c5             	add    rbp,rax
			if (new_size+size > RECLAIM && (new_size+size^size) > size)
     e61:	48 81 fa 00 80 02 00 	cmp    rdx,0x28000
     e68:	76 12                	jbe    e7c <__bin_chunk+0x1ec>
     e6a:	48 31 c2             	xor    rdx,rax
				reclaim = 1;
     e6d:	48 39 c2             	cmp    rdx,rax
     e70:	8b 44 24 18          	mov    eax,DWORD PTR [rsp+0x18]
     e74:	41 0f 47 c5          	cmova  eax,r13d
     e78:	89 44 24 18          	mov    DWORD PTR [rsp+0x18],eax
		}

		if (alloc_fwd(next)) {
     e7c:	48 89 df             	mov    rdi,rbx
     e7f:	e8 4c f8 ff ff       	call   6d0 <alloc_fwd>
     e84:	85 c0                	test   eax,eax
     e86:	0f 84 44 fe ff ff    	je     cd0 <__bin_chunk+0x40>
			size = CHUNK_SIZE(next);
     e8c:	48 8b 43 08          	mov    rax,QWORD PTR [rbx+0x8]
			final_size += size;
			if (new_size+size > RECLAIM && (new_size+size^size) > size)
     e90:	48 8b 74 24 08       	mov    rsi,QWORD PTR [rsp+0x8]
			size = CHUNK_SIZE(next);
     e95:	48 83 e0 fe          	and    rax,0xfffffffffffffffe
			if (new_size+size > RECLAIM && (new_size+size^size) > size)
     e99:	48 8d 14 06          	lea    rdx,[rsi+rax*1]
			final_size += size;
     e9d:	48 01 c5             	add    rbp,rax
			if (new_size+size > RECLAIM && (new_size+size^size) > size)
     ea0:	48 81 fa 00 80 02 00 	cmp    rdx,0x28000
     ea7:	76 12                	jbe    ebb <__bin_chunk+0x22b>
				reclaim = 1;
     ea9:	8b 4c 24 18          	mov    ecx,DWORD PTR [rsp+0x18]
			if (new_size+size > RECLAIM && (new_size+size^size) > size)
     ead:	48 31 c2             	xor    rdx,rax
				reclaim = 1;
     eb0:	48 39 c2             	cmp    rdx,rax
     eb3:	41 0f 47 cd          	cmova  ecx,r13d
     eb7:	89 4c 24 18          	mov    DWORD PTR [rsp+0x18],ecx
			next = NEXT_CHUNK(next);
     ebb:	48 01 c3             	add    rbx,rax
     ebe:	e9 0d fe ff ff       	jmp    cd0 <__bin_chunk+0x40>
     ec3:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
	if (x <= 32) return x;
     ec8:	4c 8d 34 40          	lea    r14,[rax+rax*2]
     ecc:	4c 63 e0             	movsxd r12,eax
     ecf:	4a 8d 04 f5 00 00 00 00 	lea    rax,[r14*8+0x0]
     ed7:	44 89 64 24 1c       	mov    DWORD PTR [rsp+0x1c],r12d
     edc:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
     ee1:	48 8d 50 08          	lea    rdx,[rax+0x8]
     ee5:	e9 5a fe ff ff       	jmp    d44 <__bin_chunk+0xb4>
     eea:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
		mal.bins[i].head = mal.bins[i].tail = BIN_TO_CHUNK(i);
     ef0:	48 8b 4c 24 10       	mov    rcx,QWORD PTR [rsp+0x10]
     ef5:	48 8d 91 00 d1 00 00 	lea    rdx,[rcx+0xd100]
     efc:	48 89 50 18          	mov    QWORD PTR [rax+0x18],rdx
     f00:	48 89 50 10          	mov    QWORD PTR [rax+0x10],rdx
     f04:	e9 9e fe ff ff       	jmp    da7 <__bin_chunk+0x117>
     f09:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
	if (x < 512) return bin_tab[x/8-4];
     f10:	48 c1 e8 03          	shr    rax,0x3
     f14:	0f b6 80 1c 80 00 00 	movzx  eax,BYTE PTR [rax+0x801c]
     f1b:	89 44 24 1c          	mov    DWORD PTR [rsp+0x1c],eax
     f1f:	49 89 c4             	mov    r12,rax
     f22:	0f b6 c0             	movzx  eax,al
     f25:	4c 8d 34 40          	lea    r14,[rax+rax*2]
     f29:	4a 8d 04 f5 00 00 00 00 	lea    rax,[r14*8+0x0]
     f31:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
     f36:	48 8d 50 08          	lea    rdx,[rax+0x8]
     f3a:	e9 05 fe ff ff       	jmp    d44 <__bin_chunk+0xb4>
     f3f:	90                   	nop
	__syscall(SYS_futex, addr, FUTEX_WAKE|priv, cnt) != -ENOSYS ||
     f40:	b9 01 00 00 00       	mov    ecx,0x1
     f45:	ba 81 00 00 00       	mov    edx,0x81
     f4a:	be 08 d7 00 00       	mov    esi,0xd708
     f4f:	bf ca 00 00 00       	mov    edi,0xca
     f54:	e8 c7 17 00 00       	call   2720 <__syscall3>
     f59:	48 83 f8 da          	cmp    rax,0xffffffffffffffda
     f5d:	0f 85 b7 fe ff ff    	jne    e1a <__bin_chunk+0x18a>
	__syscall(SYS_futex, addr, FUTEX_WAKE, cnt);
     f63:	b9 01 00 00 00       	mov    ecx,0x1
     f68:	ba 01 00 00 00       	mov    edx,0x1
     f6d:	be 08 d7 00 00       	mov    esi,0xd708
     f72:	bf ca 00 00 00       	mov    edi,0xca
     f77:	e8 a4 17 00 00       	call   2720 <__syscall3>
     f7c:	e9 99 fe ff ff       	jmp    e1a <__bin_chunk+0x18a>
     f81:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
	__syscall(SYS_futex, addr, FUTEX_WAKE|priv, cnt) != -ENOSYS ||
     f88:	b9 01 00 00 00       	mov    ecx,0x1
     f8d:	ba 81 00 00 00       	mov    edx,0x81
     f92:	4c 89 f6             	mov    rsi,r14
     f95:	bf ca 00 00 00       	mov    edi,0xca
     f9a:	e8 81 17 00 00       	call   2720 <__syscall3>
     f9f:	48 83 f8 da          	cmp    rax,0xffffffffffffffda
     fa3:	0f 85 8e fe ff ff    	jne    e37 <__bin_chunk+0x1a7>
	__syscall(SYS_futex, addr, FUTEX_WAKE, cnt);
     fa9:	b9 01 00 00 00       	mov    ecx,0x1
     fae:	ba 01 00 00 00       	mov    edx,0x1
     fb3:	4c 89 f6             	mov    rsi,r14
     fb6:	bf ca 00 00 00       	mov    edi,0xca
     fbb:	e8 60 17 00 00       	call   2720 <__syscall3>
     fc0:	e9 72 fe ff ff       	jmp    e37 <__bin_chunk+0x1a7>
     fc5:	0f 1f 00             	nop    DWORD PTR [rax]
		}
	}

	if (!(mal.binmap & 1ULL<<i))
     fc8:	48 8b 05 31 c1 00 00 	mov    rax,QWORD PTR [rip+0xc131]        # d100 <mal>
     fcf:	8b 74 24 1c          	mov    esi,DWORD PTR [rsp+0x1c]
     fd3:	48 0f a3 f0          	bt     rax,rsi
     fd7:	72 12                	jb     feb <__bin_chunk+0x35b>
		a_or_64(&mal.binmap, 1ULL<<i);
     fd9:	89 f1                	mov    ecx,esi
     fdb:	b8 01 00 00 00       	mov    eax,0x1
     fe0:	48 d3 e0             	shl    rax,cl
	__asm__ __volatile__(
     fe3:	f0 48 09 05 15 c1 00 00 	lock or QWORD PTR [rip+0xc115],rax        # d100 <mal>
	if (lk[0]) {
     feb:	8b 05 17 c7 00 00    	mov    eax,DWORD PTR [rip+0xc717]        # d708 <mal+0x608>

	self->csize = final_size;
     ff1:	49 89 6f 08          	mov    QWORD PTR [r15+0x8],rbp
	next->psize = final_size;
     ff5:	48 89 2b             	mov    QWORD PTR [rbx],rbp
	if (lk[0]) {
     ff8:	85 c0                	test   eax,eax
     ffa:	74 1b                	je     1017 <__bin_chunk+0x387>
	__asm__ __volatile__(
     ffc:	31 c0                	xor    eax,eax
     ffe:	89 05 04 c7 00 00    	mov    DWORD PTR [rip+0xc704],eax        # d708 <mal+0x608>
    1004:	f0 83 0c 24 00       	lock or DWORD PTR [rsp],0x0
		if (lk[1]) __wake(lk, 1, 1);
    1009:	8b 05 fd c6 00 00    	mov    eax,DWORD PTR [rip+0xc6fd]        # d70c <mal+0x60c>
    100f:	85 c0                	test   eax,eax
    1011:	0f 85 09 01 00 00    	jne    1120 <__bin_chunk+0x490>
	unlock(mal.free_lock);

	self->next = BIN_TO_CHUNK(i);
    1017:	48 8b 7c 24 10       	mov    rdi,QWORD PTR [rsp+0x10]
    101c:	48 8d 87 00 d1 00 00 	lea    rax,[rdi+0xd100]
    1023:	66 48 0f 6e c0       	movq   xmm0,rax
	self->prev = mal.bins[i].tail;
    1028:	4b 8d 04 64          	lea    rax,[r12+r12*2]
	self->next = BIN_TO_CHUNK(i);
    102c:	0f 16 04 c5 18 d1 00 00 	movhps xmm0,QWORD PTR [rax*8+0xd118]
    1034:	41 0f 11 47 10       	movups XMMWORD PTR [r15+0x10],xmm0
	self->next->prev = self;
    1039:	4c 89 bf 18 d1 00 00 	mov    QWORD PTR [rdi+0xd118],r15
	self->prev->next = self;
    1040:	49 8b 47 18          	mov    rax,QWORD PTR [r15+0x18]
    1044:	4c 89 78 10          	mov    QWORD PTR [rax+0x10],r15

	/* Replace middle of large chunks with fresh zero pages */
	if (reclaim) {
    1048:	8b 44 24 18          	mov    eax,DWORD PTR [rsp+0x18]
    104c:	85 c0                	test   eax,eax
    104e:	75 58                	jne    10a8 <__bin_chunk+0x418>
	if (lk[0]) {
    1050:	41 8b 06             	mov    eax,DWORD PTR [r14]
    1053:	85 c0                	test   eax,eax
    1055:	74 12                	je     1069 <__bin_chunk+0x3d9>
    1057:	31 c0                	xor    eax,eax
    1059:	41 89 06             	mov    DWORD PTR [r14],eax
    105c:	f0 83 0c 24 00       	lock or DWORD PTR [rsp],0x0
		if (lk[1]) __wake(lk, 1, 1);
    1061:	41 8b 46 04          	mov    eax,DWORD PTR [r14+0x4]
    1065:	85 c0                	test   eax,eax
    1067:	75 67                	jne    10d0 <__bin_chunk+0x440>
			MAP_PRIVATE|MAP_ANONYMOUS|MAP_FIXED, -1, 0);
#endif
	}

	unlock_bin(i);
}
    1069:	48 83 c4 28          	add    rsp,0x28
    106d:	5b                   	pop    rbx
    106e:	5d                   	pop    rbp
    106f:	41 5c                	pop    r12
    1071:	41 5d                	pop    r13
    1073:	41 5e                	pop    r14
    1075:	41 5f                	pop    r15
    1077:	c3                   	ret    
    1078:	0f 1f 84 00 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
    1080:	48 c7 44 24 10 e8 05 00 00 	mov    QWORD PTR [rsp+0x10],0x5e8
    1089:	ba f0 05 00 00       	mov    edx,0x5f0
    108e:	41 bc 3f 00 00 00    	mov    r12d,0x3f
	if (x > 0x1c00) return 63;
    1094:	c7 44 24 1c 3f 00 00 00 	mov    DWORD PTR [rsp+0x1c],0x3f
    109c:	e9 a3 fc ff ff       	jmp    d44 <__bin_chunk+0xb4>
    10a1:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
		uintptr_t a = (uintptr_t)self + SIZE_ALIGN+PAGE_SIZE-1 & -PAGE_SIZE;
    10a8:	49 8d bf 1f 10 00 00 	lea    rdi,[r15+0x101f]
		uintptr_t b = (uintptr_t)next - SIZE_ALIGN & -PAGE_SIZE;
    10af:	48 8d 73 e0          	lea    rsi,[rbx-0x20]
		__madvise((void *)a, b-a, MADV_DONTNEED);
    10b3:	ba 04 00 00 00       	mov    edx,0x4
		uintptr_t a = (uintptr_t)self + SIZE_ALIGN+PAGE_SIZE-1 & -PAGE_SIZE;
    10b8:	48 81 e7 00 f0 ff ff 	and    rdi,0xfffffffffffff000
		uintptr_t b = (uintptr_t)next - SIZE_ALIGN & -PAGE_SIZE;
    10bf:	48 81 e6 00 f0 ff ff 	and    rsi,0xfffffffffffff000
		__madvise((void *)a, b-a, MADV_DONTNEED);
    10c6:	48 29 fe             	sub    rsi,rdi
    10c9:	e8 22 0b 00 00       	call   1bf0 <__madvise>
    10ce:	eb 80                	jmp    1050 <__bin_chunk+0x3c0>
	__syscall(SYS_futex, addr, FUTEX_WAKE|priv, cnt) != -ENOSYS ||
    10d0:	b9 01 00 00 00       	mov    ecx,0x1
    10d5:	ba 81 00 00 00       	mov    edx,0x81
    10da:	4c 89 f6             	mov    rsi,r14
    10dd:	bf ca 00 00 00       	mov    edi,0xca
    10e2:	e8 39 16 00 00       	call   2720 <__syscall3>
    10e7:	48 83 f8 da          	cmp    rax,0xffffffffffffffda
    10eb:	0f 85 78 ff ff ff    	jne    1069 <__bin_chunk+0x3d9>
}
    10f1:	48 83 c4 28          	add    rsp,0x28
	__syscall(SYS_futex, addr, FUTEX_WAKE, cnt);
    10f5:	4c 89 f6             	mov    rsi,r14
    10f8:	b9 01 00 00 00       	mov    ecx,0x1
    10fd:	ba 01 00 00 00       	mov    edx,0x1
    1102:	5b                   	pop    rbx
    1103:	bf ca 00 00 00       	mov    edi,0xca
    1108:	5d                   	pop    rbp
    1109:	41 5c                	pop    r12
    110b:	41 5d                	pop    r13
    110d:	41 5e                	pop    r14
    110f:	41 5f                	pop    r15
    1111:	e9 0a 16 00 00       	jmp    2720 <__syscall3>
    1116:	66 2e 0f 1f 84 00 00 00 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
	__syscall(SYS_futex, addr, FUTEX_WAKE|priv, cnt) != -ENOSYS ||
    1120:	b9 01 00 00 00       	mov    ecx,0x1
    1125:	ba 81 00 00 00       	mov    edx,0x81
    112a:	be 08 d7 00 00       	mov    esi,0xd708
    112f:	bf ca 00 00 00       	mov    edi,0xca
    1134:	e8 e7 15 00 00       	call   2720 <__syscall3>
    1139:	48 83 f8 da          	cmp    rax,0xffffffffffffffda
    113d:	0f 85 d4 fe ff ff    	jne    1017 <__bin_chunk+0x387>
	__syscall(SYS_futex, addr, FUTEX_WAKE, cnt);
    1143:	b9 01 00 00 00       	mov    ecx,0x1
    1148:	ba 01 00 00 00       	mov    edx,0x1
    114d:	be 08 d7 00 00       	mov    esi,0xd708
    1152:	bf ca 00 00 00       	mov    edi,0xca
    1157:	e8 c4 15 00 00       	call   2720 <__syscall3>
    115c:	e9 b6 fe ff ff       	jmp    1017 <__bin_chunk+0x387>
    1161:	66 66 2e 0f 1f 84 00 00 00 00 00 	data16 nop WORD PTR cs:[rax+rax*1+0x0]
    116c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

0000000000001170 <malloc>:
	if (*n-1 > PTRDIFF_MAX - SIZE_ALIGN - PAGE_SIZE) {
    1170:	48 b8 df ef ff ff ff ff ff 7f 	movabs rax,0x7fffffffffffefdf
{
    117a:	41 57                	push   r15
	if (*n-1 > PTRDIFF_MAX - SIZE_ALIGN - PAGE_SIZE) {
    117c:	48 8d 57 ff          	lea    rdx,[rdi-0x1]
{
    1180:	41 56                	push   r14
    1182:	41 55                	push   r13
    1184:	41 54                	push   r12
    1186:	55                   	push   rbp
    1187:	53                   	push   rbx
    1188:	48 83 ec 38          	sub    rsp,0x38
	if (*n-1 > PTRDIFF_MAX - SIZE_ALIGN - PAGE_SIZE) {
    118c:	48 39 c2             	cmp    rdx,rax
    118f:	0f 86 5b 02 00 00    	jbe    13f0 <malloc+0x280>
		if (*n) {
    1195:	48 85 ff             	test   rdi,rdi
    1198:	0f 85 b5 05 00 00    	jne    1753 <malloc+0x5e3>
    119e:	48 c7 44 24 08 ff ff ff ff 	mov    QWORD PTR [rsp+0x8],0xffffffffffffffff
    11a7:	c7 44 24 1c 00 00 00 00 	mov    DWORD PTR [rsp+0x1c],0x0
			*n = SIZE_ALIGN;
    11af:	48 c7 44 24 10 20 00 00 00 	mov    QWORD PTR [rsp+0x10],0x20
	__asm__ __volatile__(
    11b8:	41 bd 01 00 00 00    	mov    r13d,0x1
    11be:	66 90                	xchg   ax,ax
		uint64_t mask = mal.binmap & -(1ULL<<i);
    11c0:	48 8b 1d 39 bf 00 00 	mov    rbx,QWORD PTR [rip+0xbf39]        # d100 <mal>
		if (!mask) {
    11c7:	48 23 5c 24 08       	and    rbx,QWORD PTR [rsp+0x8]
    11cc:	0f 84 06 01 00 00    	je     12d8 <malloc+0x168>

#define a_ctz_64 a_ctz_64
static inline int a_ctz_64(uint64_t x)
{
	__asm__( "bsf %1,%0" : "=r"(x) : "r"(x) );
    11d2:	48 0f bc db          	bsf    rbx,rbx
	return x;
    11d6:	89 5c 24 18          	mov    DWORD PTR [rsp+0x18],ebx
	lock(mal.bins[i].lock);
    11da:	48 63 db             	movsxd rbx,ebx
	if (libc.threads_minus_1)
    11dd:	8b 15 49 be 00 00    	mov    edx,DWORD PTR [rip+0xbe49]        # d02c <__libc+0xc>
    11e3:	48 8d 04 5b          	lea    rax,[rbx+rbx*2]
    11e7:	48 8d 2c c5 00 00 00 00 	lea    rbp,[rax*8+0x0]
	lock(mal.bins[i].lock);
    11ef:	4c 8d 65 08          	lea    r12,[rbp+0x8]
    11f3:	4c 8d b5 08 d1 00 00 	lea    r14,[rbp+0xd108]
	if (libc.threads_minus_1)
    11fa:	85 d2                	test   edx,edx
    11fc:	74 39                	je     1237 <malloc+0xc7>
	__asm__ __volatile__(
    11fe:	44 89 ea             	mov    edx,r13d
    1201:	41 87 94 24 00 d1 00 00 	xchg   DWORD PTR [r12+0xd100],edx
		while(a_swap(lk, 1)) __wait(lk, lk+1, 1, 1);
    1209:	85 d2                	test   edx,edx
    120b:	74 2a                	je     1237 <malloc+0xc7>
    120d:	4d 8d 7e 04          	lea    r15,[r14+0x4]
    1211:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
    1218:	b9 01 00 00 00       	mov    ecx,0x1
    121d:	ba 01 00 00 00       	mov    edx,0x1
    1222:	4c 89 fe             	mov    rsi,r15
    1225:	4c 89 f7             	mov    rdi,r14
    1228:	e8 f3 18 00 00       	call   2b20 <__wait>
    122d:	44 89 ea             	mov    edx,r13d
    1230:	41 87 16             	xchg   DWORD PTR [r14],edx
    1233:	85 d2                	test   edx,edx
    1235:	75 e1                	jne    1218 <malloc+0xa8>
	if (!mal.bins[i].head)
    1237:	48 8d 14 5b          	lea    rdx,[rbx+rbx*2]
    123b:	48 8d 85 00 d1 00 00 	lea    rax,[rbp+0xd100]
    1242:	48 8b 1c d5 10 d1 00 00 	mov    rbx,QWORD PTR [rdx*8+0xd110]
    124a:	48 85 db             	test   rbx,rbx
    124d:	0f 84 7d 01 00 00    	je     13d0 <malloc+0x260>
		if (c != BIN_TO_CHUNK(j)) {
    1253:	48 39 c3             	cmp    rbx,rax
    1256:	0f 85 64 02 00 00    	jne    14c0 <malloc+0x350>
	if (lk[0]) {
    125c:	41 8b 84 24 00 d1 00 00 	mov    eax,DWORD PTR [r12+0xd100]
    1264:	85 c0                	test   eax,eax
    1266:	0f 84 54 ff ff ff    	je     11c0 <malloc+0x50>
	__asm__ __volatile__(
    126c:	31 c0                	xor    eax,eax
    126e:	41 89 84 24 00 d1 00 00 	mov    DWORD PTR [r12+0xd100],eax
    1276:	f0 83 0c 24 00       	lock or DWORD PTR [rsp],0x0
		if (lk[1]) __wake(lk, 1, 1);
    127b:	41 8b 46 04          	mov    eax,DWORD PTR [r14+0x4]
    127f:	85 c0                	test   eax,eax
    1281:	0f 84 39 ff ff ff    	je     11c0 <malloc+0x50>
	__syscall(SYS_futex, addr, FUTEX_WAKE|priv, cnt) != -ENOSYS ||
    1287:	b9 01 00 00 00       	mov    ecx,0x1
    128c:	ba 81 00 00 00       	mov    edx,0x81
    1291:	4c 89 f6             	mov    rsi,r14
    1294:	bf ca 00 00 00       	mov    edi,0xca
    1299:	e8 82 14 00 00       	call   2720 <__syscall3>
    129e:	48 83 f8 da          	cmp    rax,0xffffffffffffffda
    12a2:	0f 85 18 ff ff ff    	jne    11c0 <malloc+0x50>
	__syscall(SYS_futex, addr, FUTEX_WAKE, cnt);
    12a8:	b9 01 00 00 00       	mov    ecx,0x1
    12ad:	ba 01 00 00 00       	mov    edx,0x1
    12b2:	4c 89 f6             	mov    rsi,r14
    12b5:	bf ca 00 00 00       	mov    edi,0xca
    12ba:	e8 61 14 00 00       	call   2720 <__syscall3>
		uint64_t mask = mal.binmap & -(1ULL<<i);
    12bf:	48 8b 1d 3a be 00 00 	mov    rbx,QWORD PTR [rip+0xbe3a]        # d100 <mal>
		if (!mask) {
    12c6:	48 23 5c 24 08       	and    rbx,QWORD PTR [rsp+0x8]
    12cb:	0f 85 01 ff ff ff    	jne    11d2 <malloc+0x62>
    12d1:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
	n += SIZE_ALIGN;
    12d8:	48 8b 44 24 10       	mov    rax,QWORD PTR [rsp+0x10]
    12dd:	48 83 c0 20          	add    rax,0x20
    12e1:	48 89 44 24 28       	mov    QWORD PTR [rsp+0x28],rax
	if (libc.threads_minus_1)
    12e6:	8b 05 40 bd 00 00    	mov    eax,DWORD PTR [rip+0xbd40]        # d02c <__libc+0xc>
    12ec:	85 c0                	test   eax,eax
    12ee:	0f 85 54 02 00 00    	jne    1548 <malloc+0x3d8>
	p = __expand_heap(&n);
    12f4:	48 8d 7c 24 28       	lea    rdi,[rsp+0x28]
    12f9:	e8 d2 1d 00 00       	call   30d0 <__expand_heap>
	if (!p) {
    12fe:	48 85 c0             	test   rax,rax
    1301:	0f 84 82 03 00 00    	je     1689 <malloc+0x519>
	if (p != end) {
    1307:	4c 8b 2d d2 bd 00 00 	mov    r13,QWORD PTR [rip+0xbdd2]        # d0e0 <end.3638>
    130e:	48 8b 54 24 28       	mov    rdx,QWORD PTR [rsp+0x28]
    1313:	4c 39 e8             	cmp    rax,r13
    1316:	74 15                	je     132d <malloc+0x1bd>
		n -= SIZE_ALIGN;
    1318:	48 83 ea 20          	sub    rdx,0x20
		w->psize = 0 | C_INUSE;
    131c:	48 c7 40 10 01 00 00 00 	mov    QWORD PTR [rax+0x10],0x1
		p = (char *)p + SIZE_ALIGN;
    1324:	4c 8d 68 20          	lea    r13,[rax+0x20]
		n -= SIZE_ALIGN;
    1328:	48 89 54 24 28       	mov    QWORD PTR [rsp+0x28],rdx
	end = (char *)p + n;
    132d:	49 8d 44 15 00       	lea    rax,[r13+rdx*1+0x0]
	w->psize = n | C_INUSE;
    1332:	48 83 ca 01          	or     rdx,0x1
	w = MEM_TO_CHUNK(p);
    1336:	49 8d 5d f0          	lea    rbx,[r13-0x10]
	w->psize = n | C_INUSE;
    133a:	48 89 50 f0          	mov    QWORD PTR [rax-0x10],rdx
	w->csize = 0 | C_INUSE;
    133e:	48 c7 40 f8 01 00 00 00 	mov    QWORD PTR [rax-0x8],0x1
	end = (char *)p + n;
    1346:	48 89 05 93 bd 00 00 	mov    QWORD PTR [rip+0xbd93],rax        # d0e0 <end.3638>
	if (lk[0]) {
    134d:	8b 05 95 bd 00 00    	mov    eax,DWORD PTR [rip+0xbd95]        # d0e8 <heap_lock.3637>
	w->csize = n | C_INUSE;
    1353:	49 89 55 f8          	mov    QWORD PTR [r13-0x8],rdx
	if (lk[0]) {
    1357:	85 c0                	test   eax,eax
    1359:	74 1b                	je     1376 <malloc+0x206>
    135b:	31 c0                	xor    eax,eax
    135d:	89 05 85 bd 00 00    	mov    DWORD PTR [rip+0xbd85],eax        # d0e8 <heap_lock.3637>
    1363:	f0 83 0c 24 00       	lock or DWORD PTR [rsp],0x0
		if (lk[1]) __wake(lk, 1, 1);
    1368:	8b 05 7e bd 00 00    	mov    eax,DWORD PTR [rip+0xbd7e]        # d0ec <heap_lock.3637+0x4>
    136e:	85 c0                	test   eax,eax
    1370:	0f 85 7a 03 00 00    	jne    16f0 <malloc+0x580>
			if (alloc_rev(c)) {
    1376:	48 89 df             	mov    rdi,rbx
    1379:	e8 32 f6 ff ff       	call   9b0 <alloc_rev>
    137e:	85 c0                	test   eax,eax
    1380:	0f 85 0a 02 00 00    	jne    1590 <malloc+0x420>
    1386:	49 8b 45 f8          	mov    rax,QWORD PTR [r13-0x8]
    138a:	48 83 e0 fe          	and    rax,0xfffffffffffffffe
	if (n >= n1 - DONTCARE) return;
    138e:	48 8b 74 24 10       	mov    rsi,QWORD PTR [rsp+0x10]
    1393:	48 8d 50 f0          	lea    rdx,[rax-0x10]
    1397:	48 39 f2             	cmp    rdx,rsi
    139a:	0f 86 b4 00 00 00    	jbe    1454 <malloc+0x2e4>
	split->csize = n1-n | C_INUSE;
    13a0:	48 89 c2             	mov    rdx,rax
	split->psize = n | C_INUSE;
    13a3:	48 89 f1             	mov    rcx,rsi
	split = (void *)((char *)self + n);
    13a6:	48 8d 3c 33          	lea    rdi,[rbx+rsi*1]
	split->csize = n1-n | C_INUSE;
    13aa:	48 29 f2             	sub    rdx,rsi
	split->psize = n | C_INUSE;
    13ad:	48 83 c9 01          	or     rcx,0x1
	split->csize = n1-n | C_INUSE;
    13b1:	48 83 ca 01          	or     rdx,0x1
	split->psize = n | C_INUSE;
    13b5:	48 89 0f             	mov    QWORD PTR [rdi],rcx
	split->csize = n1-n | C_INUSE;
    13b8:	48 89 57 08          	mov    QWORD PTR [rdi+0x8],rdx
	next->psize = n1-n | C_INUSE;
    13bc:	48 89 14 03          	mov    QWORD PTR [rbx+rax*1],rdx
	self->csize = n | C_INUSE;
    13c0:	48 89 4b 08          	mov    QWORD PTR [rbx+0x8],rcx
	__bin_chunk(split);
    13c4:	e8 c7 f8 ff ff       	call   c90 <__bin_chunk>
	return CHUNK_TO_MEM(c);
    13c9:	e9 86 00 00 00       	jmp    1454 <malloc+0x2e4>
    13ce:	66 90                	xchg   ax,ax
		mal.bins[i].head = mal.bins[i].tail = BIN_TO_CHUNK(i);
    13d0:	66 48 0f 6e c0       	movq   xmm0,rax
    13d5:	66 0f 6c c0          	punpcklqdq xmm0,xmm0
    13d9:	0f 11 04 d5 10 d1 00 00 	movups XMMWORD PTR [rdx*8+0xd110],xmm0
		if (c != BIN_TO_CHUNK(j)) {
    13e1:	e9 76 fe ff ff       	jmp    125c <malloc+0xec>
    13e6:	66 2e 0f 1f 84 00 00 00 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
	*n = (*n + OVERHEAD + SIZE_ALIGN - 1) & SIZE_MASK;
    13f0:	4c 8d 67 2f          	lea    r12,[rdi+0x2f]
    13f4:	49 83 e4 e0          	and    r12,0xffffffffffffffe0
    13f8:	4c 89 64 24 10       	mov    QWORD PTR [rsp+0x10],r12
    13fd:	4c 89 e0             	mov    rax,r12
	if (n > MMAP_THRESHOLD) {
    1400:	49 81 fc 00 80 03 00 	cmp    r12,0x38000
    1407:	76 67                	jbe    1470 <malloc+0x300>
		size_t len = n + OVERHEAD + PAGE_SIZE - 1 & -PAGE_SIZE;
    1409:	48 05 0f 10 00 00    	add    rax,0x100f
		char *base = __mmap(0, len, PROT_READ|PROT_WRITE,
    140f:	45 31 c9             	xor    r9d,r9d
    1412:	31 ff                	xor    edi,edi
    1414:	b9 22 00 00 00       	mov    ecx,0x22
		size_t len = n + OVERHEAD + PAGE_SIZE - 1 & -PAGE_SIZE;
    1419:	49 89 c4             	mov    r12,rax
		char *base = __mmap(0, len, PROT_READ|PROT_WRITE,
    141c:	41 b8 ff ff ff ff    	mov    r8d,0xffffffff
    1422:	ba 03 00 00 00       	mov    edx,0x3
		size_t len = n + OVERHEAD + PAGE_SIZE - 1 & -PAGE_SIZE;
    1427:	49 81 e4 00 f0 ff ff 	and    r12,0xfffffffffffff000
		char *base = __mmap(0, len, PROT_READ|PROT_WRITE,
    142e:	4c 89 e6             	mov    rsi,r12
    1431:	e8 fa 07 00 00       	call   1c30 <__mmap>
		if (base == (void *)-1) return 0;
    1436:	48 83 f8 ff          	cmp    rax,0xffffffffffffffff
    143a:	0f 84 a8 02 00 00    	je     16e8 <malloc+0x578>
		c->csize = len - (SIZE_ALIGN - OVERHEAD);
    1440:	49 83 ec 10          	sub    r12,0x10
		c->psize = SIZE_ALIGN - OVERHEAD;
    1444:	48 c7 40 10 10 00 00 00 	mov    QWORD PTR [rax+0x10],0x10
		return CHUNK_TO_MEM(c);
    144c:	4c 8d 68 20          	lea    r13,[rax+0x20]
		c->csize = len - (SIZE_ALIGN - OVERHEAD);
    1450:	4c 89 60 18          	mov    QWORD PTR [rax+0x18],r12
}
    1454:	48 83 c4 38          	add    rsp,0x38
    1458:	4c 89 e8             	mov    rax,r13
    145b:	5b                   	pop    rbx
    145c:	5d                   	pop    rbp
    145d:	41 5c                	pop    r12
    145f:	41 5d                	pop    r13
    1461:	41 5e                	pop    r14
    1463:	41 5f                	pop    r15
    1465:	c3                   	ret    
    1466:	66 2e 0f 1f 84 00 00 00 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
	x = x / SIZE_ALIGN - 1;
    1470:	48 c1 e8 05          	shr    rax,0x5
    1474:	48 8d 48 ff          	lea    rcx,[rax-0x1]
	if (x <= 32) return x;
    1478:	48 83 f9 20          	cmp    rcx,0x20
    147c:	0f 86 56 03 00 00    	jbe    17d8 <malloc+0x668>
	x--;
    1482:	48 83 e8 02          	sub    rax,0x2
	if (x < 512) return bin_tab[x/8-4] + 1;
    1486:	48 3d ff 01 00 00    	cmp    rax,0x1ff
    148c:	0f 86 3e 01 00 00    	jbe    15d0 <malloc+0x460>
	return bin_tab[x/128-4] + 17;
    1492:	48 c1 e8 07          	shr    rax,0x7
    1496:	44 0f b6 b0 1c 80 00 00 	movzx  r14d,BYTE PTR [rax+0x801c]
    149e:	41 8d 46 11          	lea    eax,[r14+0x11]
    14a2:	48 c7 c5 ff ff ff ff 	mov    rbp,0xffffffffffffffff
    14a9:	89 c1                	mov    ecx,eax
    14ab:	89 44 24 1c          	mov    DWORD PTR [rsp+0x1c],eax
    14af:	48 d3 e5             	shl    rbp,cl
    14b2:	48 89 6c 24 08       	mov    QWORD PTR [rsp+0x8],rbp
    14b7:	e9 fc fc ff ff       	jmp    11b8 <malloc+0x48>
    14bc:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
	if (j < 40) return 0;
    14c0:	8b 74 24 18          	mov    esi,DWORD PTR [rsp+0x18]
    14c4:	48 8b 53 18          	mov    rdx,QWORD PTR [rbx+0x18]
    14c8:	48 8b 43 10          	mov    rax,QWORD PTR [rbx+0x10]
    14cc:	83 fe 27             	cmp    esi,0x27
    14cf:	7e 18                	jle    14e9 <malloc+0x379>
	if (j < i+3) {
    14d1:	8b 4c 24 1c          	mov    ecx,DWORD PTR [rsp+0x1c]
    14d5:	83 c1 02             	add    ecx,0x2
    14d8:	39 ce                	cmp    esi,ecx
    14da:	0f 8f 08 01 00 00    	jg     15e8 <malloc+0x478>
		if (j != 63) return 0;
    14e0:	83 fe 3f             	cmp    esi,0x3f
    14e3:	0f 84 48 02 00 00    	je     1731 <malloc+0x5c1>
	if (c->prev == c->next)
    14e9:	48 39 c2             	cmp    rdx,rax
    14ec:	0f 84 b1 02 00 00    	je     17a3 <malloc+0x633>
	c->prev->next = c->next;
    14f2:	48 89 42 10          	mov    QWORD PTR [rdx+0x10],rax
	c->next->prev = c->prev;
    14f6:	48 89 50 18          	mov    QWORD PTR [rax+0x18],rdx
	c->csize |= C_INUSE;
    14fa:	48 8b 43 08          	mov    rax,QWORD PTR [rbx+0x8]
    14fe:	48 89 c2             	mov    rdx,rax
    1501:	48 83 e0 fe          	and    rax,0xfffffffffffffffe
    1505:	48 83 ca 01          	or     rdx,0x1
    1509:	48 89 53 08          	mov    QWORD PTR [rbx+0x8],rdx
	NEXT_CHUNK(c)->psize |= C_INUSE;
    150d:	48 83 0c 03 01       	or     QWORD PTR [rbx+rax*1],0x1
	if (lk[0]) {
    1512:	41 8b 16             	mov    edx,DWORD PTR [r14]
    1515:	4c 8d 6b 10          	lea    r13,[rbx+0x10]
    1519:	85 d2                	test   edx,edx
    151b:	0f 84 6d fe ff ff    	je     138e <malloc+0x21e>
    1521:	31 c0                	xor    eax,eax
    1523:	41 89 06             	mov    DWORD PTR [r14],eax
    1526:	f0 83 0c 24 00       	lock or DWORD PTR [rsp],0x0
		if (lk[1]) __wake(lk, 1, 1);
    152b:	41 8b 46 04          	mov    eax,DWORD PTR [r14+0x4]
    152f:	85 c0                	test   eax,eax
    1531:	0f 85 2f 02 00 00    	jne    1766 <malloc+0x5f6>
    1537:	48 8b 43 08          	mov    rax,QWORD PTR [rbx+0x8]
    153b:	48 83 e0 fe          	and    rax,0xfffffffffffffffe
    153f:	e9 4a fe ff ff       	jmp    138e <malloc+0x21e>
    1544:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
	__asm__ __volatile__(
    1548:	b8 01 00 00 00       	mov    eax,0x1
    154d:	87 05 95 bb 00 00    	xchg   DWORD PTR [rip+0xbb95],eax        # d0e8 <heap_lock.3637>
		while(a_swap(lk, 1)) __wait(lk, lk+1, 1, 1);
    1553:	85 c0                	test   eax,eax
    1555:	0f 84 99 fd ff ff    	je     12f4 <malloc+0x184>
    155b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
    1560:	b9 01 00 00 00       	mov    ecx,0x1
    1565:	ba 01 00 00 00       	mov    edx,0x1
    156a:	be ec d0 00 00       	mov    esi,0xd0ec
    156f:	bf e8 d0 00 00       	mov    edi,0xd0e8
    1574:	e8 a7 15 00 00       	call   2b20 <__wait>
    1579:	b8 01 00 00 00       	mov    eax,0x1
    157e:	87 05 64 bb 00 00    	xchg   DWORD PTR [rip+0xbb64],eax        # d0e8 <heap_lock.3637>
    1584:	85 c0                	test   eax,eax
    1586:	75 d8                	jne    1560 <malloc+0x3f0>
    1588:	e9 67 fd ff ff       	jmp    12f4 <malloc+0x184>
    158d:	0f 1f 00             	nop    DWORD PTR [rax]
				c = PREV_CHUNK(c);
    1590:	49 8b 45 f0          	mov    rax,QWORD PTR [r13-0x10]
    1594:	48 89 da             	mov    rdx,rbx
    1597:	48 83 e0 fe          	and    rax,0xfffffffffffffffe
    159b:	48 29 c2             	sub    rdx,rax
					x->csize + CHUNK_SIZE(c);
    159e:	48 8b 42 08          	mov    rax,QWORD PTR [rdx+0x8]
    15a2:	48 83 e0 fe          	and    rax,0xfffffffffffffffe
    15a6:	49 03 45 f8          	add    rax,QWORD PTR [r13-0x8]
				NEXT_CHUNK(x)->psize = c->csize =
    15aa:	48 89 42 08          	mov    QWORD PTR [rdx+0x8],rax
    15ae:	49 8b 4d f8          	mov    rcx,QWORD PTR [r13-0x8]
    15b2:	4c 8d 6a 10          	lea    r13,[rdx+0x10]
    15b6:	48 83 e1 fe          	and    rcx,0xfffffffffffffffe
    15ba:	48 89 04 0b          	mov    QWORD PTR [rbx+rcx*1],rax
    15be:	48 83 e0 fe          	and    rax,0xfffffffffffffffe
    15c2:	48 89 d3             	mov    rbx,rdx
    15c5:	e9 c4 fd ff ff       	jmp    138e <malloc+0x21e>
    15ca:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
	if (x < 512) return bin_tab[x/8-4] + 1;
    15d0:	48 c1 e8 03          	shr    rax,0x3
    15d4:	44 0f b6 b0 1c 80 00 00 	movzx  r14d,BYTE PTR [rax+0x801c]
    15dc:	41 8d 46 01          	lea    eax,[r14+0x1]
    15e0:	e9 bd fe ff ff       	jmp    14a2 <malloc+0x332>
    15e5:	0f 1f 00             	nop    DWORD PTR [rax]
		n1 = CHUNK_SIZE(self);
    15e8:	48 8b 73 08          	mov    rsi,QWORD PTR [rbx+0x8]
    15ec:	48 83 e6 fe          	and    rsi,0xfffffffffffffffe
    15f0:	48 89 f7             	mov    rdi,rsi
    15f3:	48 2b 7c 24 10       	sub    rdi,QWORD PTR [rsp+0x10]
	x = x / SIZE_ALIGN - 1;
    15f8:	48 89 f9             	mov    rcx,rdi
    15fb:	48 c1 e9 05          	shr    rcx,0x5
    15ff:	48 83 e9 01          	sub    rcx,0x1
	if (x <= 32) return x;
    1603:	48 83 f9 20          	cmp    rcx,0x20
    1607:	0f 86 dc fe ff ff    	jbe    14e9 <malloc+0x379>
	if (x < 512) return bin_tab[x/8-4];
    160d:	48 81 f9 ff 01 00 00 	cmp    rcx,0x1ff
    1614:	0f 86 ad 01 00 00    	jbe    17c7 <malloc+0x657>
	if (x > 0x1c00) return 63;
    161a:	41 b9 3f 00 00 00    	mov    r9d,0x3f
    1620:	48 81 f9 00 1c 00 00 	cmp    rcx,0x1c00
    1627:	77 10                	ja     1639 <malloc+0x4c9>
	return bin_tab[x/128-4] + 16;
    1629:	48 c1 e9 07          	shr    rcx,0x7
    162d:	44 0f b6 89 1c 80 00 00 	movzx  r9d,BYTE PTR [rcx+0x801c]
    1635:	41 83 c1 10          	add    r9d,0x10
	if (bin_index(n1-n) != j) return 0;
    1639:	44 39 4c 24 18       	cmp    DWORD PTR [rsp+0x18],r9d
    163e:	0f 85 a5 fe ff ff    	jne    14e9 <malloc+0x379>
	split = (void *)((char *)self + n);
    1644:	4c 8b 54 24 10       	mov    r10,QWORD PTR [rsp+0x10]
	split->next = self->next;
    1649:	66 48 0f 6e c0       	movq   xmm0,rax
    164e:	66 48 0f 6e ca       	movq   xmm1,rdx
    1653:	66 0f 6c c1          	punpcklqdq xmm0,xmm1
	split = (void *)((char *)self + n);
    1657:	4a 8d 0c 13          	lea    rcx,[rbx+r10*1]
	split->next = self->next;
    165b:	0f 11 41 10          	movups XMMWORD PTR [rcx+0x10],xmm0
	split->prev->next = split;
    165f:	48 89 4a 10          	mov    QWORD PTR [rdx+0x10],rcx
	split->next->prev = split;
    1663:	48 8b 41 10          	mov    rax,QWORD PTR [rcx+0x10]
    1667:	48 89 48 18          	mov    QWORD PTR [rax+0x18],rcx
	split->psize = n | C_INUSE;
    166b:	4c 89 d0             	mov    rax,r10
    166e:	48 83 c8 01          	or     rax,0x1
	split->csize = n1-n;
    1672:	48 89 79 08          	mov    QWORD PTR [rcx+0x8],rdi
	split->psize = n | C_INUSE;
    1676:	48 89 01             	mov    QWORD PTR [rcx],rax
	next->psize = n1-n;
    1679:	48 89 3c 33          	mov    QWORD PTR [rbx+rsi*1],rdi
	self->csize = n | C_INUSE;
    167d:	48 89 43 08          	mov    QWORD PTR [rbx+0x8],rax
    1681:	4c 89 d0             	mov    rax,r10
    1684:	e9 89 fe ff ff       	jmp    1512 <malloc+0x3a2>
	if (lk[0]) {
    1689:	8b 05 59 ba 00 00    	mov    eax,DWORD PTR [rip+0xba59]        # d0e8 <heap_lock.3637>
    168f:	85 c0                	test   eax,eax
    1691:	74 55                	je     16e8 <malloc+0x578>
	__asm__ __volatile__(
    1693:	31 c0                	xor    eax,eax
    1695:	89 05 4d ba 00 00    	mov    DWORD PTR [rip+0xba4d],eax        # d0e8 <heap_lock.3637>
    169b:	f0 83 0c 24 00       	lock or DWORD PTR [rsp],0x0
		if (lk[1]) __wake(lk, 1, 1);
    16a0:	8b 05 46 ba 00 00    	mov    eax,DWORD PTR [rip+0xba46]        # d0ec <heap_lock.3637+0x4>
    16a6:	85 c0                	test   eax,eax
    16a8:	74 3e                	je     16e8 <malloc+0x578>
	__syscall(SYS_futex, addr, FUTEX_WAKE|priv, cnt) != -ENOSYS ||
    16aa:	b9 01 00 00 00       	mov    ecx,0x1
    16af:	ba 81 00 00 00       	mov    edx,0x81
    16b4:	be e8 d0 00 00       	mov    esi,0xd0e8
    16b9:	bf ca 00 00 00       	mov    edi,0xca
    16be:	e8 5d 10 00 00       	call   2720 <__syscall3>
    16c3:	48 83 f8 da          	cmp    rax,0xffffffffffffffda
    16c7:	75 1f                	jne    16e8 <malloc+0x578>
	__syscall(SYS_futex, addr, FUTEX_WAKE, cnt);
    16c9:	b9 01 00 00 00       	mov    ecx,0x1
    16ce:	ba 01 00 00 00       	mov    edx,0x1
    16d3:	be e8 d0 00 00       	mov    esi,0xd0e8
    16d8:	bf ca 00 00 00       	mov    edi,0xca
    16dd:	e8 3e 10 00 00       	call   2720 <__syscall3>
    16e2:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
			if (!c) return 0;
    16e8:	45 31 ed             	xor    r13d,r13d
    16eb:	e9 64 fd ff ff       	jmp    1454 <malloc+0x2e4>
	__syscall(SYS_futex, addr, FUTEX_WAKE|priv, cnt) != -ENOSYS ||
    16f0:	b9 01 00 00 00       	mov    ecx,0x1
    16f5:	ba 81 00 00 00       	mov    edx,0x81
    16fa:	be e8 d0 00 00       	mov    esi,0xd0e8
    16ff:	bf ca 00 00 00       	mov    edi,0xca
    1704:	e8 17 10 00 00       	call   2720 <__syscall3>
    1709:	48 83 f8 da          	cmp    rax,0xffffffffffffffda
    170d:	0f 85 63 fc ff ff    	jne    1376 <malloc+0x206>
	__syscall(SYS_futex, addr, FUTEX_WAKE, cnt);
    1713:	b9 01 00 00 00       	mov    ecx,0x1
    1718:	ba 01 00 00 00       	mov    edx,0x1
    171d:	be e8 d0 00 00       	mov    esi,0xd0e8
    1722:	bf ca 00 00 00       	mov    edi,0xca
    1727:	e8 f4 0f 00 00       	call   2720 <__syscall3>
    172c:	e9 45 fc ff ff       	jmp    1376 <malloc+0x206>
		n1 = CHUNK_SIZE(self);
    1731:	48 8b 73 08          	mov    rsi,QWORD PTR [rbx+0x8]
    1735:	48 83 e6 fe          	and    rsi,0xfffffffffffffffe
		if (n1-n <= MMAP_THRESHOLD) return 0;
    1739:	48 89 f7             	mov    rdi,rsi
    173c:	48 2b 7c 24 10       	sub    rdi,QWORD PTR [rsp+0x10]
    1741:	48 81 ff 00 80 03 00 	cmp    rdi,0x38000
    1748:	0f 87 aa fe ff ff    	ja     15f8 <malloc+0x488>
    174e:	e9 96 fd ff ff       	jmp    14e9 <malloc+0x379>
			errno = ENOMEM;
    1753:	e8 28 19 00 00       	call   3080 <__errno_location>
	if (adjust_size(&n) < 0) return 0;
    1758:	45 31 ed             	xor    r13d,r13d
			errno = ENOMEM;
    175b:	c7 00 0c 00 00 00    	mov    DWORD PTR [rax],0xc
			return -1;
    1761:	e9 ee fc ff ff       	jmp    1454 <malloc+0x2e4>
	__syscall(SYS_futex, addr, FUTEX_WAKE|priv, cnt) != -ENOSYS ||
    1766:	b9 01 00 00 00       	mov    ecx,0x1
    176b:	ba 81 00 00 00       	mov    edx,0x81
    1770:	4c 89 f6             	mov    rsi,r14
    1773:	bf ca 00 00 00       	mov    edi,0xca
    1778:	e8 a3 0f 00 00       	call   2720 <__syscall3>
    177d:	48 83 f8 da          	cmp    rax,0xffffffffffffffda
    1781:	0f 85 b0 fd ff ff    	jne    1537 <malloc+0x3c7>
	__syscall(SYS_futex, addr, FUTEX_WAKE, cnt);
    1787:	b9 01 00 00 00       	mov    ecx,0x1
    178c:	ba 01 00 00 00       	mov    edx,0x1
    1791:	4c 89 f6             	mov    rsi,r14
    1794:	bf ca 00 00 00       	mov    edi,0xca
    1799:	e8 82 0f 00 00       	call   2720 <__syscall3>
    179e:	e9 94 fd ff ff       	jmp    1537 <malloc+0x3c7>
		a_and_64(&mal.binmap, ~(1ULL<<i));
    17a3:	0f b6 4c 24 18       	movzx  ecx,BYTE PTR [rsp+0x18]
    17a8:	48 c7 c0 fe ff ff ff 	mov    rax,0xfffffffffffffffe
    17af:	48 d3 c0             	rol    rax,cl
	__asm__ __volatile(
    17b2:	f0 48 21 05 46 b9 00 00 	lock and QWORD PTR [rip+0xb946],rax        # d100 <mal>
    17ba:	48 8b 53 18          	mov    rdx,QWORD PTR [rbx+0x18]
    17be:	48 8b 43 10          	mov    rax,QWORD PTR [rbx+0x10]
}
    17c2:	e9 2b fd ff ff       	jmp    14f2 <malloc+0x382>
	if (x < 512) return bin_tab[x/8-4];
    17c7:	48 c1 e9 03          	shr    rcx,0x3
    17cb:	44 0f b6 89 1c 80 00 00 	movzx  r9d,BYTE PTR [rcx+0x801c]
    17d3:	e9 61 fe ff ff       	jmp    1639 <malloc+0x4c9>
    17d8:	48 83 cd ff          	or     rbp,0xffffffffffffffff
    17dc:	89 4c 24 1c          	mov    DWORD PTR [rsp+0x1c],ecx
    17e0:	48 d3 e5             	shl    rbp,cl
    17e3:	48 89 6c 24 08       	mov    QWORD PTR [rsp+0x8],rbp
    17e8:	e9 cb f9 ff ff       	jmp    11b8 <malloc+0x48>
    17ed:	0f 1f 00             	nop    DWORD PTR [rax]

00000000000017f0 <calloc>:
{
    17f0:	41 54                	push   r12
    17f2:	49 89 fc             	mov    r12,rdi
    17f5:	55                   	push   rbp
    17f6:	53                   	push   rbx
	if (n && m > (size_t)-1/n) {
    17f7:	48 85 f6             	test   rsi,rsi
    17fa:	74 08                	je     1804 <calloc+0x14>
    17fc:	48 89 f8             	mov    rax,rdi
    17ff:	48 f7 e6             	mul    rsi
    1802:	70 3e                	jo     1842 <calloc+0x52>
	n *= m;
    1804:	4c 0f af e6          	imul   r12,rsi
	void *p = malloc(n);
    1808:	4c 89 e7             	mov    rdi,r12
    180b:	e8 60 f9 ff ff       	call   1170 <malloc>
    1810:	48 89 c5             	mov    rbp,rax
	if (!p) return p;
    1813:	48 85 c0             	test   rax,rax
    1816:	74 37                	je     184f <calloc+0x5f>
	if (!__malloc_replaced) {
    1818:	8b 05 72 b8 00 00    	mov    eax,DWORD PTR [rip+0xb872]        # d090 <__malloc_replaced>
    181e:	85 c0                	test   eax,eax
    1820:	75 0f                	jne    1831 <calloc+0x41>
		if (IS_MMAPPED(MEM_TO_CHUNK(p)))
    1822:	f6 45 f8 01          	test   BYTE PTR [rbp-0x8],0x1
    1826:	74 27                	je     184f <calloc+0x5f>
		if (n >= PAGE_SIZE)
    1828:	49 81 fc ff 0f 00 00 	cmp    r12,0xfff
    182f:	77 2f                	ja     1860 <calloc+0x70>
}
    1831:	5b                   	pop    rbx
	return memset(p, 0, n);
    1832:	4c 89 e2             	mov    rdx,r12
    1835:	48 89 ef             	mov    rdi,rbp
    1838:	31 f6                	xor    esi,esi
}
    183a:	5d                   	pop    rbp
    183b:	41 5c                	pop    r12
	return memset(p, 0, n);
    183d:	e9 60 0f 00 00       	jmp    27a2 <memset>
		errno = ENOMEM;
    1842:	e8 39 18 00 00       	call   3080 <__errno_location>
		return 0;
    1847:	31 ed                	xor    ebp,ebp
		errno = ENOMEM;
    1849:	c7 00 0c 00 00 00    	mov    DWORD PTR [rax],0xc
}
    184f:	48 89 e8             	mov    rax,rbp
    1852:	5b                   	pop    rbx
    1853:	5d                   	pop    rbp
    1854:	41 5c                	pop    r12
    1856:	c3                   	ret    
    1857:	66 0f 1f 84 00 00 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
	char *pp = p + n;
    1860:	4a 8d 7c 25 00       	lea    rdi,[rbp+r12*1+0x0]
	size_t i = (uintptr_t)pp & (pagesz - 1);
    1865:	bb 00 10 00 00       	mov    ebx,0x1000
    186a:	48 89 fa             	mov    rdx,rdi
    186d:	81 e2 ff 0f 00 00    	and    edx,0xfff
    1873:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
		pp = memset(pp - i, 0, i);
    1878:	48 29 d7             	sub    rdi,rdx
    187b:	31 f6                	xor    esi,esi
    187d:	e8 20 0f 00 00       	call   27a2 <memset>
		if (pp - p < pagesz) return pp - p;
    1882:	49 89 c4             	mov    r12,rax
    1885:	49 29 ec             	sub    r12,rbp
    1888:	49 81 fc ff 0f 00 00 	cmp    r12,0xfff
    188f:	76 a0                	jbe    1831 <calloc+0x41>
    1891:	48 89 d9             	mov    rcx,rbx
    1894:	48 8d b8 00 f0 ff ff 	lea    rdi,[rax-0x1000]
    189b:	48 29 c1             	sub    rcx,rax
    189e:	eb 09                	jmp    18a9 <calloc+0xb9>
		for (i = pagesz; i; i -= 2*sizeof(T), pp -= 2*sizeof(T))
    18a0:	48 83 e8 10          	sub    rax,0x10
    18a4:	48 39 c7             	cmp    rdi,rax
    18a7:	74 cf                	je     1878 <calloc+0x88>
		        if (((T *)pp)[-1] | ((T *)pp)[-2])
    18a9:	48 8b 50 f8          	mov    rdx,QWORD PTR [rax-0x8]
    18ad:	48 8d 34 08          	lea    rsi,[rax+rcx*1]
    18b1:	48 0b 50 f0          	or     rdx,QWORD PTR [rax-0x10]
    18b5:	74 e9                	je     18a0 <calloc+0xb0>
    18b7:	48 89 f2             	mov    rdx,rsi
    18ba:	48 89 c7             	mov    rdi,rax
    18bd:	eb b9                	jmp    1878 <calloc+0x88>
    18bf:	90                   	nop

00000000000018c0 <realloc>:
	if (!p) return malloc(n);
    18c0:	48 85 ff             	test   rdi,rdi
    18c3:	0f 84 d7 01 00 00    	je     1aa0 <realloc+0x1e0>
	if (*n-1 > PTRDIFF_MAX - SIZE_ALIGN - PAGE_SIZE) {
    18c9:	48 b8 df ef ff ff ff ff ff 7f 	movabs rax,0x7fffffffffffefdf
{
    18d3:	41 57                	push   r15
	if (*n-1 > PTRDIFF_MAX - SIZE_ALIGN - PAGE_SIZE) {
    18d5:	48 8d 56 ff          	lea    rdx,[rsi-0x1]
{
    18d9:	41 56                	push   r14
    18db:	41 55                	push   r13
    18dd:	41 54                	push   r12
    18df:	55                   	push   rbp
    18e0:	48 89 fd             	mov    rbp,rdi
    18e3:	53                   	push   rbx
    18e4:	48 83 ec 28          	sub    rsp,0x28
	if (*n-1 > PTRDIFF_MAX - SIZE_ALIGN - PAGE_SIZE) {
    18e8:	48 39 c2             	cmp    rdx,rax
    18eb:	0f 87 a7 00 00 00    	ja     1998 <realloc+0xd8>
	*n = (*n + OVERHEAD + SIZE_ALIGN - 1) & SIZE_MASK;
    18f1:	48 8d 5e 2f          	lea    rbx,[rsi+0x2f]
    18f5:	48 83 e3 e0          	and    rbx,0xffffffffffffffe0
	n1 = n0 = CHUNK_SIZE(self);
    18f9:	48 8b 45 f8          	mov    rax,QWORD PTR [rbp-0x8]
	self = MEM_TO_CHUNK(p);
    18fd:	4c 8d 75 f0          	lea    r14,[rbp-0x10]
	n1 = n0 = CHUNK_SIZE(self);
    1901:	49 89 c7             	mov    r15,rax
    1904:	49 83 e7 fe          	and    r15,0xfffffffffffffffe
	if (IS_MMAPPED(self)) {
    1908:	a8 01                	test   al,0x1
    190a:	0f 85 a0 00 00 00    	jne    19b0 <realloc+0xf0>
		size_t extra = self->psize;
    1910:	4c 8b 45 f0          	mov    r8,QWORD PTR [rbp-0x10]
		size_t oldlen = n0 + extra;
    1914:	4b 8d 34 07          	lea    rsi,[r15+r8*1]
		size_t newlen = n + extra;
    1918:	4d 8d 2c 18          	lea    r13,[r8+rbx*1]
		if (extra & 1) a_crash();
    191c:	41 f6 c0 01          	test   r8b,0x1
    1920:	0f 85 c2 00 00 00    	jne    19e8 <realloc+0x128>
		if (newlen < PAGE_SIZE && (new = malloc(n-OVERHEAD))) {
    1926:	49 81 fd ff 0f 00 00 	cmp    r13,0xfff
    192d:	0f 86 c3 00 00 00    	jbe    19f6 <realloc+0x136>
		newlen = (newlen + PAGE_SIZE-1) & -PAGE_SIZE;
    1933:	49 81 c5 ff 0f 00 00 	add    r13,0xfff
    193a:	49 81 e5 00 f0 ff ff 	and    r13,0xfffffffffffff000
		if (oldlen == newlen) return p;
    1941:	4c 39 ee             	cmp    rsi,r13
    1944:	0f 84 92 00 00 00    	je     19dc <realloc+0x11c>
		char *base = (char *)self - extra;
    194a:	4c 89 f7             	mov    rdi,r14
		base = __mremap(base, oldlen, newlen, MREMAP_MAYMOVE);
    194d:	31 c0                	xor    eax,eax
    194f:	b9 01 00 00 00       	mov    ecx,0x1
    1954:	4c 89 ea             	mov    rdx,r13
		char *base = (char *)self - extra;
    1957:	4c 29 c7             	sub    rdi,r8
    195a:	4c 89 44 24 08       	mov    QWORD PTR [rsp+0x8],r8
		base = __mremap(base, oldlen, newlen, MREMAP_MAYMOVE);
    195f:	e8 dc 03 00 00       	call   1d40 <__mremap>
		if (base == (void *)-1)
    1964:	48 83 f8 ff          	cmp    rax,0xffffffffffffffff
    1968:	0f 84 e2 00 00 00    	je     1a50 <realloc+0x190>
		self = (void *)(base + extra);
    196e:	4c 8b 44 24 08       	mov    r8,QWORD PTR [rsp+0x8]
    1973:	4c 01 c0             	add    rax,r8
		self->csize = newlen - extra;
    1976:	4d 29 c5             	sub    r13,r8
    1979:	4c 89 68 08          	mov    QWORD PTR [rax+0x8],r13
		return CHUNK_TO_MEM(self);
    197d:	4c 8d 60 10          	lea    r12,[rax+0x10]
}
    1981:	48 83 c4 28          	add    rsp,0x28
    1985:	4c 89 e0             	mov    rax,r12
    1988:	5b                   	pop    rbx
    1989:	5d                   	pop    rbp
    198a:	41 5c                	pop    r12
    198c:	41 5d                	pop    r13
    198e:	41 5e                	pop    r14
    1990:	41 5f                	pop    r15
    1992:	c3                   	ret    
    1993:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
		if (*n) {
    1998:	48 85 f6             	test   rsi,rsi
    199b:	0f 85 7e 01 00 00    	jne    1b1f <realloc+0x25f>
			*n = SIZE_ALIGN;
    19a1:	bb 20 00 00 00       	mov    ebx,0x20
    19a6:	e9 4e ff ff ff       	jmp    18f9 <realloc+0x39>
    19ab:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
	next = NEXT_CHUNK(self);
    19b0:	4f 8d 24 3e          	lea    r12,[r14+r15*1]
	if (next->psize != self->csize) a_crash();
    19b4:	49 3b 04 24          	cmp    rax,QWORD PTR [r12]
    19b8:	74 01                	je     19bb <realloc+0xfb>
	__asm__ __volatile__( "hlt" : : : "memory" );
    19ba:	f4                   	hlt    
	if (n > n1 && alloc_fwd(next)) {
    19bb:	49 39 df             	cmp    r15,rbx
    19be:	72 70                	jb     1a30 <realloc+0x170>
	self->csize = n1 | C_INUSE;
    19c0:	4c 89 f8             	mov    rax,r15
    19c3:	48 83 c8 01          	or     rax,0x1
    19c7:	48 89 45 f8          	mov    QWORD PTR [rbp-0x8],rax
	next->psize = n1 | C_INUSE;
    19cb:	49 89 04 24          	mov    QWORD PTR [r12],rax
	if (n >= n1 - DONTCARE) return;
    19cf:	49 8d 47 f0          	lea    rax,[r15-0x10]
    19d3:	48 39 c3             	cmp    rbx,rax
    19d6:	0f 82 14 01 00 00    	jb     1af0 <realloc+0x230>
	__bin_chunk(split);
    19dc:	49 89 ec             	mov    r12,rbp
    19df:	eb a0                	jmp    1981 <realloc+0xc1>
    19e1:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
    19e8:	f4                   	hlt    
		if (newlen < PAGE_SIZE && (new = malloc(n-OVERHEAD))) {
    19e9:	49 81 fd ff 0f 00 00 	cmp    r13,0xfff
    19f0:	0f 87 3d ff ff ff    	ja     1933 <realloc+0x73>
    19f6:	48 8d 53 f0          	lea    rdx,[rbx-0x10]
    19fa:	48 89 74 24 18       	mov    QWORD PTR [rsp+0x18],rsi
    19ff:	48 89 d7             	mov    rdi,rdx
    1a02:	48 89 54 24 08       	mov    QWORD PTR [rsp+0x8],rdx
    1a07:	4c 89 44 24 10       	mov    QWORD PTR [rsp+0x10],r8
    1a0c:	e8 5f f7 ff ff       	call   1170 <malloc>
    1a11:	48 8b 54 24 08       	mov    rdx,QWORD PTR [rsp+0x8]
    1a16:	48 85 c0             	test   rax,rax
    1a19:	49 89 c4             	mov    r12,rax
    1a1c:	75 4b                	jne    1a69 <realloc+0x1a9>
    1a1e:	4c 8b 44 24 10       	mov    r8,QWORD PTR [rsp+0x10]
    1a23:	48 8b 74 24 18       	mov    rsi,QWORD PTR [rsp+0x18]
    1a28:	e9 06 ff ff ff       	jmp    1933 <realloc+0x73>
    1a2d:	0f 1f 00             	nop    DWORD PTR [rax]
	if (n > n1 && alloc_fwd(next)) {
    1a30:	4c 89 e7             	mov    rdi,r12
    1a33:	e8 98 ec ff ff       	call   6d0 <alloc_fwd>
    1a38:	85 c0                	test   eax,eax
    1a3a:	0f 85 80 00 00 00    	jne    1ac0 <realloc+0x200>
	self->csize = n1 | C_INUSE;
    1a40:	4c 89 f8             	mov    rax,r15
    1a43:	48 83 c8 01          	or     rax,0x1
    1a47:	48 89 45 f8          	mov    QWORD PTR [rbp-0x8],rax
	next->psize = n1 | C_INUSE;
    1a4b:	49 89 04 24          	mov    QWORD PTR [r12],rax
	if (n <= n1) {
    1a4f:	90                   	nop
	new = malloc(n-OVERHEAD);
    1a50:	48 8d 7b f0          	lea    rdi,[rbx-0x10]
    1a54:	e8 17 f7 ff ff       	call   1170 <malloc>
    1a59:	49 89 c4             	mov    r12,rax
	if (!new) return 0;
    1a5c:	48 85 c0             	test   rax,rax
    1a5f:	0f 84 1c ff ff ff    	je     1981 <realloc+0xc1>
    1a65:	49 8d 57 f0          	lea    rdx,[r15-0x10]
	memcpy(new, p, n0-OVERHEAD);
    1a69:	48 89 ee             	mov    rsi,rbp
    1a6c:	4c 89 e7             	mov    rdi,r12
    1a6f:	e8 fc 0c 00 00       	call   2770 <memcpy>
{
	if (!p) return;

	struct chunk *self = MEM_TO_CHUNK(p);

	if (IS_MMAPPED(self))
    1a74:	48 8b 75 f8          	mov    rsi,QWORD PTR [rbp-0x8]
    1a78:	40 f6 c6 01          	test   sil,0x1
    1a7c:	75 32                	jne    1ab0 <realloc+0x1f0>
	size_t extra = self->psize;
    1a7e:	48 8b 45 f0          	mov    rax,QWORD PTR [rbp-0x10]
	char *base = (char *)self - extra;
    1a82:	4c 89 f7             	mov    rdi,r14
	size_t len = CHUNK_SIZE(self) + extra;
    1a85:	48 83 e6 fe          	and    rsi,0xfffffffffffffffe
	char *base = (char *)self - extra;
    1a89:	48 29 c7             	sub    rdi,rax
	size_t len = CHUNK_SIZE(self) + extra;
    1a8c:	48 01 c6             	add    rsi,rax
	if (extra & 1) a_crash();
    1a8f:	a8 01                	test   al,0x1
    1a91:	74 01                	je     1a94 <realloc+0x1d4>
    1a93:	f4                   	hlt    
	__munmap(base, len);
    1a94:	e8 67 03 00 00       	call   1e00 <__munmap>
}
    1a99:	e9 e3 fe ff ff       	jmp    1981 <realloc+0xc1>
    1a9e:	66 90                	xchg   ax,ax
	if (!p) return malloc(n);
    1aa0:	48 89 f7             	mov    rdi,rsi
    1aa3:	e9 c8 f6 ff ff       	jmp    1170 <malloc>
    1aa8:	0f 1f 84 00 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
		unmap_chunk(self);
	else
		__bin_chunk(self);
    1ab0:	4c 89 f7             	mov    rdi,r14
    1ab3:	e8 d8 f1 ff ff       	call   c90 <__bin_chunk>
    1ab8:	e9 c4 fe ff ff       	jmp    1981 <realloc+0xc1>
    1abd:	0f 1f 00             	nop    DWORD PTR [rax]
		n1 += CHUNK_SIZE(next);
    1ac0:	49 8b 44 24 08       	mov    rax,QWORD PTR [r12+0x8]
    1ac5:	48 83 e0 fe          	and    rax,0xfffffffffffffffe
    1ac9:	4a 8d 14 38          	lea    rdx,[rax+r15*1]
	self->csize = n1 | C_INUSE;
    1acd:	48 89 d1             	mov    rcx,rdx
    1ad0:	48 83 c9 01          	or     rcx,0x1
    1ad4:	48 89 4d f8          	mov    QWORD PTR [rbp-0x8],rcx
	next->psize = n1 | C_INUSE;
    1ad8:	49 89 0c 04          	mov    QWORD PTR [r12+rax*1],rcx
	if (n <= n1) {
    1adc:	48 39 da             	cmp    rdx,rbx
    1adf:	0f 82 6b ff ff ff    	jb     1a50 <realloc+0x190>
    1ae5:	49 89 d7             	mov    r15,rdx
    1ae8:	e9 e2 fe ff ff       	jmp    19cf <realloc+0x10f>
    1aed:	0f 1f 00             	nop    DWORD PTR [rax]
	split->csize = n1-n | C_INUSE;
    1af0:	4c 89 f8             	mov    rax,r15
	split->psize = n | C_INUSE;
    1af3:	48 89 da             	mov    rdx,rbx
	split = (void *)((char *)self + n);
    1af6:	49 8d 3c 1e          	lea    rdi,[r14+rbx*1]
	split->csize = n1-n | C_INUSE;
    1afa:	48 29 d8             	sub    rax,rbx
	split->psize = n | C_INUSE;
    1afd:	48 83 ca 01          	or     rdx,0x1
	split->csize = n1-n | C_INUSE;
    1b01:	48 83 c8 01          	or     rax,0x1
	split->psize = n | C_INUSE;
    1b05:	48 89 17             	mov    QWORD PTR [rdi],rdx
	split->csize = n1-n | C_INUSE;
    1b08:	48 89 47 08          	mov    QWORD PTR [rdi+0x8],rax
	next->psize = n1-n | C_INUSE;
    1b0c:	4a 89 44 3d f0       	mov    QWORD PTR [rbp+r15*1-0x10],rax
	self->csize = n | C_INUSE;
    1b11:	48 89 55 f8          	mov    QWORD PTR [rbp-0x8],rdx
	__bin_chunk(split);
    1b15:	e8 76 f1 ff ff       	call   c90 <__bin_chunk>
    1b1a:	e9 bd fe ff ff       	jmp    19dc <realloc+0x11c>
			errno = ENOMEM;
    1b1f:	e8 5c 15 00 00       	call   3080 <__errno_location>
	if (adjust_size(&n) < 0) return 0;
    1b24:	45 31 e4             	xor    r12d,r12d
			errno = ENOMEM;
    1b27:	c7 00 0c 00 00 00    	mov    DWORD PTR [rax],0xc
			return -1;
    1b2d:	e9 4f fe ff ff       	jmp    1981 <realloc+0xc1>
    1b32:	66 66 2e 0f 1f 84 00 00 00 00 00 	data16 nop WORD PTR cs:[rax+rax*1+0x0]
    1b3d:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000001b40 <free>:
	if (!p) return;
    1b40:	48 85 ff             	test   rdi,rdi
    1b43:	74 3b                	je     1b80 <free+0x40>
	if (IS_MMAPPED(self))
    1b45:	48 8b 77 f8          	mov    rsi,QWORD PTR [rdi-0x8]
	struct chunk *self = MEM_TO_CHUNK(p);
    1b49:	4c 8d 47 f0          	lea    r8,[rdi-0x10]
	if (IS_MMAPPED(self))
    1b4d:	40 f6 c6 01          	test   sil,0x1
    1b51:	75 1d                	jne    1b70 <free+0x30>
	size_t extra = self->psize;
    1b53:	48 8b 47 f0          	mov    rax,QWORD PTR [rdi-0x10]
	size_t len = CHUNK_SIZE(self) + extra;
    1b57:	48 83 e6 fe          	and    rsi,0xfffffffffffffffe
	char *base = (char *)self - extra;
    1b5b:	4c 89 c7             	mov    rdi,r8
    1b5e:	48 29 c7             	sub    rdi,rax
	size_t len = CHUNK_SIZE(self) + extra;
    1b61:	48 01 c6             	add    rsi,rax
	if (extra & 1) a_crash();
    1b64:	a8 01                	test   al,0x1
    1b66:	74 01                	je     1b69 <free+0x29>
    1b68:	f4                   	hlt    
	__munmap(base, len);
    1b69:	e9 92 02 00 00       	jmp    1e00 <__munmap>
    1b6e:	66 90                	xchg   ax,ax
		__bin_chunk(self);
    1b70:	4c 89 c7             	mov    rdi,r8
    1b73:	e9 18 f1 ff ff       	jmp    c90 <__bin_chunk>
    1b78:	0f 1f 84 00 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
}
    1b80:	c3                   	ret    
    1b81:	66 66 2e 0f 1f 84 00 00 00 00 00 	data16 nop WORD PTR cs:[rax+rax*1+0x0]
    1b8c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

0000000000001b90 <__malloc_donate>:

void __malloc_donate(char *start, char *end)
{
	size_t align_start_up = (SIZE_ALIGN-1) & (-(uintptr_t)start - OVERHEAD);
    1b90:	48 c7 c0 f0 ff ff ff 	mov    rax,0xfffffffffffffff0
	size_t align_end_down = (SIZE_ALIGN-1) & (uintptr_t)end;
    1b97:	48 89 f2             	mov    rdx,rsi

	/* Getting past this condition ensures that the padding for alignment
	 * and header overhead will not overflow and will leave a nonzero
	 * multiple of SIZE_ALIGN bytes between start and end. */
	if (end - start <= OVERHEAD + align_start_up + align_end_down)
    1b9a:	48 89 f1             	mov    rcx,rsi
	size_t align_start_up = (SIZE_ALIGN-1) & (-(uintptr_t)start - OVERHEAD);
    1b9d:	48 29 f8             	sub    rax,rdi
	size_t align_end_down = (SIZE_ALIGN-1) & (uintptr_t)end;
    1ba0:	83 e2 1f             	and    edx,0x1f
	if (end - start <= OVERHEAD + align_start_up + align_end_down)
    1ba3:	48 29 f9             	sub    rcx,rdi
	size_t align_start_up = (SIZE_ALIGN-1) & (-(uintptr_t)start - OVERHEAD);
    1ba6:	83 e0 1f             	and    eax,0x1f
	if (end - start <= OVERHEAD + align_start_up + align_end_down)
    1ba9:	48 8d 54 10 10       	lea    rdx,[rax+rdx*1+0x10]
    1bae:	48 39 d1             	cmp    rcx,rdx
    1bb1:	77 05                	ja     1bb8 <__malloc_donate+0x28>

	struct chunk *c = MEM_TO_CHUNK(start), *n = MEM_TO_CHUNK(end);
	c->psize = n->csize = C_INUSE;
	c->csize = n->psize = C_INUSE | (end-start);
	__bin_chunk(c);
}
    1bb3:	c3                   	ret    
    1bb4:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
	end   -= align_end_down;
    1bb8:	48 83 e6 e0          	and    rsi,0xffffffffffffffe0
	start += align_start_up + OVERHEAD;
    1bbc:	48 8d 4c 07 10       	lea    rcx,[rdi+rax*1+0x10]
	struct chunk *c = MEM_TO_CHUNK(start), *n = MEM_TO_CHUNK(end);
    1bc1:	48 01 c7             	add    rdi,rax
	c->csize = n->psize = C_INUSE | (end-start);
    1bc4:	48 89 f2             	mov    rdx,rsi
	c->psize = n->csize = C_INUSE;
    1bc7:	48 c7 46 f8 01 00 00 00 	mov    QWORD PTR [rsi-0x8],0x1
	c->csize = n->psize = C_INUSE | (end-start);
    1bcf:	48 29 ca             	sub    rdx,rcx
	c->psize = n->csize = C_INUSE;
    1bd2:	48 c7 41 f0 01 00 00 00 	mov    QWORD PTR [rcx-0x10],0x1
	c->csize = n->psize = C_INUSE | (end-start);
    1bda:	48 83 ca 01          	or     rdx,0x1
    1bde:	48 89 56 f0          	mov    QWORD PTR [rsi-0x10],rdx
    1be2:	48 89 51 f8          	mov    QWORD PTR [rcx-0x8],rdx
	__bin_chunk(c);
    1be6:	e9 a5 f0 ff ff       	jmp    c90 <__bin_chunk>
    1beb:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

0000000000001bf0 <__madvise>:
#include <sys/mman.h>
#include "syscall.h"

int __madvise(void *addr, size_t len, int advice)
{
    1bf0:	48 83 ec 08          	sub    rsp,0x8
	return syscall(SYS_madvise, addr, len, advice);
    1bf4:	48 63 ca             	movsxd rcx,edx
    1bf7:	48 89 f2             	mov    rdx,rsi
    1bfa:	48 89 fe             	mov    rsi,rdi
    1bfd:	bf 1c 00 00 00       	mov    edi,0x1c
    1c02:	e8 19 0b 00 00       	call   2720 <__syscall3>
    1c07:	48 89 c7             	mov    rdi,rax
    1c0a:	e8 81 14 00 00       	call   3090 <__syscall_ret>
}
    1c0f:	48 83 c4 08          	add    rsp,0x8
    1c13:	c3                   	ret    
    1c14:	66 2e 0f 1f 84 00 00 00 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
    1c1e:	66 90                	xchg   ax,ax

0000000000001c20 <__vm_wait>:
#include <errno.h>
#include <stdint.h>
#include <limits.h>
#include "syscall.h"

static void dummy(void) { }
    1c20:	c3                   	ret    
    1c21:	66 66 2e 0f 1f 84 00 00 00 00 00 	data16 nop WORD PTR cs:[rax+rax*1+0x0]
    1c2c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

0000000000001c30 <__mmap>:

#define UNIT SYSCALL_MMAP2_UNIT
#define OFF_MASK ((-0x2000ULL << (8*sizeof(syscall_arg_t)-1)) | (UNIT-1))

void *__mmap(void *start, size_t len, int prot, int flags, int fd, off_t off)
{
    1c30:	41 55                	push   r13
    1c32:	41 54                	push   r12
    1c34:	53                   	push   rbx
    1c35:	48 83 ec 10          	sub    rsp,0x10
	long ret;
	if (off & OFF_MASK) {
    1c39:	41 f7 c1 ff 0f 00 00 	test   r9d,0xfff
    1c40:	0f 85 9a 00 00 00    	jne    1ce0 <__mmap+0xb0>
		errno = EINVAL;
		return MAP_FAILED;
	}
	if (len >= PTRDIFF_MAX) {
    1c46:	48 b8 fe ff ff ff ff ff ff 7f 	movabs rax,0x7ffffffffffffffe
    1c50:	49 89 f4             	mov    r12,rsi
    1c53:	48 39 c6             	cmp    rsi,rax
    1c56:	77 68                	ja     1cc0 <__mmap+0x90>
    1c58:	49 89 fd             	mov    r13,rdi
    1c5b:	89 cb                	mov    ebx,ecx
		errno = ENOMEM;
		return MAP_FAILED;
	}
	if (flags & MAP_FIXED) {
    1c5d:	f6 c1 10             	test   cl,0x10
    1c60:	0f 85 a2 00 00 00    	jne    1d08 <__mmap+0xd8>
		__vm_wait();
	}
#ifdef SYS_mmap2
	ret = __syscall(SYS_mmap2, start, len, prot, flags, fd, off/UNIT);
#else
	ret = __syscall(SYS_mmap, start, len, prot, flags, fd, off);
    1c66:	48 83 ec 08          	sub    rsp,0x8
    1c6a:	48 63 ca             	movsxd rcx,edx
    1c6d:	4c 89 ee             	mov    rsi,r13
    1c70:	4c 89 e2             	mov    rdx,r12
    1c73:	41 51                	push   r9
    1c75:	bf 09 00 00 00       	mov    edi,0x9
    1c7a:	4d 63 c8             	movsxd r9,r8d
    1c7d:	4c 63 c3             	movsxd r8,ebx
    1c80:	e8 bb 01 00 00       	call   1e40 <__syscall6>
#endif
	/* Fixup incorrect EPERM from kernel. */
	if (ret == -EPERM && !start && (flags&MAP_ANON) && !(flags&MAP_FIXED))
    1c85:	5a                   	pop    rdx
    1c86:	59                   	pop    rcx
    1c87:	48 83 f8 ff          	cmp    rax,0xffffffffffffffff
    1c8b:	75 63                	jne    1cf0 <__mmap+0xc0>
    1c8d:	4d 85 ed             	test   r13,r13
    1c90:	75 5e                	jne    1cf0 <__mmap+0xc0>
    1c92:	83 e3 30             	and    ebx,0x30
    1c95:	48 c7 c0 ff ff ff ff 	mov    rax,0xffffffffffffffff
    1c9c:	48 c7 c7 f4 ff ff ff 	mov    rdi,0xfffffffffffffff4
    1ca3:	83 fb 20             	cmp    ebx,0x20
    1ca6:	48 0f 45 f8          	cmovne rdi,rax
		ret = -ENOMEM;
	return (void *)__syscall_ret(ret);
}
    1caa:	48 83 c4 10          	add    rsp,0x10
    1cae:	5b                   	pop    rbx
    1caf:	41 5c                	pop    r12
    1cb1:	41 5d                	pop    r13
	return (void *)__syscall_ret(ret);
    1cb3:	e9 d8 13 00 00       	jmp    3090 <__syscall_ret>
    1cb8:	0f 1f 84 00 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
		errno = ENOMEM;
    1cc0:	e8 bb 13 00 00       	call   3080 <__errno_location>
    1cc5:	c7 00 0c 00 00 00    	mov    DWORD PTR [rax],0xc
}
    1ccb:	48 83 c4 10          	add    rsp,0x10
    1ccf:	48 c7 c0 ff ff ff ff 	mov    rax,0xffffffffffffffff
    1cd6:	5b                   	pop    rbx
    1cd7:	41 5c                	pop    r12
    1cd9:	41 5d                	pop    r13
    1cdb:	c3                   	ret    
    1cdc:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
		errno = EINVAL;
    1ce0:	e8 9b 13 00 00       	call   3080 <__errno_location>
    1ce5:	c7 00 16 00 00 00    	mov    DWORD PTR [rax],0x16
		return MAP_FAILED;
    1ceb:	eb de                	jmp    1ccb <__mmap+0x9b>
    1ced:	0f 1f 00             	nop    DWORD PTR [rax]
}
    1cf0:	48 83 c4 10          	add    rsp,0x10
    1cf4:	48 89 c7             	mov    rdi,rax
    1cf7:	5b                   	pop    rbx
    1cf8:	41 5c                	pop    r12
    1cfa:	41 5d                	pop    r13
	return (void *)__syscall_ret(ret);
    1cfc:	e9 8f 13 00 00       	jmp    3090 <__syscall_ret>
    1d01:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
    1d08:	4c 89 4c 24 08       	mov    QWORD PTR [rsp+0x8],r9
    1d0d:	44 89 44 24 04       	mov    DWORD PTR [rsp+0x4],r8d
    1d12:	89 14 24             	mov    DWORD PTR [rsp],edx
		__vm_wait();
    1d15:	e8 06 ff ff ff       	call   1c20 <__vm_wait>
    1d1a:	4c 8b 4c 24 08       	mov    r9,QWORD PTR [rsp+0x8]
    1d1f:	44 8b 44 24 04       	mov    r8d,DWORD PTR [rsp+0x4]
    1d24:	8b 14 24             	mov    edx,DWORD PTR [rsp]
    1d27:	e9 3a ff ff ff       	jmp    1c66 <__mmap+0x36>
    1d2c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

0000000000001d30 <dummy>:
#include <errno.h>
#include <stdint.h>
#include <stdarg.h>
#include "syscall.h"

static void dummy(void) { }
    1d30:	c3                   	ret    
    1d31:	66 66 2e 0f 1f 84 00 00 00 00 00 	data16 nop WORD PTR cs:[rax+rax*1+0x0]
    1d3c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

0000000000001d40 <__mremap>:
void *__mremap(void *old_addr, size_t old_len, size_t new_len, int flags, ...)
{
	va_list ap;
	void *new_addr = 0;

	if (new_len >= PTRDIFF_MAX) {
    1d40:	48 b8 fe ff ff ff ff ff ff 7f 	movabs rax,0x7ffffffffffffffe
{
    1d4a:	41 55                	push   r13
    1d4c:	41 54                	push   r12
    1d4e:	55                   	push   rbp
    1d4f:	53                   	push   rbx
    1d50:	48 83 ec 58          	sub    rsp,0x58
    1d54:	4c 89 44 24 40       	mov    QWORD PTR [rsp+0x40],r8
	if (new_len >= PTRDIFF_MAX) {
    1d59:	48 39 c2             	cmp    rdx,rax
    1d5c:	77 72                	ja     1dd0 <__mremap+0x90>
    1d5e:	48 89 fd             	mov    rbp,rdi
    1d61:	49 89 f5             	mov    r13,rsi
    1d64:	49 89 d4             	mov    r12,rdx
    1d67:	89 cb                	mov    ebx,ecx
		errno = ENOMEM;
		return MAP_FAILED;
	}

	if (flags & MREMAP_FIXED) {
    1d69:	45 31 c9             	xor    r9d,r9d
    1d6c:	f6 c1 02             	test   cl,0x2
    1d6f:	75 2f                	jne    1da0 <__mremap+0x60>
		va_start(ap, flags);
		new_addr = va_arg(ap, void *);
		va_end(ap);
	}

	return (void *)syscall(SYS_mremap, old_addr, old_len, new_len, flags, new_addr);
    1d71:	4c 63 c3             	movsxd r8,ebx
    1d74:	4c 89 e1             	mov    rcx,r12
    1d77:	4c 89 ea             	mov    rdx,r13
    1d7a:	48 89 ee             	mov    rsi,rbp
    1d7d:	bf 19 00 00 00       	mov    edi,0x19
    1d82:	e8 d9 09 00 00       	call   2760 <__syscall5>
    1d87:	48 89 c7             	mov    rdi,rax
    1d8a:	e8 01 13 00 00       	call   3090 <__syscall_ret>
}
    1d8f:	48 83 c4 58          	add    rsp,0x58
    1d93:	5b                   	pop    rbx
    1d94:	5d                   	pop    rbp
    1d95:	41 5c                	pop    r12
    1d97:	41 5d                	pop    r13
    1d99:	c3                   	ret    
    1d9a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
		__vm_wait();
    1da0:	e8 7b fe ff ff       	call   1c20 <__vm_wait>
		va_start(ap, flags);
    1da5:	48 8d 84 24 80 00 00 00 	lea    rax,[rsp+0x80]
    1dad:	4c 8b 4c 24 40       	mov    r9,QWORD PTR [rsp+0x40]
    1db2:	c7 44 24 08 20 00 00 00 	mov    DWORD PTR [rsp+0x8],0x20
    1dba:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
    1dbf:	48 8d 44 24 20       	lea    rax,[rsp+0x20]
    1dc4:	48 89 44 24 18       	mov    QWORD PTR [rsp+0x18],rax
		va_end(ap);
    1dc9:	eb a6                	jmp    1d71 <__mremap+0x31>
    1dcb:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
		errno = ENOMEM;
    1dd0:	e8 ab 12 00 00       	call   3080 <__errno_location>
    1dd5:	c7 00 0c 00 00 00    	mov    DWORD PTR [rax],0xc
}
    1ddb:	48 83 c4 58          	add    rsp,0x58
		return MAP_FAILED;
    1ddf:	48 c7 c0 ff ff ff ff 	mov    rax,0xffffffffffffffff
}
    1de6:	5b                   	pop    rbx
    1de7:	5d                   	pop    rbp
    1de8:	41 5c                	pop    r12
    1dea:	41 5d                	pop    r13
    1dec:	c3                   	ret    
    1ded:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000001df0 <dummy>:
#include <sys/mman.h>
#include "syscall.h"

static void dummy(void) { }
    1df0:	c3                   	ret    
    1df1:	66 66 2e 0f 1f 84 00 00 00 00 00 	data16 nop WORD PTR cs:[rax+rax*1+0x0]
    1dfc:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

0000000000001e00 <__munmap>:
weak_alias(dummy, __vm_wait);

int __munmap(void *start, size_t len)
{
    1e00:	41 54                	push   r12
    1e02:	49 89 f4             	mov    r12,rsi
    1e05:	55                   	push   rbp
    1e06:	48 89 fd             	mov    rbp,rdi
    1e09:	48 83 ec 08          	sub    rsp,0x8
	__vm_wait();
    1e0d:	e8 0e fe ff ff       	call   1c20 <__vm_wait>
	return syscall(SYS_munmap, start, len);
    1e12:	4c 89 e2             	mov    rdx,r12
    1e15:	48 89 ee             	mov    rsi,rbp
    1e18:	bf 0b 00 00 00       	mov    edi,0xb
    1e1d:	e8 de 08 00 00       	call   2700 <__syscall2>
    1e22:	48 89 c7             	mov    rdi,rax
    1e25:	e8 66 12 00 00       	call   3090 <__syscall_ret>
}
    1e2a:	48 83 c4 08          	add    rsp,0x8
    1e2e:	5d                   	pop    rbp
    1e2f:	41 5c                	pop    r12
    1e31:	c3                   	ret    
    1e32:	66 2e 0f 1f 84 00 00 00 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
    1e3c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

0000000000001e40 <__syscall6>:

extern "C" long __syscall5(long n, long a1, long a2, long a3, long a4, long a5) {
	return __syscall6(n, a1, a2, a3, a4, a5, 0);
}

extern "C" long __syscall6(long n, long a1, long a2, long a3, long a4, long a5, long a6) {
    1e40:	55                   	push   rbp
    1e41:	48 89 fd             	mov    rbp,rdi
    1e44:	48 89 f7             	mov    rdi,rsi
    1e47:	48 89 d6             	mov    rsi,rdx
    1e4a:	48 89 ca             	mov    rdx,rcx
    1e4d:	4c 89 c1             	mov    rcx,r8
    1e50:	4d 89 c8             	mov    r8,r9
    1e53:	4c 8b 4c 24 10       	mov    r9,QWORD PTR [rsp+0x10]
    1e58:	48 81 fd b3 01 00 00 	cmp    rbp,0x1b3
    1e5f:	77 0f                	ja     1e70 <__syscall6+0x30>
    1e61:	ff 24 ed 70 80 00 00 	jmp    QWORD PTR [rbp*8+0x8070]
    1e68:	0f 1f 84 00 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
		case SYS_write:
			return ::perception::linux_syscalls::write();
		case SYS_writev:
			return ::perception::linux_syscalls::writev(a1, (struct iovec*)a2, a3);
		default:
			DebugPrinterSingleton << "Unknown syscall: " << (size_t)n << '\n';
    1e70:	be 5c 80 00 00       	mov    esi,0x805c
    1e75:	bf d8 d8 00 00       	mov    edi,0xd8d8
    1e7a:	e8 01 41 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
    1e7f:	48 89 ee             	mov    rsi,rbp
    1e82:	48 89 c7             	mov    rdi,rax
    1e85:	e8 16 40 00 00       	call   5ea0 <perception::DebugPrinter::operator<<(unsigned long)>
    1e8a:	be 0a 00 00 00       	mov    esi,0xa
    1e8f:	48 89 c7             	mov    rdi,rax
    1e92:	e8 f9 3f 00 00       	call   5e90 <perception::DebugPrinter::operator<<(char)>
			return 0;
	}
}
    1e97:	31 c0                	xor    eax,eax
    1e99:	5d                   	pop    rbp
    1e9a:	c3                   	ret    
    1e9b:	5d                   	pop    rbp
			return ::perception::linux_syscalls::clone3();
    1e9c:	e9 af 16 00 00       	jmp    3550 <perception::linux_syscalls::clone3()>
}
    1ea1:	5d                   	pop    rbp
			return ::perception::linux_syscalls::pidfd_open();
    1ea2:	e9 e9 2b 00 00       	jmp    4a90 <perception::linux_syscalls::pidfd_open()>
}
    1ea7:	5d                   	pop    rbp
			return ::perception::linux_syscalls::fspick();
    1ea8:	e9 23 1c 00 00       	jmp    3ad0 <perception::linux_syscalls::fspick()>
}
    1ead:	5d                   	pop    rbp
			return ::perception::linux_syscalls::fsmount();
    1eae:	e9 dd 1b 00 00       	jmp    3a90 <perception::linux_syscalls::fsmount()>
}
    1eb3:	5d                   	pop    rbp
			return ::perception::linux_syscalls::fsconfig();
    1eb4:	e9 97 1b 00 00       	jmp    3a50 <perception::linux_syscalls::fsconfig()>
}
    1eb9:	5d                   	pop    rbp
			return ::perception::linux_syscalls::fsopen();
    1eba:	e9 f1 1b 00 00       	jmp    3ab0 <perception::linux_syscalls::fsopen()>
}
    1ebf:	5d                   	pop    rbp
			return ::perception::linux_syscalls::move_mount();
    1ec0:	e9 2b 28 00 00       	jmp    46f0 <perception::linux_syscalls::move_mount()>
}
    1ec5:	5d                   	pop    rbp
			return ::perception::linux_syscalls::open_tree();
    1ec6:	e9 25 2b 00 00       	jmp    49f0 <perception::linux_syscalls::open_tree()>
}
    1ecb:	5d                   	pop    rbp
			return ::perception::linux_syscalls::io_uring_register();
    1ecc:	e9 4f 22 00 00       	jmp    4120 <perception::linux_syscalls::io_uring_register()>
}
    1ed1:	5d                   	pop    rbp
			return ::perception::linux_syscalls::io_uring_enter();
    1ed2:	e9 29 22 00 00       	jmp    4100 <perception::linux_syscalls::io_uring_enter()>
}
    1ed7:	5d                   	pop    rbp
			return ::perception::linux_syscalls::io_uring_setup();
    1ed8:	e9 63 22 00 00       	jmp    4140 <perception::linux_syscalls::io_uring_setup()>
}
    1edd:	5d                   	pop    rbp
			return ::perception::linux_syscalls::pidfd_send_signal();
    1ede:	e9 cd 2b 00 00       	jmp    4ab0 <perception::linux_syscalls::pidfd_send_signal()>
}
    1ee3:	5d                   	pop    rbp
			return ::perception::linux_syscalls::rseq();
    1ee4:	e9 e7 30 00 00       	jmp    4fd0 <perception::linux_syscalls::rseq()>
}
    1ee9:	5d                   	pop    rbp
			return ::perception::linux_syscalls::io_pgetevents();
    1eea:	e9 b1 21 00 00       	jmp    40a0 <perception::linux_syscalls::io_pgetevents()>
}
    1eef:	5d                   	pop    rbp
			return ::perception::linux_syscalls::statx();
    1ef0:	e9 6b 39 00 00       	jmp    5860 <perception::linux_syscalls::statx()>
}
    1ef5:	5d                   	pop    rbp
			return ::perception::linux_syscalls::pkey_free();
    1ef6:	e9 55 2c 00 00       	jmp    4b50 <perception::linux_syscalls::pkey_free()>
}
    1efb:	5d                   	pop    rbp
			return ::perception::linux_syscalls::pkey_alloc();
    1efc:	e9 2f 2c 00 00       	jmp    4b30 <perception::linux_syscalls::pkey_alloc()>
}
    1f01:	5d                   	pop    rbp
			return ::perception::linux_syscalls::pkey_mprotect();
    1f02:	e9 69 2c 00 00       	jmp    4b70 <perception::linux_syscalls::pkey_mprotect()>
}
    1f07:	5d                   	pop    rbp
			return ::perception::linux_syscalls::pwritev2();
    1f08:	e9 43 2e 00 00       	jmp    4d50 <perception::linux_syscalls::pwritev2()>
}
    1f0d:	5d                   	pop    rbp
			return ::perception::linux_syscalls::preadv2();
    1f0e:	e9 1d 2d 00 00       	jmp    4c30 <perception::linux_syscalls::preadv2()>
}
    1f13:	5d                   	pop    rbp
			return ::perception::linux_syscalls::copy_file_range();
    1f14:	e9 97 16 00 00       	jmp    35b0 <perception::linux_syscalls::copy_file_range()>
}
    1f19:	5d                   	pop    rbp
			return ::perception::linux_syscalls::mlock2();
    1f1a:	e9 b1 26 00 00       	jmp    45d0 <perception::linux_syscalls::mlock2()>
}
    1f1f:	5d                   	pop    rbp
			return ::perception::linux_syscalls::membarrier();
    1f20:	e9 8b 25 00 00       	jmp    44b0 <perception::linux_syscalls::membarrier()>
}
    1f25:	5d                   	pop    rbp
			return ::perception::linux_syscalls::userfaultfd();
    1f26:	e9 55 3d 00 00       	jmp    5c80 <perception::linux_syscalls::userfaultfd()>
}
    1f2b:	5d                   	pop    rbp
			return ::perception::linux_syscalls::execveat();
    1f2c:	e9 9f 18 00 00       	jmp    37d0 <perception::linux_syscalls::execveat()>
}
    1f31:	5d                   	pop    rbp
			return ::perception::linux_syscalls::bpf();
    1f32:	e9 69 14 00 00       	jmp    33a0 <perception::linux_syscalls::bpf()>
}
    1f37:	5d                   	pop    rbp
			return ::perception::linux_syscalls::kexec_file_load();
    1f38:	e9 33 23 00 00       	jmp    4270 <perception::linux_syscalls::kexec_file_load()>
}
    1f3d:	5d                   	pop    rbp
			return ::perception::linux_syscalls::memfd_create();
    1f3e:	e9 8d 25 00 00       	jmp    44d0 <perception::linux_syscalls::memfd_create()>
}
    1f43:	5d                   	pop    rbp
			return ::perception::linux_syscalls::getrandom();
    1f44:	e9 e7 1e 00 00       	jmp    3e30 <perception::linux_syscalls::getrandom()>
}
    1f49:	5d                   	pop    rbp
			return ::perception::linux_syscalls::seccomp();
    1f4a:	e9 21 33 00 00       	jmp    5270 <perception::linux_syscalls::seccomp()>
}
    1f4f:	5d                   	pop    rbp
			return ::perception::linux_syscalls::renameat2();
    1f50:	e9 fb 2f 00 00       	jmp    4f50 <perception::linux_syscalls::renameat2()>
}
    1f55:	5d                   	pop    rbp
			return ::perception::linux_syscalls::sched_getattr();
    1f56:	e9 f5 31 00 00       	jmp    5150 <perception::linux_syscalls::sched_getattr()>
}
    1f5b:	5d                   	pop    rbp
			return ::perception::linux_syscalls::sched_setattr();
    1f5c:	e9 8f 32 00 00       	jmp    51f0 <perception::linux_syscalls::sched_setattr()>
}
    1f61:	5d                   	pop    rbp
			return ::perception::linux_syscalls::finit_module();
    1f62:	e9 49 1a 00 00       	jmp    39b0 <perception::linux_syscalls::finit_module()>
}
    1f67:	5d                   	pop    rbp
			return ::perception::linux_syscalls::kcmp();
    1f68:	e9 e3 22 00 00       	jmp    4250 <perception::linux_syscalls::kcmp()>
}
    1f6d:	5d                   	pop    rbp
			return ::perception::linux_syscalls::process_vm_writev();
    1f6e:	e9 1d 2d 00 00       	jmp    4c90 <perception::linux_syscalls::process_vm_writev()>
}
    1f73:	5d                   	pop    rbp
			return ::perception::linux_syscalls::process_vm_readv();
    1f74:	e9 f7 2c 00 00       	jmp    4c70 <perception::linux_syscalls::process_vm_readv()>
}
    1f79:	5d                   	pop    rbp
			return ::perception::linux_syscalls::getcpu();
    1f7a:	e9 b1 1c 00 00       	jmp    3c30 <perception::linux_syscalls::getcpu()>
}
    1f7f:	5d                   	pop    rbp
			return ::perception::linux_syscalls::setns();
    1f80:	e9 9b 35 00 00       	jmp    5520 <perception::linux_syscalls::setns()>
}
    1f85:	5d                   	pop    rbp
			return ::perception::linux_syscalls::sendmmsg();
    1f86:	e9 e5 33 00 00       	jmp    5370 <perception::linux_syscalls::sendmmsg()>
}
    1f8b:	5d                   	pop    rbp
			return ::perception::linux_syscalls::syncfs();
    1f8c:	e9 af 39 00 00       	jmp    5940 <perception::linux_syscalls::syncfs()>
}
    1f91:	5d                   	pop    rbp
			return ::perception::linux_syscalls::clock_adjtime();
    1f92:	e9 f9 14 00 00       	jmp    3490 <perception::linux_syscalls::clock_adjtime()>
}
    1f97:	5d                   	pop    rbp
			return ::perception::linux_syscalls::open_by_handle_at();
    1f98:	e9 33 2a 00 00       	jmp    49d0 <perception::linux_syscalls::open_by_handle_at()>
}
    1f9d:	5d                   	pop    rbp
			return ::perception::linux_syscalls::name_to_handle_at();
    1f9e:	e9 8d 29 00 00       	jmp    4930 <perception::linux_syscalls::name_to_handle_at()>
}
    1fa3:	5d                   	pop    rbp
			return ::perception::linux_syscalls::prlimit64();
    1fa4:	e9 a7 2c 00 00       	jmp    4c50 <perception::linux_syscalls::prlimit64()>
}
    1fa9:	5d                   	pop    rbp
			return ::perception::linux_syscalls::fanotify_mark();
    1faa:	e9 e1 18 00 00       	jmp    3890 <perception::linux_syscalls::fanotify_mark()>
}
    1faf:	5d                   	pop    rbp
			return ::perception::linux_syscalls::fanotify_init();
    1fb0:	e9 bb 18 00 00       	jmp    3870 <perception::linux_syscalls::fanotify_init()>
}
    1fb5:	5d                   	pop    rbp
			return ::perception::linux_syscalls::recvmmsg();
    1fb6:	e9 d5 2e 00 00       	jmp    4e90 <perception::linux_syscalls::recvmmsg()>
}
    1fbb:	5d                   	pop    rbp
			return ::perception::linux_syscalls::perf_event_open();
    1fbc:	e9 8f 2a 00 00       	jmp    4a50 <perception::linux_syscalls::perf_event_open()>
}
    1fc1:	5d                   	pop    rbp
			return ::perception::linux_syscalls::rt_tgsigqueueinfo();
    1fc2:	e9 09 31 00 00       	jmp    50d0 <perception::linux_syscalls::rt_tgsigqueueinfo()>
}
    1fc7:	5d                   	pop    rbp
			return ::perception::linux_syscalls::pwritev();
    1fc8:	e9 63 2d 00 00       	jmp    4d30 <perception::linux_syscalls::pwritev()>
}
    1fcd:	5d                   	pop    rbp
			return ::perception::linux_syscalls::preadv();
    1fce:	e9 3d 2c 00 00       	jmp    4c10 <perception::linux_syscalls::preadv()>
}
    1fd3:	5d                   	pop    rbp
			return ::perception::linux_syscalls::inotify_init1();
    1fd4:	e9 27 20 00 00       	jmp    4000 <perception::linux_syscalls::inotify_init1()>
}
    1fd9:	5d                   	pop    rbp
			return ::perception::linux_syscalls::pipe2();
    1fda:	e9 11 2b 00 00       	jmp    4af0 <perception::linux_syscalls::pipe2()>
}
    1fdf:	5d                   	pop    rbp
			return ::perception::linux_syscalls::dup3();
    1fe0:	e9 8b 16 00 00       	jmp    3670 <perception::linux_syscalls::dup3()>
}
    1fe5:	5d                   	pop    rbp
			return ::perception::linux_syscalls::epoll_create1();
    1fe6:	e9 c5 16 00 00       	jmp    36b0 <perception::linux_syscalls::epoll_create1()>
}
    1feb:	5d                   	pop    rbp
			return ::perception::linux_syscalls::eventfd2();
    1fec:	e9 9f 17 00 00       	jmp    3790 <perception::linux_syscalls::eventfd2()>
}
    1ff1:	5d                   	pop    rbp
			return ::perception::linux_syscalls::signalfd4();
    1ff2:	e9 a9 37 00 00       	jmp    57a0 <perception::linux_syscalls::signalfd4()>
}
    1ff7:	5d                   	pop    rbp
			return ::perception::linux_syscalls::accept4();
    1ff8:	e9 83 12 00 00       	jmp    3280 <perception::linux_syscalls::accept4()>
}
    1ffd:	5d                   	pop    rbp
			return ::perception::linux_syscalls::timerfd_gettime();
    1ffe:	e9 dd 3a 00 00       	jmp    5ae0 <perception::linux_syscalls::timerfd_gettime()>
}
    2003:	5d                   	pop    rbp
			return ::perception::linux_syscalls::timerfd_settime();
    2004:	e9 f7 3a 00 00       	jmp    5b00 <perception::linux_syscalls::timerfd_settime()>
}
    2009:	5d                   	pop    rbp
			return ::perception::linux_syscalls::fallocate();
    200a:	e9 41 18 00 00       	jmp    3850 <perception::linux_syscalls::fallocate()>
}
    200f:	5d                   	pop    rbp
			return ::perception::linux_syscalls::eventfd();
    2010:	e9 5b 17 00 00       	jmp    3770 <perception::linux_syscalls::eventfd()>
}
    2015:	5d                   	pop    rbp
			return ::perception::linux_syscalls::timerfd_create();
    2016:	e9 a5 3a 00 00       	jmp    5ac0 <perception::linux_syscalls::timerfd_create()>
}
    201b:	5d                   	pop    rbp
			return ::perception::linux_syscalls::signalfd();
    201c:	e9 5f 37 00 00       	jmp    5780 <perception::linux_syscalls::signalfd()>
}
    2021:	5d                   	pop    rbp
			return ::perception::linux_syscalls::epoll_pwait();
    2022:	e9 e9 16 00 00       	jmp    3710 <perception::linux_syscalls::epoll_pwait()>
}
    2027:	5d                   	pop    rbp
			return ::perception::linux_syscalls::utimensat();
    2028:	e9 b3 3c 00 00       	jmp    5ce0 <perception::linux_syscalls::utimensat()>
}
    202d:	5d                   	pop    rbp
			return ::perception::linux_syscalls::move_pages();
    202e:	e9 dd 26 00 00       	jmp    4710 <perception::linux_syscalls::move_pages()>
}
    2033:	5d                   	pop    rbp
			return ::perception::linux_syscalls::vmsplice();
    2034:	e9 27 3d 00 00       	jmp    5d60 <perception::linux_syscalls::vmsplice()>
}
    2039:	5d                   	pop    rbp
			return ::perception::linux_syscalls::sync_file_range();
    203a:	e9 e1 38 00 00       	jmp    5920 <perception::linux_syscalls::sync_file_range()>
}
    203f:	5d                   	pop    rbp
			return ::perception::linux_syscalls::tee();
    2040:	e9 7b 39 00 00       	jmp    59c0 <perception::linux_syscalls::tee()>
}
    2045:	5d                   	pop    rbp
			return ::perception::linux_syscalls::splice();
    2046:	e9 b5 37 00 00       	jmp    5800 <perception::linux_syscalls::splice()>
}
    204b:	5d                   	pop    rbp
			return ::perception::linux_syscalls::get_robust_list();
    204c:	e9 9f 1b 00 00       	jmp    3bf0 <perception::linux_syscalls::get_robust_list()>
}
    2051:	5d                   	pop    rbp
			return ::perception::linux_syscalls::set_robust_list();
    2052:	e9 99 33 00 00       	jmp    53f0 <perception::linux_syscalls::set_robust_list()>
}
    2057:	5d                   	pop    rbp
			return ::perception::linux_syscalls::unshare();
    2058:	e9 e3 3b 00 00       	jmp    5c40 <perception::linux_syscalls::unshare()>
}
    205d:	5d                   	pop    rbp
			return ::perception::linux_syscalls::ppoll();
    205e:	e9 4d 2b 00 00       	jmp    4bb0 <perception::linux_syscalls::ppoll()>
}
    2063:	5d                   	pop    rbp
			return ::perception::linux_syscalls::pselect6();
    2064:	e9 47 2c 00 00       	jmp    4cb0 <perception::linux_syscalls::pselect6()>
}
    2069:	5d                   	pop    rbp
			return ::perception::linux_syscalls::faccessat();
    206a:	e9 a1 17 00 00       	jmp    3810 <perception::linux_syscalls::faccessat()>
}
    206f:	5d                   	pop    rbp
			return ::perception::linux_syscalls::fchmodat();
    2070:	e9 7b 18 00 00       	jmp    38f0 <perception::linux_syscalls::fchmodat()>
}
    2075:	5d                   	pop    rbp
			return ::perception::linux_syscalls::readlinkat();
    2076:	e9 95 2d 00 00       	jmp    4e10 <perception::linux_syscalls::readlinkat()>
}
    207b:	5d                   	pop    rbp
			return ::perception::linux_syscalls::symlinkat();
    207c:	e9 5f 38 00 00       	jmp    58e0 <perception::linux_syscalls::symlinkat()>
}
    2081:	5d                   	pop    rbp
			return ::perception::linux_syscalls::linkat();
    2082:	e9 c9 22 00 00       	jmp    4350 <perception::linux_syscalls::linkat()>
}
    2087:	5d                   	pop    rbp
			return ::perception::linux_syscalls::renameat();
    2088:	e9 a3 2e 00 00       	jmp    4f30 <perception::linux_syscalls::renameat()>
}
    208d:	5d                   	pop    rbp
			return ::perception::linux_syscalls::unlinkat();
    208e:	e9 8d 3b 00 00       	jmp    5c20 <perception::linux_syscalls::unlinkat()>
}
    2093:	5d                   	pop    rbp
			return ::perception::linux_syscalls::newfstatat();
    2094:	e9 d7 28 00 00       	jmp    4970 <perception::linux_syscalls::newfstatat()>
}
    2099:	5d                   	pop    rbp
			return ::perception::linux_syscalls::futimesat();
    209a:	e9 f1 1a 00 00       	jmp    3b90 <perception::linux_syscalls::futimesat()>
}
    209f:	5d                   	pop    rbp
			return ::perception::linux_syscalls::fchownat();
    20a0:	e9 8b 18 00 00       	jmp    3930 <perception::linux_syscalls::fchownat()>
}
    20a5:	5d                   	pop    rbp
			return ::perception::linux_syscalls::mknodat();
    20a6:	e9 e5 24 00 00       	jmp    4590 <perception::linux_syscalls::mknodat()>
}
    20ab:	5d                   	pop    rbp
			return ::perception::linux_syscalls::mkdirat();
    20ac:	e9 9f 24 00 00       	jmp    4550 <perception::linux_syscalls::mkdirat()>
}
    20b1:	5d                   	pop    rbp
			return ::perception::linux_syscalls::openat();
    20b2:	e9 59 29 00 00       	jmp    4a10 <perception::linux_syscalls::openat()>
}
    20b7:	5d                   	pop    rbp
			return ::perception::linux_syscalls::migrate_pages();
    20b8:	e9 33 24 00 00       	jmp    44f0 <perception::linux_syscalls::migrate_pages()>
}
    20bd:	5d                   	pop    rbp
			return ::perception::linux_syscalls::inotify_rm_watch();
    20be:	e9 5d 1f 00 00       	jmp    4020 <perception::linux_syscalls::inotify_rm_watch()>
}
    20c3:	5d                   	pop    rbp
			return ::perception::linux_syscalls::inotify_add_watch();
    20c4:	e9 f7 1e 00 00       	jmp    3fc0 <perception::linux_syscalls::inotify_add_watch()>
}
    20c9:	5d                   	pop    rbp
			return ::perception::linux_syscalls::inotify_init();
    20ca:	e9 11 1f 00 00       	jmp    3fe0 <perception::linux_syscalls::inotify_init()>
}
    20cf:	5d                   	pop    rbp
			return ::perception::linux_syscalls::ioprio_get();
    20d0:	e9 3b 21 00 00       	jmp    4210 <perception::linux_syscalls::ioprio_get()>
}
    20d5:	5d                   	pop    rbp
			return ::perception::linux_syscalls::ioprio_set();
    20d6:	e9 55 21 00 00       	jmp    4230 <perception::linux_syscalls::ioprio_set()>
}
    20db:	5d                   	pop    rbp
			return ::perception::linux_syscalls::keyctl();
    20dc:	e9 cf 21 00 00       	jmp    42b0 <perception::linux_syscalls::keyctl()>
}
    20e1:	5d                   	pop    rbp
			return ::perception::linux_syscalls::request_key();
    20e2:	e9 89 2e 00 00       	jmp    4f70 <perception::linux_syscalls::request_key()>
}
    20e7:	5d                   	pop    rbp
			return ::perception::linux_syscalls::add_key();
    20e8:	e9 f3 11 00 00       	jmp    32e0 <perception::linux_syscalls::add_key()>
}
    20ed:	5d                   	pop    rbp
			return ::perception::linux_syscalls::waitid();
    20ee:	e9 cd 3c 00 00       	jmp    5dc0 <perception::linux_syscalls::waitid()>
}
    20f3:	5d                   	pop    rbp
			return ::perception::linux_syscalls::kexec_load();
    20f4:	e9 97 21 00 00       	jmp    4290 <perception::linux_syscalls::kexec_load()>
}
    20f9:	5d                   	pop    rbp
			return ::perception::linux_syscalls::mq_getsetattr();
    20fa:	e9 51 26 00 00       	jmp    4750 <perception::linux_syscalls::mq_getsetattr()>
}
    20ff:	5d                   	pop    rbp
			return ::perception::linux_syscalls::mq_notify();
    2100:	e9 6b 26 00 00       	jmp    4770 <perception::linux_syscalls::mq_notify()>
}
    2105:	5d                   	pop    rbp
			return ::perception::linux_syscalls::mq_timedreceive();
    2106:	e9 a5 26 00 00       	jmp    47b0 <perception::linux_syscalls::mq_timedreceive()>
}
    210b:	5d                   	pop    rbp
			return ::perception::linux_syscalls::mq_timedsend();
    210c:	e9 bf 26 00 00       	jmp    47d0 <perception::linux_syscalls::mq_timedsend()>
}
    2111:	5d                   	pop    rbp
			return ::perception::linux_syscalls::mq_unlink();
    2112:	e9 d9 26 00 00       	jmp    47f0 <perception::linux_syscalls::mq_unlink()>
}
    2117:	5d                   	pop    rbp
			return ::perception::linux_syscalls::mq_open();
    2118:	e9 73 26 00 00       	jmp    4790 <perception::linux_syscalls::mq_open()>
}
    211d:	5d                   	pop    rbp
			return ::perception::linux_syscalls::get_mempolicy();
    211e:	e9 ad 1a 00 00       	jmp    3bd0 <perception::linux_syscalls::get_mempolicy()>
}
    2123:	5d                   	pop    rbp
			return ::perception::linux_syscalls::set_mempolicy();
    2124:	e9 a7 32 00 00       	jmp    53d0 <perception::linux_syscalls::set_mempolicy()>
}
    2129:	5d                   	pop    rbp
			return ::perception::linux_syscalls::mbind();
    212a:	e9 61 23 00 00       	jmp    4490 <perception::linux_syscalls::mbind()>
}
    212f:	5d                   	pop    rbp
			return ::perception::linux_syscalls::vserver();
    2130:	e9 4b 3c 00 00       	jmp    5d80 <perception::linux_syscalls::vserver()>
}
    2135:	5d                   	pop    rbp
			return ::perception::linux_syscalls::utimes();
    2136:	e9 c5 3b 00 00       	jmp    5d00 <perception::linux_syscalls::utimes()>
}
    213b:	5d                   	pop    rbp
			return ::perception::linux_syscalls::tgkill();
    213c:	e9 9f 38 00 00       	jmp    59e0 <perception::linux_syscalls::tgkill()>
}
    2141:	5d                   	pop    rbp
			return ::perception::linux_syscalls::epoll_ctl();
    2142:	e9 89 15 00 00       	jmp    36d0 <perception::linux_syscalls::epoll_ctl()>
}
    2147:	5d                   	pop    rbp
			return ::perception::linux_syscalls::epoll_wait();
    2148:	e9 e3 15 00 00       	jmp    3730 <perception::linux_syscalls::epoll_wait()>
}
    214d:	5d                   	pop    rbp
			return ::perception::linux_syscalls::exit_group();
    214e:	e9 ad 16 00 00       	jmp    3800 <perception::linux_syscalls::exit_group()>
}
    2153:	5d                   	pop    rbp
			return ::perception::linux_syscalls::clock_nanosleep();
    2154:	e9 97 13 00 00       	jmp    34f0 <perception::linux_syscalls::clock_nanosleep()>
}
    2159:	5d                   	pop    rbp
			return ::perception::linux_syscalls::clock_getres();
    215a:	e9 51 13 00 00       	jmp    34b0 <perception::linux_syscalls::clock_getres()>
}
    215f:	5d                   	pop    rbp
			return ::perception::linux_syscalls::clock_gettime();
    2160:	e9 6b 13 00 00       	jmp    34d0 <perception::linux_syscalls::clock_gettime()>
}
    2165:	5d                   	pop    rbp
			return ::perception::linux_syscalls::clock_settime();
    2166:	e9 a5 13 00 00       	jmp    3510 <perception::linux_syscalls::clock_settime()>
}
    216b:	5d                   	pop    rbp
			return ::perception::linux_syscalls::timer_delete();
    216c:	e9 cf 38 00 00       	jmp    5a40 <perception::linux_syscalls::timer_delete()>
}
    2171:	5d                   	pop    rbp
			return ::perception::linux_syscalls::timer_getoverrun();
    2172:	e9 e9 38 00 00       	jmp    5a60 <perception::linux_syscalls::timer_getoverrun()>
}
    2177:	5d                   	pop    rbp
			return ::perception::linux_syscalls::timer_gettime();
    2178:	e9 03 39 00 00       	jmp    5a80 <perception::linux_syscalls::timer_gettime()>
}
    217d:	5d                   	pop    rbp
			return ::perception::linux_syscalls::timer_settime();
    217e:	e9 1d 39 00 00       	jmp    5aa0 <perception::linux_syscalls::timer_settime()>
}
    2183:	5d                   	pop    rbp
			return ::perception::linux_syscalls::timer_create();
    2184:	e9 97 38 00 00       	jmp    5a20 <perception::linux_syscalls::timer_create()>
}
    2189:	5d                   	pop    rbp
			return ::perception::linux_syscalls::fadvise64();
    218a:	e9 a1 16 00 00       	jmp    3830 <perception::linux_syscalls::fadvise64()>
}
    218f:	5d                   	pop    rbp
			return ::perception::linux_syscalls::semtimedop();
    2190:	e9 9b 31 00 00       	jmp    5330 <perception::linux_syscalls::semtimedop()>
}
    2195:	5d                   	pop    rbp
			return ::perception::linux_syscalls::restart_syscall();
    2196:	e9 f5 2d 00 00       	jmp    4f90 <perception::linux_syscalls::restart_syscall()>
}
    219b:	5d                   	pop    rbp
			return ::perception::linux_syscalls::set_tid_address(a1);
    219c:	e9 7f 32 00 00       	jmp    5420 <perception::linux_syscalls::set_tid_address(long)>
}
    21a1:	5d                   	pop    rbp
			return ::perception::linux_syscalls::getdents64();
    21a2:	e9 e9 1a 00 00       	jmp    3c90 <perception::linux_syscalls::getdents64()>
}
    21a7:	5d                   	pop    rbp
			return ::perception::linux_syscalls::remap_file_pages();
    21a8:	e9 23 2d 00 00       	jmp    4ed0 <perception::linux_syscalls::remap_file_pages()>
}
    21ad:	5d                   	pop    rbp
			return ::perception::linux_syscalls::epoll_wait_old();
    21ae:	e9 9d 15 00 00       	jmp    3750 <perception::linux_syscalls::epoll_wait_old()>
}
    21b3:	5d                   	pop    rbp
			return ::perception::linux_syscalls::epoll_ctl_old();
    21b4:	e9 37 15 00 00       	jmp    36f0 <perception::linux_syscalls::epoll_ctl_old()>
}
    21b9:	5d                   	pop    rbp
			return ::perception::linux_syscalls::epoll_create();
    21ba:	e9 d1 14 00 00       	jmp    3690 <perception::linux_syscalls::epoll_create()>
}
    21bf:	5d                   	pop    rbp
			return ::perception::linux_syscalls::lookup_dcookie();
    21c0:	e9 0b 22 00 00       	jmp    43d0 <perception::linux_syscalls::lookup_dcookie()>
}
    21c5:	5d                   	pop    rbp
			return ::perception::linux_syscalls::get_thread_area();
    21c6:	e9 45 1a 00 00       	jmp    3c10 <perception::linux_syscalls::get_thread_area()>
}
    21cb:	5d                   	pop    rbp
			return ::perception::linux_syscalls::io_cancel();
    21cc:	e9 6f 1e 00 00       	jmp    4040 <perception::linux_syscalls::io_cancel()>
}
    21d1:	5d                   	pop    rbp
			return ::perception::linux_syscalls::io_submit();
    21d2:	e9 09 1f 00 00       	jmp    40e0 <perception::linux_syscalls::io_submit()>
}
    21d7:	5d                   	pop    rbp
			return ::perception::linux_syscalls::io_getevents();
    21d8:	e9 a3 1e 00 00       	jmp    4080 <perception::linux_syscalls::io_getevents()>
}
    21dd:	5d                   	pop    rbp
			return ::perception::linux_syscalls::io_destroy();
    21de:	e9 7d 1e 00 00       	jmp    4060 <perception::linux_syscalls::io_destroy()>
}
    21e3:	5d                   	pop    rbp
			return ::perception::linux_syscalls::io_setup();
    21e4:	e9 d7 1e 00 00       	jmp    40c0 <perception::linux_syscalls::io_setup()>
}
    21e9:	5d                   	pop    rbp
			return ::perception::linux_syscalls::set_thread_area(a1);
    21ea:	e9 21 32 00 00       	jmp    5410 <perception::linux_syscalls::set_thread_area(long)>
}
    21ef:	5d                   	pop    rbp
			return ::perception::linux_syscalls::sched_getaffinity();
    21f0:	e9 3b 2f 00 00       	jmp    5130 <perception::linux_syscalls::sched_getaffinity()>
}
    21f5:	5d                   	pop    rbp
			return ::perception::linux_syscalls::sched_setaffinity();
    21f6:	e9 d5 2f 00 00       	jmp    51d0 <perception::linux_syscalls::sched_setaffinity()>
}
    21fb:	5d                   	pop    rbp
			return ::perception::linux_syscalls::futex();
    21fc:	e9 6f 19 00 00       	jmp    3b70 <perception::linux_syscalls::futex()>
}
    2201:	5d                   	pop    rbp
			return ::perception::linux_syscalls::time();
    2202:	e9 f9 37 00 00       	jmp    5a00 <perception::linux_syscalls::time()>
}
    2207:	5d                   	pop    rbp
			return ::perception::linux_syscalls::tkill();
    2208:	e9 33 39 00 00       	jmp    5b40 <perception::linux_syscalls::tkill()>
}
    220d:	5d                   	pop    rbp
			return ::perception::linux_syscalls::fremovexattr();
    220e:	e9 1d 18 00 00       	jmp    3a30 <perception::linux_syscalls::fremovexattr()>
}
    2213:	5d                   	pop    rbp
			return ::perception::linux_syscalls::lremovexattr();
    2214:	e9 d7 21 00 00       	jmp    43f0 <perception::linux_syscalls::lremovexattr()>
}
    2219:	5d                   	pop    rbp
			return ::perception::linux_syscalls::removexattr();
    221a:	e9 d1 2c 00 00       	jmp    4ef0 <perception::linux_syscalls::removexattr()>
}
    221f:	5d                   	pop    rbp
			return ::perception::linux_syscalls::flistxattr();
    2220:	e9 ab 17 00 00       	jmp    39d0 <perception::linux_syscalls::flistxattr()>
}
    2225:	5d                   	pop    rbp
			return ::perception::linux_syscalls::llistxattr();
    2226:	e9 85 21 00 00       	jmp    43b0 <perception::linux_syscalls::llistxattr()>
}
    222b:	5d                   	pop    rbp
			return ::perception::linux_syscalls::listxattr();
    222c:	e9 5f 21 00 00       	jmp    4390 <perception::linux_syscalls::listxattr()>
}
    2231:	5d                   	pop    rbp
			return ::perception::linux_syscalls::fgetxattr();
    2232:	e9 59 17 00 00       	jmp    3990 <perception::linux_syscalls::fgetxattr()>
}
    2237:	5d                   	pop    rbp
			return ::perception::linux_syscalls::lgetxattr();
    2238:	e9 d3 20 00 00       	jmp    4310 <perception::linux_syscalls::lgetxattr()>
}
    223d:	5d                   	pop    rbp
			return ::perception::linux_syscalls::getxattr();
    223e:	e9 3d 1d 00 00       	jmp    3f80 <perception::linux_syscalls::getxattr()>
}
    2243:	5d                   	pop    rbp
			return ::perception::linux_syscalls::fsetxattr();
    2244:	e9 27 18 00 00       	jmp    3a70 <perception::linux_syscalls::fsetxattr()>
}
    2249:	5d                   	pop    rbp
			return ::perception::linux_syscalls::lsetxattr();
    224a:	e9 e1 21 00 00       	jmp    4430 <perception::linux_syscalls::lsetxattr()>
}
    224f:	5d                   	pop    rbp
			return ::perception::linux_syscalls::setxattr();
    2250:	e9 4b 34 00 00       	jmp    56a0 <perception::linux_syscalls::setxattr()>
}
    2255:	5d                   	pop    rbp
			return ::perception::linux_syscalls::readahead();
    2256:	e9 75 2b 00 00       	jmp    4dd0 <perception::linux_syscalls::readahead()>
}
    225b:	5d                   	pop    rbp
			return ::perception::linux_syscalls::gettid();
    225c:	e9 cf 1c 00 00       	jmp    3f30 <perception::linux_syscalls::gettid()>
}
    2261:	5d                   	pop    rbp
			return ::perception::linux_syscalls::security();
    2262:	e9 29 30 00 00       	jmp    5290 <perception::linux_syscalls::security()>
}
    2267:	5d                   	pop    rbp
			return ::perception::linux_syscalls::tuxcall();
    2268:	e9 13 39 00 00       	jmp    5b80 <perception::linux_syscalls::tuxcall()>
}
    226d:	5d                   	pop    rbp
			return ::perception::linux_syscalls::afs_syscall();
    226e:	e9 ad 10 00 00       	jmp    3320 <perception::linux_syscalls::afs_syscall()>
}
    2273:	5d                   	pop    rbp
			return ::perception::linux_syscalls::putpmsg();
    2274:	e9 77 2a 00 00       	jmp    4cf0 <perception::linux_syscalls::putpmsg()>
}
    2279:	5d                   	pop    rbp
			return ::perception::linux_syscalls::getpmsg();
    227a:	e9 51 1b 00 00       	jmp    3dd0 <perception::linux_syscalls::getpmsg()>
}
    227f:	5d                   	pop    rbp
			return ::perception::linux_syscalls::nfsservctl();
    2280:	e9 0b 27 00 00       	jmp    4990 <perception::linux_syscalls::nfsservctl()>
}
    2285:	5d                   	pop    rbp
			return ::perception::linux_syscalls::quotactl();
    2286:	e9 05 2b 00 00       	jmp    4d90 <perception::linux_syscalls::quotactl()>
}
    228b:	5d                   	pop    rbp
			return ::perception::linux_syscalls::query_module();
    228c:	e9 df 2a 00 00       	jmp    4d70 <perception::linux_syscalls::query_module()>
}
    2291:	5d                   	pop    rbp
			return ::perception::linux_syscalls::get_kernel_syms();
    2292:	e9 19 19 00 00       	jmp    3bb0 <perception::linux_syscalls::get_kernel_syms()>
}
    2297:	5d                   	pop    rbp
			return ::perception::linux_syscalls::delete_module();
    2298:	e9 73 13 00 00       	jmp    3610 <perception::linux_syscalls::delete_module()>
}
    229d:	5d                   	pop    rbp
			return ::perception::linux_syscalls::init_module();
    229e:	e9 fd 1c 00 00       	jmp    3fa0 <perception::linux_syscalls::init_module()>
}
    22a3:	5d                   	pop    rbp
			return ::perception::linux_syscalls::create_module();
    22a4:	e9 47 13 00 00       	jmp    35f0 <perception::linux_syscalls::create_module()>
}
    22a9:	5d                   	pop    rbp
			return ::perception::linux_syscalls::ioperm();
    22aa:	e9 21 1f 00 00       	jmp    41d0 <perception::linux_syscalls::ioperm()>
}
    22af:	5d                   	pop    rbp
			return ::perception::linux_syscalls::iopl();
    22b0:	e9 3b 1f 00 00       	jmp    41f0 <perception::linux_syscalls::iopl()>
}
    22b5:	5d                   	pop    rbp
			return ::perception::linux_syscalls::setdomainname();
    22b6:	e9 85 31 00 00       	jmp    5440 <perception::linux_syscalls::setdomainname()>
}
    22bb:	5d                   	pop    rbp
			return ::perception::linux_syscalls::sethostname();
    22bc:	e9 1f 32 00 00       	jmp    54e0 <perception::linux_syscalls::sethostname()>
}
    22c1:	5d                   	pop    rbp
			return ::perception::linux_syscalls::reboot();
    22c2:	e9 89 2b 00 00       	jmp    4e50 <perception::linux_syscalls::reboot()>
}
    22c7:	5d                   	pop    rbp
			return ::perception::linux_syscalls::swapoff();
    22c8:	e9 b3 35 00 00       	jmp    5880 <perception::linux_syscalls::swapoff()>
}
    22cd:	5d                   	pop    rbp
			return ::perception::linux_syscalls::swapon();
    22ce:	e9 cd 35 00 00       	jmp    58a0 <perception::linux_syscalls::swapon()>
}
    22d3:	5d                   	pop    rbp
			return ::perception::linux_syscalls::umount2();
    22d4:	e9 e7 38 00 00       	jmp    5bc0 <perception::linux_syscalls::umount2()>
}
    22d9:	5d                   	pop    rbp
			return ::perception::linux_syscalls::mount();
    22da:	e9 f1 23 00 00       	jmp    46d0 <perception::linux_syscalls::mount()>
}
    22df:	5d                   	pop    rbp
			return ::perception::linux_syscalls::settimeofday();
    22e0:	e9 7b 33 00 00       	jmp    5660 <perception::linux_syscalls::settimeofday()>
}
    22e5:	5d                   	pop    rbp
			return ::perception::linux_syscalls::acct();
    22e6:	e9 d5 0f 00 00       	jmp    32c0 <perception::linux_syscalls::acct()>
}
    22eb:	5d                   	pop    rbp
			return ::perception::linux_syscalls::sync();
    22ec:	e9 0f 36 00 00       	jmp    5900 <perception::linux_syscalls::sync()>
}
    22f1:	5d                   	pop    rbp
			return ::perception::linux_syscalls::chroot();
    22f2:	e9 79 11 00 00       	jmp    3470 <perception::linux_syscalls::chroot()>
}
    22f7:	5d                   	pop    rbp
			return ::perception::linux_syscalls::setrlimit();
    22f8:	e9 03 33 00 00       	jmp    5600 <perception::linux_syscalls::setrlimit()>
}
    22fd:	5d                   	pop    rbp
			return ::perception::linux_syscalls::adjtimex();
    22fe:	e9 fd 0f 00 00       	jmp    3300 <perception::linux_syscalls::adjtimex()>
}
    2303:	5d                   	pop    rbp
			return ::perception::linux_syscalls::arch_prctl();
    2304:	e9 57 10 00 00       	jmp    3360 <perception::linux_syscalls::arch_prctl()>
}
    2309:	5d                   	pop    rbp
			return ::perception::linux_syscalls::prctl();
    230a:	e9 c1 28 00 00       	jmp    4bd0 <perception::linux_syscalls::prctl()>
}
    230f:	5d                   	pop    rbp
			return ::perception::linux_syscalls::_sysctl();
    2310:	e9 2b 0f 00 00       	jmp    3240 <perception::linux_syscalls::_sysctl()>
}
    2315:	5d                   	pop    rbp
			return ::perception::linux_syscalls::pivot_root();
    2316:	e9 f5 27 00 00       	jmp    4b10 <perception::linux_syscalls::pivot_root()>
}
    231b:	5d                   	pop    rbp
			return ::perception::linux_syscalls::modify_ldt();
    231c:	e9 8f 23 00 00       	jmp    46b0 <perception::linux_syscalls::modify_ldt()>
}
    2321:	5d                   	pop    rbp
			return ::perception::linux_syscalls::vhangup();
    2322:	e9 19 3a 00 00       	jmp    5d40 <perception::linux_syscalls::vhangup()>
}
    2327:	5d                   	pop    rbp
			return ::perception::linux_syscalls::munlockall();
    2328:	e9 c3 25 00 00       	jmp    48f0 <perception::linux_syscalls::munlockall()>
}
    232d:	5d                   	pop    rbp
			return ::perception::linux_syscalls::mlockall();
    232e:	e9 bd 22 00 00       	jmp    45f0 <perception::linux_syscalls::mlockall()>
}
    2333:	5d                   	pop    rbp
			return ::perception::linux_syscalls::munlock();
    2334:	e9 97 25 00 00       	jmp    48d0 <perception::linux_syscalls::munlock()>
}
    2339:	5d                   	pop    rbp
			return ::perception::linux_syscalls::mlock();
    233a:	e9 71 22 00 00       	jmp    45b0 <perception::linux_syscalls::mlock()>
}
    233f:	5d                   	pop    rbp
			return ::perception::linux_syscalls::sched_rr_get_interval();
    2340:	e9 6b 2e 00 00       	jmp    51b0 <perception::linux_syscalls::sched_rr_get_interval()>
}
    2345:	5d                   	pop    rbp
			return ::perception::linux_syscalls::sched_get_priority_min();
    2346:	e9 c5 2d 00 00       	jmp    5110 <perception::linux_syscalls::sched_get_priority_min()>
}
    234b:	5d                   	pop    rbp
			return ::perception::linux_syscalls::sched_get_priority_max();
    234c:	e9 9f 2d 00 00       	jmp    50f0 <perception::linux_syscalls::sched_get_priority_max()>
}
    2351:	5d                   	pop    rbp
			return ::perception::linux_syscalls::sched_getscheduler();
    2352:	e9 39 2e 00 00       	jmp    5190 <perception::linux_syscalls::sched_getscheduler()>
}
    2357:	5d                   	pop    rbp
			return ::perception::linux_syscalls::sched_setscheduler();
    2358:	e9 d3 2e 00 00       	jmp    5230 <perception::linux_syscalls::sched_setscheduler()>
}
    235d:	5d                   	pop    rbp
			return ::perception::linux_syscalls::sched_getparam();
    235e:	e9 0d 2e 00 00       	jmp    5170 <perception::linux_syscalls::sched_getparam()>
}
    2363:	5d                   	pop    rbp
			return ::perception::linux_syscalls::sched_setparam();
    2364:	e9 a7 2e 00 00       	jmp    5210 <perception::linux_syscalls::sched_setparam()>
}
    2369:	5d                   	pop    rbp
			return ::perception::linux_syscalls::setpriority();
    236a:	e9 f1 31 00 00       	jmp    5560 <perception::linux_syscalls::setpriority()>
}
    236f:	5d                   	pop    rbp
			return ::perception::linux_syscalls::getpriority();
    2370:	e9 9b 1a 00 00       	jmp    3e10 <perception::linux_syscalls::getpriority()>
}
    2375:	5d                   	pop    rbp
			return ::perception::linux_syscalls::sysfs();
    2376:	e9 e5 35 00 00       	jmp    5960 <perception::linux_syscalls::sysfs()>
}
    237b:	5d                   	pop    rbp
			return ::perception::linux_syscalls::fstatfs();
    237c:	e9 8f 17 00 00       	jmp    3b10 <perception::linux_syscalls::fstatfs()>
}
    2381:	5d                   	pop    rbp
			return ::perception::linux_syscalls::statfs();
    2382:	e9 b9 34 00 00       	jmp    5840 <perception::linux_syscalls::statfs()>
}
    2387:	5d                   	pop    rbp
			return ::perception::linux_syscalls::ustat();
    2388:	e9 13 39 00 00       	jmp    5ca0 <perception::linux_syscalls::ustat()>
}
    238d:	5d                   	pop    rbp
			return ::perception::linux_syscalls::personality();
    238e:	e9 dd 26 00 00       	jmp    4a70 <perception::linux_syscalls::personality()>
}
    2393:	5d                   	pop    rbp
			return ::perception::linux_syscalls::uselib();
    2394:	e9 c7 38 00 00       	jmp    5c60 <perception::linux_syscalls::uselib()>
}
    2399:	5d                   	pop    rbp
			return ::perception::linux_syscalls::mknod();
    239a:	e9 d1 21 00 00       	jmp    4570 <perception::linux_syscalls::mknod()>
}
    239f:	5d                   	pop    rbp
			return ::perception::linux_syscalls::utime();
    23a0:	e9 1b 39 00 00       	jmp    5cc0 <perception::linux_syscalls::utime()>
}
    23a5:	5d                   	pop    rbp
			return ::perception::linux_syscalls::sigaltstack();
    23a6:	e9 b5 33 00 00       	jmp    5760 <perception::linux_syscalls::sigaltstack()>
}
    23ab:	5d                   	pop    rbp
			return ::perception::linux_syscalls::rt_sigsuspend();
    23ac:	e9 df 2c 00 00       	jmp    5090 <perception::linux_syscalls::rt_sigsuspend()>
}
    23b1:	5d                   	pop    rbp
			return ::perception::linux_syscalls::rt_sigqueueinfo();
    23b2:	e9 99 2c 00 00       	jmp    5050 <perception::linux_syscalls::rt_sigqueueinfo()>
}
    23b7:	5d                   	pop    rbp
			return ::perception::linux_syscalls::rt_sigtimedwait();
    23b8:	e9 f3 2c 00 00       	jmp    50b0 <perception::linux_syscalls::rt_sigtimedwait()>
}
    23bd:	5d                   	pop    rbp
			return ::perception::linux_syscalls::rt_sigpending();
    23be:	e9 4d 2c 00 00       	jmp    5010 <perception::linux_syscalls::rt_sigpending()>
}
    23c3:	5d                   	pop    rbp
			return ::perception::linux_syscalls::capset();
    23c4:	e9 27 10 00 00       	jmp    33f0 <perception::linux_syscalls::capset()>
}
    23c9:	5d                   	pop    rbp
			return ::perception::linux_syscalls::capget();
    23ca:	e9 01 10 00 00       	jmp    33d0 <perception::linux_syscalls::capget()>
}
    23cf:	5d                   	pop    rbp
			return ::perception::linux_syscalls::getsid();
    23d0:	e9 fb 1a 00 00       	jmp    3ed0 <perception::linux_syscalls::getsid()>
}
    23d5:	5d                   	pop    rbp
			return ::perception::linux_syscalls::setfsgid();
    23d6:	e9 85 30 00 00       	jmp    5460 <perception::linux_syscalls::setfsgid()>
}
    23db:	5d                   	pop    rbp
			return ::perception::linux_syscalls::setfsuid();
    23dc:	e9 9f 30 00 00       	jmp    5480 <perception::linux_syscalls::setfsuid()>
}
    23e1:	5d                   	pop    rbp
			return ::perception::linux_syscalls::getpgid();
    23e2:	e9 89 19 00 00       	jmp    3d70 <perception::linux_syscalls::getpgid()>
}
    23e7:	5d                   	pop    rbp
			return ::perception::linux_syscalls::getresgid();
    23e8:	e9 63 1a 00 00       	jmp    3e50 <perception::linux_syscalls::getresgid()>
}
    23ed:	5d                   	pop    rbp
			return ::perception::linux_syscalls::setresgid();
    23ee:	e9 ad 31 00 00       	jmp    55a0 <perception::linux_syscalls::setresgid()>
}
    23f3:	5d                   	pop    rbp
			return ::perception::linux_syscalls::getresuid();
    23f4:	e9 77 1a 00 00       	jmp    3e70 <perception::linux_syscalls::getresuid()>
}
    23f9:	5d                   	pop    rbp
			return ::perception::linux_syscalls::setresuid();
    23fa:	e9 c1 31 00 00       	jmp    55c0 <perception::linux_syscalls::setresuid()>
}
    23ff:	5d                   	pop    rbp
			return ::perception::linux_syscalls::setgroups();
    2400:	e9 bb 30 00 00       	jmp    54c0 <perception::linux_syscalls::setgroups()>
}
    2405:	5d                   	pop    rbp
			return ::perception::linux_syscalls::getgroups();
    2406:	e9 05 19 00 00       	jmp    3d10 <perception::linux_syscalls::getgroups()>
}
    240b:	5d                   	pop    rbp
			return ::perception::linux_syscalls::setregid();
    240c:	e9 6f 31 00 00       	jmp    5580 <perception::linux_syscalls::setregid()>
}
    2411:	5d                   	pop    rbp
			return ::perception::linux_syscalls::setreuid();
    2412:	e9 c9 31 00 00       	jmp    55e0 <perception::linux_syscalls::setreuid()>
}
    2417:	5d                   	pop    rbp
			return ::perception::linux_syscalls::setsid();
    2418:	e9 03 32 00 00       	jmp    5620 <perception::linux_syscalls::setsid()>
}
    241d:	5d                   	pop    rbp
			return ::perception::linux_syscalls::getpgrp();
    241e:	e9 6d 19 00 00       	jmp    3d90 <perception::linux_syscalls::getpgrp()>
}
    2423:	5d                   	pop    rbp
			return ::perception::linux_syscalls::getppid();
    2424:	e9 c7 19 00 00       	jmp    3df0 <perception::linux_syscalls::getppid()>
}
    2429:	5d                   	pop    rbp
			return ::perception::linux_syscalls::setpgid();
    242a:	e9 11 31 00 00       	jmp    5540 <perception::linux_syscalls::setpgid()>
}
    242f:	5d                   	pop    rbp
			return ::perception::linux_syscalls::getegid();
    2430:	e9 7b 18 00 00       	jmp    3cb0 <perception::linux_syscalls::getegid()>
}
    2435:	5d                   	pop    rbp
			return ::perception::linux_syscalls::geteuid();
    2436:	e9 95 18 00 00       	jmp    3cd0 <perception::linux_syscalls::geteuid()>
}
    243b:	5d                   	pop    rbp
			return ::perception::linux_syscalls::setgid();
    243c:	e9 5f 30 00 00       	jmp    54a0 <perception::linux_syscalls::setgid()>
}
    2441:	5d                   	pop    rbp
			return ::perception::linux_syscalls::setuid();
    2442:	e9 39 32 00 00       	jmp    5680 <perception::linux_syscalls::setuid()>
}
    2447:	5d                   	pop    rbp
			return ::perception::linux_syscalls::getgid();
    2448:	e9 a3 18 00 00       	jmp    3cf0 <perception::linux_syscalls::getgid()>
}
    244d:	5d                   	pop    rbp
			return ::perception::linux_syscalls::syslog();
    244e:	e9 4d 35 00 00       	jmp    59a0 <perception::linux_syscalls::syslog()>
}
    2453:	5d                   	pop    rbp
			return ::perception::linux_syscalls::getuid();
    2454:	e9 07 1b 00 00       	jmp    3f60 <perception::linux_syscalls::getuid()>
}
    2459:	5d                   	pop    rbp
			return ::perception::linux_syscalls::ptrace();
    245a:	e9 71 28 00 00       	jmp    4cd0 <perception::linux_syscalls::ptrace()>
}
    245f:	5d                   	pop    rbp
			return ::perception::linux_syscalls::times();
    2460:	e9 bb 36 00 00       	jmp    5b20 <perception::linux_syscalls::times()>
}
    2465:	5d                   	pop    rbp
			return ::perception::linux_syscalls::sysinfo();
    2466:	e9 15 35 00 00       	jmp    5980 <perception::linux_syscalls::sysinfo()>
}
    246b:	5d                   	pop    rbp
			return ::perception::linux_syscalls::getrusage();
    246c:	e9 3f 1a 00 00       	jmp    3eb0 <perception::linux_syscalls::getrusage()>
}
    2471:	5d                   	pop    rbp
			return ::perception::linux_syscalls::getrlimit();
    2472:	e9 19 1a 00 00       	jmp    3e90 <perception::linux_syscalls::getrlimit()>
}
    2477:	5d                   	pop    rbp
			return ::perception::linux_syscalls::gettimeofday();
    2478:	e9 c3 1a 00 00       	jmp    3f40 <perception::linux_syscalls::gettimeofday()>
}
    247d:	5d                   	pop    rbp
			return ::perception::linux_syscalls::umask();
    247e:	e9 1d 37 00 00       	jmp    5ba0 <perception::linux_syscalls::umask()>
}
    2483:	5d                   	pop    rbp
			return ::perception::linux_syscalls::lchown();
    2484:	e9 67 1e 00 00       	jmp    42f0 <perception::linux_syscalls::lchown()>
}
    2489:	5d                   	pop    rbp
			return ::perception::linux_syscalls::fchown();
    248a:	e9 81 14 00 00       	jmp    3910 <perception::linux_syscalls::fchown()>
}
    248f:	5d                   	pop    rbp
			return ::perception::linux_syscalls::chown();
    2490:	e9 bb 0f 00 00       	jmp    3450 <perception::linux_syscalls::chown()>
}
    2495:	5d                   	pop    rbp
			return ::perception::linux_syscalls::fchmod();
    2496:	e9 35 14 00 00       	jmp    38d0 <perception::linux_syscalls::fchmod()>
}
    249b:	5d                   	pop    rbp
			return ::perception::linux_syscalls::chmod();
    249c:	e9 8f 0f 00 00       	jmp    3430 <perception::linux_syscalls::chmod()>
}
    24a1:	5d                   	pop    rbp
			return ::perception::linux_syscalls::readlink();
    24a2:	e9 49 29 00 00       	jmp    4df0 <perception::linux_syscalls::readlink()>
}
    24a7:	5d                   	pop    rbp
			return ::perception::linux_syscalls::symlink();
    24a8:	e9 13 34 00 00       	jmp    58c0 <perception::linux_syscalls::symlink()>
}
    24ad:	5d                   	pop    rbp
			return ::perception::linux_syscalls::unlink();
    24ae:	e9 4d 37 00 00       	jmp    5c00 <perception::linux_syscalls::unlink()>
}
    24b3:	5d                   	pop    rbp
			return ::perception::linux_syscalls::link();
    24b4:	e9 77 1e 00 00       	jmp    4330 <perception::linux_syscalls::link()>
}
    24b9:	5d                   	pop    rbp
			return ::perception::linux_syscalls::creat();
    24ba:	e9 11 11 00 00       	jmp    35d0 <perception::linux_syscalls::creat()>
}
    24bf:	5d                   	pop    rbp
			return ::perception::linux_syscalls::rmdir();
    24c0:	e9 eb 2a 00 00       	jmp    4fb0 <perception::linux_syscalls::rmdir()>
}
    24c5:	5d                   	pop    rbp
			return ::perception::linux_syscalls::mkdir();
    24c6:	e9 65 20 00 00       	jmp    4530 <perception::linux_syscalls::mkdir()>
}
    24cb:	5d                   	pop    rbp
			return ::perception::linux_syscalls::rename();
    24cc:	e9 3f 2a 00 00       	jmp    4f10 <perception::linux_syscalls::rename()>
}
    24d1:	5d                   	pop    rbp
			return ::perception::linux_syscalls::fchdir();
    24d2:	e9 d9 13 00 00       	jmp    38b0 <perception::linux_syscalls::fchdir()>
}
    24d7:	5d                   	pop    rbp
			return ::perception::linux_syscalls::chdir();
    24d8:	e9 33 0f 00 00       	jmp    3410 <perception::linux_syscalls::chdir()>
}
    24dd:	5d                   	pop    rbp
			return ::perception::linux_syscalls::getcwd();
    24de:	e9 6d 17 00 00       	jmp    3c50 <perception::linux_syscalls::getcwd()>
}
    24e3:	5d                   	pop    rbp
			return ::perception::linux_syscalls::getdents();
    24e4:	e9 87 17 00 00       	jmp    3c70 <perception::linux_syscalls::getdents()>
}
    24e9:	5d                   	pop    rbp
			return ::perception::linux_syscalls::ftruncate();
    24ea:	e9 61 16 00 00       	jmp    3b50 <perception::linux_syscalls::ftruncate()>
}
    24ef:	5d                   	pop    rbp
			return ::perception::linux_syscalls::truncate();
    24f0:	e9 6b 36 00 00       	jmp    5b60 <perception::linux_syscalls::truncate()>
}
    24f5:	5d                   	pop    rbp
			return ::perception::linux_syscalls::fdatasync();
    24f6:	e9 75 14 00 00       	jmp    3970 <perception::linux_syscalls::fdatasync()>
}
    24fb:	5d                   	pop    rbp
			return ::perception::linux_syscalls::fsync();
    24fc:	e9 2f 16 00 00       	jmp    3b30 <perception::linux_syscalls::fsync()>
}
    2501:	5d                   	pop    rbp
			return ::perception::linux_syscalls::flock();
    2502:	e9 e9 14 00 00       	jmp    39f0 <perception::linux_syscalls::flock()>
}
    2507:	5d                   	pop    rbp
			return ::perception::linux_syscalls::fcntl();
    2508:	e9 43 14 00 00       	jmp    3950 <perception::linux_syscalls::fcntl()>
}
    250d:	5d                   	pop    rbp
			return ::perception::linux_syscalls::msgctl();
    250e:	e9 1d 23 00 00       	jmp    4830 <perception::linux_syscalls::msgctl()>
}
    2513:	5d                   	pop    rbp
			return ::perception::linux_syscalls::msgrcv();
    2514:	e9 57 23 00 00       	jmp    4870 <perception::linux_syscalls::msgrcv()>
}
    2519:	5d                   	pop    rbp
			return ::perception::linux_syscalls::msgsnd();
    251a:	e9 71 23 00 00       	jmp    4890 <perception::linux_syscalls::msgsnd()>
}
    251f:	5d                   	pop    rbp
			return ::perception::linux_syscalls::msgget();
    2520:	e9 2b 23 00 00       	jmp    4850 <perception::linux_syscalls::msgget()>
}
    2525:	5d                   	pop    rbp
			return ::perception::linux_syscalls::shmdt();
    2526:	e9 d5 31 00 00       	jmp    5700 <perception::linux_syscalls::shmdt()>
}
    252b:	5d                   	pop    rbp
			return ::perception::linux_syscalls::semctl();
    252c:	e9 9f 2d 00 00       	jmp    52d0 <perception::linux_syscalls::semctl()>
}
    2531:	5d                   	pop    rbp
			return ::perception::linux_syscalls::semop();
    2532:	e9 d9 2d 00 00       	jmp    5310 <perception::linux_syscalls::semop()>
}
    2537:	5d                   	pop    rbp
			return ::perception::linux_syscalls::semget();
    2538:	e9 b3 2d 00 00       	jmp    52f0 <perception::linux_syscalls::semget()>
}
    253d:	5d                   	pop    rbp
			return ::perception::linux_syscalls::uname();
    253e:	e9 9d 36 00 00       	jmp    5be0 <perception::linux_syscalls::uname()>
}
    2543:	5d                   	pop    rbp
			return ::perception::linux_syscalls::kill();
    2544:	e9 87 1d 00 00       	jmp    42d0 <perception::linux_syscalls::kill()>
}
    2549:	5d                   	pop    rbp
			return ::perception::linux_syscalls::wait4();
    254a:	e9 51 38 00 00       	jmp    5da0 <perception::linux_syscalls::wait4()>
}
    254f:	5d                   	pop    rbp
			return ::perception::linux_syscalls::exit();
    2550:	e9 9b 12 00 00       	jmp    37f0 <perception::linux_syscalls::exit()>
}
    2555:	5d                   	pop    rbp
			return ::perception::linux_syscalls::execve();
    2556:	e9 55 12 00 00       	jmp    37b0 <perception::linux_syscalls::execve()>
}
    255b:	5d                   	pop    rbp
			return ::perception::linux_syscalls::vfork();
    255c:	e9 bf 37 00 00       	jmp    5d20 <perception::linux_syscalls::vfork()>
}
    2561:	5d                   	pop    rbp
			return ::perception::linux_syscalls::fork();
    2562:	e9 a9 14 00 00       	jmp    3a10 <perception::linux_syscalls::fork()>
}
    2567:	5d                   	pop    rbp
			return ::perception::linux_syscalls::clone();
    2568:	e9 c3 0f 00 00       	jmp    3530 <perception::linux_syscalls::clone()>
}
    256d:	5d                   	pop    rbp
			return ::perception::linux_syscalls::getsockopt();
    256e:	e9 9d 19 00 00       	jmp    3f10 <perception::linux_syscalls::getsockopt()>
}
    2573:	5d                   	pop    rbp
			return ::perception::linux_syscalls::setsockopt();
    2574:	e9 c7 30 00 00       	jmp    5640 <perception::linux_syscalls::setsockopt()>
}
    2579:	5d                   	pop    rbp
			return ::perception::linux_syscalls::socketpair();
    257a:	e9 61 32 00 00       	jmp    57e0 <perception::linux_syscalls::socketpair()>
}
    257f:	5d                   	pop    rbp
			return ::perception::linux_syscalls::getpeername();
    2580:	e9 cb 17 00 00       	jmp    3d50 <perception::linux_syscalls::getpeername()>
}
    2585:	5d                   	pop    rbp
			return ::perception::linux_syscalls::getsockname();
    2586:	e9 65 19 00 00       	jmp    3ef0 <perception::linux_syscalls::getsockname()>
}
    258b:	5d                   	pop    rbp
			return ::perception::linux_syscalls::listen();
    258c:	e9 df 1d 00 00       	jmp    4370 <perception::linux_syscalls::listen()>
}
    2591:	5d                   	pop    rbp
			return ::perception::linux_syscalls::bind();
    2592:	e9 e9 0d 00 00       	jmp    3380 <perception::linux_syscalls::bind()>
}
    2597:	5d                   	pop    rbp
			return ::perception::linux_syscalls::shutdown();
    2598:	e9 a3 31 00 00       	jmp    5740 <perception::linux_syscalls::shutdown()>
}
    259d:	5d                   	pop    rbp
			return ::perception::linux_syscalls::recvmsg();
    259e:	e9 0d 29 00 00       	jmp    4eb0 <perception::linux_syscalls::recvmsg()>
}
    25a3:	5d                   	pop    rbp
			return ::perception::linux_syscalls::sendmsg();
    25a4:	e9 e7 2d 00 00       	jmp    5390 <perception::linux_syscalls::sendmsg()>
}
    25a9:	5d                   	pop    rbp
			return ::perception::linux_syscalls::recvfrom();
    25aa:	e9 c1 28 00 00       	jmp    4e70 <perception::linux_syscalls::recvfrom()>
}
    25af:	5d                   	pop    rbp
			return ::perception::linux_syscalls::sendto();
    25b0:	e9 fb 2d 00 00       	jmp    53b0 <perception::linux_syscalls::sendto()>
}
    25b5:	5d                   	pop    rbp
			return ::perception::linux_syscalls::accept();
    25b6:	e9 a5 0c 00 00       	jmp    3260 <perception::linux_syscalls::accept()>
}
    25bb:	5d                   	pop    rbp
			return ::perception::linux_syscalls::connect();
    25bc:	e9 cf 0f 00 00       	jmp    3590 <perception::linux_syscalls::connect()>
}
    25c1:	5d                   	pop    rbp
			return ::perception::linux_syscalls::socket();
    25c2:	e9 f9 31 00 00       	jmp    57c0 <perception::linux_syscalls::socket()>
}
    25c7:	5d                   	pop    rbp
			return ::perception::linux_syscalls::sendfile();
    25c8:	e9 83 2d 00 00       	jmp    5350 <perception::linux_syscalls::sendfile()>
}
    25cd:	5d                   	pop    rbp
			return ::perception::linux_syscalls::getpid();
    25ce:	e9 dd 17 00 00       	jmp    3db0 <perception::linux_syscalls::getpid()>
}
    25d3:	5d                   	pop    rbp
			return ::perception::linux_syscalls::setitimer();
    25d4:	e9 27 2f 00 00       	jmp    5500 <perception::linux_syscalls::setitimer()>
}
    25d9:	5d                   	pop    rbp
			return ::perception::linux_syscalls::alarm();
    25da:	e9 61 0d 00 00       	jmp    3340 <perception::linux_syscalls::alarm()>
}
    25df:	5d                   	pop    rbp
			return ::perception::linux_syscalls::getitimer();
    25e0:	e9 4b 17 00 00       	jmp    3d30 <perception::linux_syscalls::getitimer()>
}
    25e5:	5d                   	pop    rbp
			return ::perception::linux_syscalls::nanosleep();
    25e6:	e9 65 23 00 00       	jmp    4950 <perception::linux_syscalls::nanosleep()>
}
    25eb:	5d                   	pop    rbp
			return ::perception::linux_syscalls::pause();
    25ec:	e9 3f 24 00 00       	jmp    4a30 <perception::linux_syscalls::pause()>
}
    25f1:	5d                   	pop    rbp
			return ::perception::linux_syscalls::dup2();
    25f2:	e9 59 10 00 00       	jmp    3650 <perception::linux_syscalls::dup2()>
}
    25f7:	5d                   	pop    rbp
			return ::perception::linux_syscalls::dup();
    25f8:	e9 33 10 00 00       	jmp    3630 <perception::linux_syscalls::dup()>
}
    25fd:	5d                   	pop    rbp
			return ::perception::linux_syscalls::shmctl();
    25fe:	e9 dd 30 00 00       	jmp    56e0 <perception::linux_syscalls::shmctl()>
}
    2603:	5d                   	pop    rbp
			return ::perception::linux_syscalls::shmat();
    2604:	e9 b7 30 00 00       	jmp    56c0 <perception::linux_syscalls::shmat()>
}
    2609:	5d                   	pop    rbp
			return ::perception::linux_syscalls::shmget();
    260a:	e9 11 31 00 00       	jmp    5720 <perception::linux_syscalls::shmget()>
}
    260f:	5d                   	pop    rbp
			return ::perception::linux_syscalls::madvise();
    2610:	e9 5b 1e 00 00       	jmp    4470 <perception::linux_syscalls::madvise()>
}
    2615:	5d                   	pop    rbp
			return ::perception::linux_syscalls::mincore();
    2616:	e9 f5 1e 00 00       	jmp    4510 <perception::linux_syscalls::mincore()>
}
    261b:	5d                   	pop    rbp
			return ::perception::linux_syscalls::msync();
    261c:	e9 8f 22 00 00       	jmp    48b0 <perception::linux_syscalls::msync()>
}
    2621:	5d                   	pop    rbp
			return ::perception::linux_syscalls::mremap();
    2622:	e9 e9 21 00 00       	jmp    4810 <perception::linux_syscalls::mremap()>
}
    2627:	5d                   	pop    rbp
			return ::perception::linux_syscalls::sched_yield();
    2628:	e9 23 2c 00 00       	jmp    5250 <perception::linux_syscalls::sched_yield()>
}
    262d:	5d                   	pop    rbp
			return ::perception::linux_syscalls::select();
    262e:	e9 7d 2c 00 00       	jmp    52b0 <perception::linux_syscalls::select()>
}
    2633:	5d                   	pop    rbp
			return ::perception::linux_syscalls::pipe();
    2634:	e9 97 24 00 00       	jmp    4ad0 <perception::linux_syscalls::pipe()>
}
    2639:	5d                   	pop    rbp
			return ::perception::linux_syscalls::access();
    263a:	e9 61 0c 00 00       	jmp    32a0 <perception::linux_syscalls::access()>
}
    263f:	5d                   	pop    rbp
			return ::perception::linux_syscalls::writev(a1, (struct iovec*)a2, a3);
    2640:	e9 bb 37 00 00       	jmp    5e00 <perception::linux_syscalls::writev(long, iovec*, long)>
}
    2645:	5d                   	pop    rbp
			return ::perception::linux_syscalls::readv();
    2646:	e9 e5 27 00 00       	jmp    4e30 <perception::linux_syscalls::readv()>
}
    264b:	5d                   	pop    rbp
			return ::perception::linux_syscalls::pwrite64();
    264c:	e9 bf 26 00 00       	jmp    4d10 <perception::linux_syscalls::pwrite64()>
}
    2651:	5d                   	pop    rbp
			return ::perception::linux_syscalls::pread64();
    2652:	e9 99 25 00 00       	jmp    4bf0 <perception::linux_syscalls::pread64()>
}
    2657:	5d                   	pop    rbp
			return ::perception::linux_syscalls::ioctl(a1, a2, a3);
    2658:	e9 03 1b 00 00       	jmp    4160 <perception::linux_syscalls::ioctl(long, long, long)>
}
    265d:	5d                   	pop    rbp
			return ::perception::linux_syscalls::rt_sigreturn();
    265e:	e9 0d 2a 00 00       	jmp    5070 <perception::linux_syscalls::rt_sigreturn()>
}
    2663:	5d                   	pop    rbp
			return ::perception::linux_syscalls::rt_sigprocmask();
    2664:	e9 c7 29 00 00       	jmp    5030 <perception::linux_syscalls::rt_sigprocmask()>
}
    2669:	5d                   	pop    rbp
			return ::perception::linux_syscalls::rt_sigaction();
    266a:	e9 81 29 00 00       	jmp    4ff0 <perception::linux_syscalls::rt_sigaction()>
}
    266f:	5d                   	pop    rbp
			return ::perception::linux_syscalls::brk();
    2670:	e9 4b 0d 00 00       	jmp    33c0 <perception::linux_syscalls::brk()>
}
    2675:	5d                   	pop    rbp
			return ::perception::linux_syscalls::munmap(a1, a2);
    2676:	e9 95 22 00 00       	jmp    4910 <perception::linux_syscalls::munmap(long, long)>
}
    267b:	5d                   	pop    rbp
			return ::perception::linux_syscalls::mprotect();
    267c:	e9 af 20 00 00       	jmp    4730 <perception::linux_syscalls::mprotect()>
}
    2681:	5d                   	pop    rbp
			return ::perception::linux_syscalls::mmap(a1, a2, a3, a4, a5, a6);
    2682:	e9 89 1f 00 00       	jmp    4610 <perception::linux_syscalls::mmap(long, long, long, long, long, long)>
}
    2687:	5d                   	pop    rbp
			return ::perception::linux_syscalls::lseek();
    2688:	e9 83 1d 00 00       	jmp    4410 <perception::linux_syscalls::lseek()>
}
    268d:	5d                   	pop    rbp
			return ::perception::linux_syscalls::poll();
    268e:	e9 fd 24 00 00       	jmp    4b90 <perception::linux_syscalls::poll()>
}
    2693:	5d                   	pop    rbp
			return ::perception::linux_syscalls::lstat();
    2694:	e9 b7 1d 00 00       	jmp    4450 <perception::linux_syscalls::lstat()>
}
    2699:	5d                   	pop    rbp
			return ::perception::linux_syscalls::fstat();
    269a:	e9 51 14 00 00       	jmp    3af0 <perception::linux_syscalls::fstat()>
}
    269f:	5d                   	pop    rbp
			return ::perception::linux_syscalls::stat();
    26a0:	e9 7b 31 00 00       	jmp    5820 <perception::linux_syscalls::stat()>
}
    26a5:	5d                   	pop    rbp
			return ::perception::linux_syscalls::close();
    26a6:	e9 c5 0e 00 00       	jmp    3570 <perception::linux_syscalls::close()>
}
    26ab:	5d                   	pop    rbp
			return ::perception::linux_syscalls::open();
    26ac:	e9 ff 22 00 00       	jmp    49b0 <perception::linux_syscalls::open()>
}
    26b1:	5d                   	pop    rbp
			return ::perception::linux_syscalls::write();
    26b2:	e9 29 37 00 00       	jmp    5de0 <perception::linux_syscalls::write()>
}
    26b7:	5d                   	pop    rbp
			return ::perception::linux_syscalls::read();
    26b8:	e9 f3 26 00 00       	jmp    4db0 <perception::linux_syscalls::read()>
    26bd:	0f 1f 00             	nop    DWORD PTR [rax]

00000000000026c0 <__syscall0>:
extern "C" long __syscall0(long n) {
    26c0:	48 83 ec 10          	sub    rsp,0x10
	return __syscall6(n, 0, 0, 0, 0, 0, 0);
    26c4:	45 31 c9             	xor    r9d,r9d
    26c7:	45 31 c0             	xor    r8d,r8d
    26ca:	31 c9                	xor    ecx,ecx
    26cc:	6a 00                	push   0x0
    26ce:	31 d2                	xor    edx,edx
    26d0:	31 f6                	xor    esi,esi
    26d2:	e8 69 f7 ff ff       	call   1e40 <__syscall6>
}
    26d7:	48 83 c4 18          	add    rsp,0x18
    26db:	c3                   	ret    
    26dc:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

00000000000026e0 <__syscall1>:
extern "C" long __syscall1(long n, long a1) {
    26e0:	48 83 ec 10          	sub    rsp,0x10
	return __syscall6(n, a1, 0, 0, 0, 0, 0);
    26e4:	45 31 c9             	xor    r9d,r9d
    26e7:	45 31 c0             	xor    r8d,r8d
    26ea:	31 c9                	xor    ecx,ecx
    26ec:	6a 00                	push   0x0
    26ee:	31 d2                	xor    edx,edx
    26f0:	e8 4b f7 ff ff       	call   1e40 <__syscall6>
}
    26f5:	48 83 c4 18          	add    rsp,0x18
    26f9:	c3                   	ret    
    26fa:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000002700 <__syscall2>:
extern "C" long __syscall2(long n, long a1, long a2) {
    2700:	48 83 ec 10          	sub    rsp,0x10
	return __syscall6(n, a1, a2, 0, 0, 0, 0);
    2704:	45 31 c9             	xor    r9d,r9d
    2707:	45 31 c0             	xor    r8d,r8d
    270a:	31 c9                	xor    ecx,ecx
    270c:	6a 00                	push   0x0
    270e:	e8 2d f7 ff ff       	call   1e40 <__syscall6>
}
    2713:	48 83 c4 18          	add    rsp,0x18
    2717:	c3                   	ret    
    2718:	0f 1f 84 00 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]

0000000000002720 <__syscall3>:
extern "C" long __syscall3(long n, long a1, long a2, long a3) {
    2720:	48 83 ec 10          	sub    rsp,0x10
	return __syscall6(n, a1, a2, a3, 0, 0, 0);
    2724:	45 31 c9             	xor    r9d,r9d
    2727:	45 31 c0             	xor    r8d,r8d
    272a:	6a 00                	push   0x0
    272c:	e8 0f f7 ff ff       	call   1e40 <__syscall6>
}
    2731:	48 83 c4 18          	add    rsp,0x18
    2735:	c3                   	ret    
    2736:	66 2e 0f 1f 84 00 00 00 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]

0000000000002740 <__syscall4>:
extern "C" long __syscall4(long n, long a1, long a2, long a3, long a4) {
    2740:	48 83 ec 10          	sub    rsp,0x10
	return __syscall6(n, a1, a2, a3, a4, 0, 0);
    2744:	45 31 c9             	xor    r9d,r9d
    2747:	6a 00                	push   0x0
    2749:	e8 f2 f6 ff ff       	call   1e40 <__syscall6>
}
    274e:	48 83 c4 18          	add    rsp,0x18
    2752:	c3                   	ret    
    2753:	66 66 2e 0f 1f 84 00 00 00 00 00 	data16 nop WORD PTR cs:[rax+rax*1+0x0]
    275e:	66 90                	xchg   ax,ax

0000000000002760 <__syscall5>:
extern "C" long __syscall5(long n, long a1, long a2, long a3, long a4, long a5) {
    2760:	48 83 ec 10          	sub    rsp,0x10
	return __syscall6(n, a1, a2, a3, a4, a5, 0);
    2764:	6a 00                	push   0x0
    2766:	e8 d5 f6 ff ff       	call   1e40 <__syscall6>
}
    276b:	48 83 c4 18          	add    rsp,0x18
    276f:	c3                   	ret    

0000000000002770 <memcpy>:
    2770:	48 89 f8             	mov    rax,rdi
    2773:	48 83 fa 08          	cmp    rdx,0x8
    2777:	72 14                	jb     278d <memcpy+0x1d>
    2779:	f7 c7 07 00 00 00    	test   edi,0x7
    277f:	74 0c                	je     278d <memcpy+0x1d>
    2781:	a4                   	movs   BYTE PTR es:[rdi],BYTE PTR ds:[rsi]
    2782:	48 ff ca             	dec    rdx
    2785:	f7 c7 07 00 00 00    	test   edi,0x7
    278b:	75 f4                	jne    2781 <memcpy+0x11>
    278d:	48 89 d1             	mov    rcx,rdx
    2790:	48 c1 e9 03          	shr    rcx,0x3
    2794:	f3 48 a5             	rep movs QWORD PTR es:[rdi],QWORD PTR ds:[rsi]
    2797:	83 e2 07             	and    edx,0x7
    279a:	74 05                	je     27a1 <memcpy+0x31>
    279c:	a4                   	movs   BYTE PTR es:[rdi],BYTE PTR ds:[rsi]
    279d:	ff ca                	dec    edx
    279f:	75 fb                	jne    279c <memcpy+0x2c>
    27a1:	c3                   	ret    

00000000000027a2 <memset>:
    27a2:	48 0f b6 c6          	movzx  rax,sil
    27a6:	49 b8 01 01 01 01 01 01 01 01 	movabs r8,0x101010101010101
    27b0:	49 0f af c0          	imul   rax,r8
    27b4:	48 83 fa 7e          	cmp    rdx,0x7e
    27b8:	77 78                	ja     2832 <memset+0x90>
    27ba:	85 d2                	test   edx,edx
    27bc:	74 70                	je     282e <memset+0x8c>
    27be:	40 88 37             	mov    BYTE PTR [rdi],sil
    27c1:	40 88 74 17 ff       	mov    BYTE PTR [rdi+rdx*1-0x1],sil
    27c6:	83 fa 02             	cmp    edx,0x2
    27c9:	76 63                	jbe    282e <memset+0x8c>
    27cb:	66 89 47 01          	mov    WORD PTR [rdi+0x1],ax
    27cf:	66 89 44 17 fd       	mov    WORD PTR [rdi+rdx*1-0x3],ax
    27d4:	83 fa 06             	cmp    edx,0x6
    27d7:	76 55                	jbe    282e <memset+0x8c>
    27d9:	89 47 03             	mov    DWORD PTR [rdi+0x3],eax
    27dc:	89 44 17 f9          	mov    DWORD PTR [rdi+rdx*1-0x7],eax
    27e0:	83 fa 0e             	cmp    edx,0xe
    27e3:	76 49                	jbe    282e <memset+0x8c>
    27e5:	48 89 47 07          	mov    QWORD PTR [rdi+0x7],rax
    27e9:	48 89 44 17 f1       	mov    QWORD PTR [rdi+rdx*1-0xf],rax
    27ee:	83 fa 1e             	cmp    edx,0x1e
    27f1:	76 3b                	jbe    282e <memset+0x8c>
    27f3:	48 89 47 0f          	mov    QWORD PTR [rdi+0xf],rax
    27f7:	48 89 47 17          	mov    QWORD PTR [rdi+0x17],rax
    27fb:	48 89 44 17 e1       	mov    QWORD PTR [rdi+rdx*1-0x1f],rax
    2800:	48 89 44 17 e9       	mov    QWORD PTR [rdi+rdx*1-0x17],rax
    2805:	83 fa 3e             	cmp    edx,0x3e
    2808:	76 24                	jbe    282e <memset+0x8c>
    280a:	48 89 47 1f          	mov    QWORD PTR [rdi+0x1f],rax
    280e:	48 89 47 27          	mov    QWORD PTR [rdi+0x27],rax
    2812:	48 89 47 2f          	mov    QWORD PTR [rdi+0x2f],rax
    2816:	48 89 47 37          	mov    QWORD PTR [rdi+0x37],rax
    281a:	48 89 44 17 c1       	mov    QWORD PTR [rdi+rdx*1-0x3f],rax
    281f:	48 89 44 17 c9       	mov    QWORD PTR [rdi+rdx*1-0x37],rax
    2824:	48 89 44 17 d1       	mov    QWORD PTR [rdi+rdx*1-0x2f],rax
    2829:	48 89 44 17 d9       	mov    QWORD PTR [rdi+rdx*1-0x27],rax
    282e:	48 89 f8             	mov    rax,rdi
    2831:	c3                   	ret    
    2832:	f7 c7 0f 00 00 00    	test   edi,0xf
    2838:	49 89 f8             	mov    r8,rdi
    283b:	48 89 44 17 f8       	mov    QWORD PTR [rdi+rdx*1-0x8],rax
    2840:	48 89 d1             	mov    rcx,rdx
    2843:	75 0b                	jne    2850 <memset+0xae>
    2845:	48 c1 e9 03          	shr    rcx,0x3
    2849:	f3 48 ab             	rep stos QWORD PTR es:[rdi],rax
    284c:	4c 89 c0             	mov    rax,r8
    284f:	c3                   	ret    
    2850:	31 d2                	xor    edx,edx
    2852:	29 fa                	sub    edx,edi
    2854:	83 e2 0f             	and    edx,0xf
    2857:	48 89 07             	mov    QWORD PTR [rdi],rax
    285a:	48 89 47 08          	mov    QWORD PTR [rdi+0x8],rax
    285e:	48 29 d1             	sub    rcx,rdx
    2861:	48 01 d7             	add    rdi,rdx
    2864:	eb df                	jmp    2845 <memset+0xa3>
    2866:	66 2e 0f 1f 84 00 00 00 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]

0000000000002870 <__lock>:
 * with INT_MIN as a lock flag.
 */

void __lock(volatile int *l)
{
	if (!libc.threads_minus_1) return;
    2870:	8b 05 b6 a7 00 00    	mov    eax,DWORD PTR [rip+0xa7b6]        # d02c <__libc+0xc>
    2876:	85 c0                	test   eax,eax
    2878:	0f 84 c2 01 00 00    	je     2a40 <__lock+0x1d0>
{
    287e:	41 54                	push   r12
	__asm__ __volatile__ (
    2880:	31 c0                	xor    eax,eax
    2882:	ba 01 00 00 80       	mov    edx,0x80000001
    2887:	55                   	push   rbp
    2888:	48 89 fd             	mov    rbp,rdi
    288b:	53                   	push   rbx
    288c:	f0 0f b1 17          	lock cmpxchg DWORD PTR [rdi],edx
    2890:	89 c2                	mov    edx,eax
	/* fast path: INT_MIN for the lock, +1 for the congestion */
	int current = a_cas(l, 0, INT_MIN + 1);
	if (!current) return;
    2892:	85 c0                	test   eax,eax
    2894:	0f 84 9e 01 00 00    	je     2a38 <__lock+0x1c8>
	/* A first spin loop, for medium congestion. */
	for (unsigned i = 0; i < 10; ++i) {
		if (current < 0) current -= INT_MIN + 1;
    289a:	8d 88 01 00 00 80    	lea    ecx,[rax-0x7fffffff]
    28a0:	79 08                	jns    28aa <__lock+0x3a>
    28a2:	89 c1                	mov    ecx,eax
    28a4:	81 c2 ff ff ff 7f    	add    edx,0x7fffffff
    28aa:	89 d0                	mov    eax,edx
    28ac:	f0 0f b1 4d 00       	lock cmpxchg DWORD PTR [rbp+0x0],ecx
    28b1:	89 c1                	mov    ecx,eax
		// assertion: current >= 0
		int val = a_cas(l, current, INT_MIN + (current + 1));
		if (val == current) return;
    28b3:	39 d0                	cmp    eax,edx
    28b5:	0f 84 7d 01 00 00    	je     2a38 <__lock+0x1c8>
		if (current < 0) current -= INT_MIN + 1;
    28bb:	8d 90 01 00 00 80    	lea    edx,[rax-0x7fffffff]
    28c1:	85 c0                	test   eax,eax
    28c3:	79 08                	jns    28cd <__lock+0x5d>
    28c5:	89 c2                	mov    edx,eax
    28c7:	81 c1 ff ff ff 7f    	add    ecx,0x7fffffff
    28cd:	89 c8                	mov    eax,ecx
    28cf:	f0 0f b1 55 00       	lock cmpxchg DWORD PTR [rbp+0x0],edx
    28d4:	89 c2                	mov    edx,eax
		if (val == current) return;
    28d6:	39 c1                	cmp    ecx,eax
    28d8:	0f 84 5a 01 00 00    	je     2a38 <__lock+0x1c8>
		if (current < 0) current -= INT_MIN + 1;
    28de:	8d 88 01 00 00 80    	lea    ecx,[rax-0x7fffffff]
    28e4:	85 c0                	test   eax,eax
    28e6:	79 08                	jns    28f0 <__lock+0x80>
    28e8:	89 c1                	mov    ecx,eax
    28ea:	81 c2 ff ff ff 7f    	add    edx,0x7fffffff
    28f0:	89 d0                	mov    eax,edx
    28f2:	f0 0f b1 4d 00       	lock cmpxchg DWORD PTR [rbp+0x0],ecx
    28f7:	89 c1                	mov    ecx,eax
		if (val == current) return;
    28f9:	39 c2                	cmp    edx,eax
    28fb:	0f 84 37 01 00 00    	je     2a38 <__lock+0x1c8>
		if (current < 0) current -= INT_MIN + 1;
    2901:	8d 90 01 00 00 80    	lea    edx,[rax-0x7fffffff]
    2907:	85 c0                	test   eax,eax
    2909:	79 08                	jns    2913 <__lock+0xa3>
    290b:	89 c2                	mov    edx,eax
    290d:	81 c1 ff ff ff 7f    	add    ecx,0x7fffffff
    2913:	89 c8                	mov    eax,ecx
    2915:	f0 0f b1 55 00       	lock cmpxchg DWORD PTR [rbp+0x0],edx
    291a:	89 c2                	mov    edx,eax
		if (val == current) return;
    291c:	39 c1                	cmp    ecx,eax
    291e:	0f 84 14 01 00 00    	je     2a38 <__lock+0x1c8>
		if (current < 0) current -= INT_MIN + 1;
    2924:	8d 88 01 00 00 80    	lea    ecx,[rax-0x7fffffff]
    292a:	85 c0                	test   eax,eax
    292c:	79 08                	jns    2936 <__lock+0xc6>
    292e:	89 c1                	mov    ecx,eax
    2930:	81 c2 ff ff ff 7f    	add    edx,0x7fffffff
    2936:	89 d0                	mov    eax,edx
    2938:	f0 0f b1 4d 00       	lock cmpxchg DWORD PTR [rbp+0x0],ecx
    293d:	89 c1                	mov    ecx,eax
		if (val == current) return;
    293f:	39 c2                	cmp    edx,eax
    2941:	0f 84 f1 00 00 00    	je     2a38 <__lock+0x1c8>
		if (current < 0) current -= INT_MIN + 1;
    2947:	8d 90 01 00 00 80    	lea    edx,[rax-0x7fffffff]
    294d:	85 c0                	test   eax,eax
    294f:	0f 88 f3 00 00 00    	js     2a48 <__lock+0x1d8>
    2955:	89 c8                	mov    eax,ecx
    2957:	f0 0f b1 55 00       	lock cmpxchg DWORD PTR [rbp+0x0],edx
    295c:	89 c2                	mov    edx,eax
		if (val == current) return;
    295e:	39 c1                	cmp    ecx,eax
    2960:	0f 84 d2 00 00 00    	je     2a38 <__lock+0x1c8>
		if (current < 0) current -= INT_MIN + 1;
    2966:	8d 88 01 00 00 80    	lea    ecx,[rax-0x7fffffff]
    296c:	85 c0                	test   eax,eax
    296e:	0f 88 e4 00 00 00    	js     2a58 <__lock+0x1e8>
    2974:	89 d0                	mov    eax,edx
    2976:	f0 0f b1 4d 00       	lock cmpxchg DWORD PTR [rbp+0x0],ecx
    297b:	89 c1                	mov    ecx,eax
		if (val == current) return;
    297d:	39 c2                	cmp    edx,eax
    297f:	0f 84 b3 00 00 00    	je     2a38 <__lock+0x1c8>
		if (current < 0) current -= INT_MIN + 1;
    2985:	8d 90 01 00 00 80    	lea    edx,[rax-0x7fffffff]
    298b:	85 c0                	test   eax,eax
    298d:	0f 88 d5 00 00 00    	js     2a68 <__lock+0x1f8>
    2993:	89 c8                	mov    eax,ecx
    2995:	f0 0f b1 55 00       	lock cmpxchg DWORD PTR [rbp+0x0],edx
    299a:	89 c2                	mov    edx,eax
		if (val == current) return;
    299c:	39 c1                	cmp    ecx,eax
    299e:	0f 84 94 00 00 00    	je     2a38 <__lock+0x1c8>
		if (current < 0) current -= INT_MIN + 1;
    29a4:	8d 88 01 00 00 80    	lea    ecx,[rax-0x7fffffff]
    29aa:	85 c0                	test   eax,eax
    29ac:	0f 88 c6 00 00 00    	js     2a78 <__lock+0x208>
    29b2:	89 d0                	mov    eax,edx
    29b4:	f0 0f b1 4d 00       	lock cmpxchg DWORD PTR [rbp+0x0],ecx
    29b9:	89 c1                	mov    ecx,eax
		if (val == current) return;
    29bb:	39 c2                	cmp    edx,eax
    29bd:	74 79                	je     2a38 <__lock+0x1c8>
		if (current < 0) current -= INT_MIN + 1;
    29bf:	8d 90 01 00 00 80    	lea    edx,[rax-0x7fffffff]
    29c5:	85 c0                	test   eax,eax
    29c7:	0f 88 bb 00 00 00    	js     2a88 <__lock+0x218>
    29cd:	89 c8                	mov    eax,ecx
    29cf:	f0 0f b1 55 00       	lock cmpxchg DWORD PTR [rbp+0x0],edx
		if (val == current) return;
    29d4:	39 c1                	cmp    ecx,eax
    29d6:	74 60                	je     2a38 <__lock+0x1c8>
	__asm__ __volatile__(
    29d8:	bb 01 00 00 00       	mov    ebx,0x1
    29dd:	f0 0f c1 5d 00       	lock xadd DWORD PTR [rbp+0x0],ebx
		current = val;
	}
	// Spinning failed, so mark ourselves as being inside the CS.
	current = a_fetch_add(l, 1) + 1;
    29e2:	83 c3 01             	add    ebx,0x1
    29e5:	eb 1c                	jmp    2a03 <__lock+0x193>
    29e7:	66 0f 1f 84 00 00 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
		if (current < 0) {
			__futexwait(l, current, 1);
			current -= INT_MIN + 1;
		}
		/* assertion: current > 0, the count includes us already. */
		int val = a_cas(l, current, INT_MIN + current);
    29f0:	8d 9a 00 00 00 80    	lea    ebx,[rdx-0x80000000]
	__asm__ __volatile__ (
    29f6:	89 d0                	mov    eax,edx
    29f8:	f0 0f b1 5d 00       	lock cmpxchg DWORD PTR [rbp+0x0],ebx
    29fd:	89 c3                	mov    ebx,eax
		if (val == current) return;
    29ff:	39 c2                	cmp    edx,eax
    2a01:	74 35                	je     2a38 <__lock+0x1c8>
		if (current < 0) {
    2a03:	89 da                	mov    edx,ebx
    2a05:	85 db                	test   ebx,ebx
    2a07:	79 e7                	jns    29f0 <__lock+0x180>
}
static inline void __futexwait(volatile void *addr, int val, int priv)
{
	if (priv) priv = FUTEX_PRIVATE;
	__syscall(SYS_futex, addr, FUTEX_WAIT|priv, val, 0) != -ENOSYS ||
    2a09:	4c 63 e3             	movsxd r12,ebx
    2a0c:	45 31 c0             	xor    r8d,r8d
    2a0f:	ba 80 00 00 00       	mov    edx,0x80
    2a14:	48 89 ee             	mov    rsi,rbp
    2a17:	4c 89 e1             	mov    rcx,r12
    2a1a:	bf ca 00 00 00       	mov    edi,0xca
    2a1f:	e8 1c fd ff ff       	call   2740 <__syscall4>
    2a24:	48 83 f8 da          	cmp    rax,0xffffffffffffffda
    2a28:	74 6e                	je     2a98 <__lock+0x228>
			current -= INT_MIN + 1;
    2a2a:	8d 93 ff ff ff 7f    	lea    edx,[rbx+0x7fffffff]
    2a30:	eb be                	jmp    29f0 <__lock+0x180>
    2a32:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
		current = val;
	}
}
    2a38:	5b                   	pop    rbx
    2a39:	5d                   	pop    rbp
    2a3a:	41 5c                	pop    r12
    2a3c:	c3                   	ret    
    2a3d:	0f 1f 00             	nop    DWORD PTR [rax]
    2a40:	c3                   	ret    
    2a41:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
		if (current < 0) current -= INT_MIN + 1;
    2a48:	89 c2                	mov    edx,eax
    2a4a:	81 c1 ff ff ff 7f    	add    ecx,0x7fffffff
    2a50:	e9 00 ff ff ff       	jmp    2955 <__lock+0xe5>
    2a55:	0f 1f 00             	nop    DWORD PTR [rax]
    2a58:	89 c1                	mov    ecx,eax
    2a5a:	81 c2 ff ff ff 7f    	add    edx,0x7fffffff
    2a60:	e9 0f ff ff ff       	jmp    2974 <__lock+0x104>
    2a65:	0f 1f 00             	nop    DWORD PTR [rax]
    2a68:	89 c2                	mov    edx,eax
    2a6a:	81 c1 ff ff ff 7f    	add    ecx,0x7fffffff
    2a70:	e9 1e ff ff ff       	jmp    2993 <__lock+0x123>
    2a75:	0f 1f 00             	nop    DWORD PTR [rax]
    2a78:	89 c1                	mov    ecx,eax
    2a7a:	81 c2 ff ff ff 7f    	add    edx,0x7fffffff
    2a80:	e9 2d ff ff ff       	jmp    29b2 <__lock+0x142>
    2a85:	0f 1f 00             	nop    DWORD PTR [rax]
    2a88:	89 c2                	mov    edx,eax
    2a8a:	81 c1 ff ff ff 7f    	add    ecx,0x7fffffff
    2a90:	e9 38 ff ff ff       	jmp    29cd <__lock+0x15d>
    2a95:	0f 1f 00             	nop    DWORD PTR [rax]
	__syscall(SYS_futex, addr, FUTEX_WAIT, val, 0);
    2a98:	45 31 c0             	xor    r8d,r8d
    2a9b:	4c 89 e1             	mov    rcx,r12
    2a9e:	31 d2                	xor    edx,edx
    2aa0:	48 89 ee             	mov    rsi,rbp
    2aa3:	bf ca 00 00 00       	mov    edi,0xca
    2aa8:	e8 93 fc ff ff       	call   2740 <__syscall4>
    2aad:	e9 78 ff ff ff       	jmp    2a2a <__lock+0x1ba>
    2ab2:	66 66 2e 0f 1f 84 00 00 00 00 00 	data16 nop WORD PTR cs:[rax+rax*1+0x0]
    2abd:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000002ac0 <__unlock>:

void __unlock(volatile int *l)
{
	/* Check l[0] to see if we are multi-threaded. */
	if (l[0] < 0) {
    2ac0:	8b 07                	mov    eax,DWORD PTR [rdi]
    2ac2:	85 c0                	test   eax,eax
    2ac4:	78 0a                	js     2ad0 <__unlock+0x10>
    2ac6:	c3                   	ret    
    2ac7:	66 0f 1f 84 00 00 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
{
    2ad0:	55                   	push   rbp
	__asm__ __volatile__(
    2ad1:	b8 ff ff ff 7f       	mov    eax,0x7fffffff
    2ad6:	48 89 fd             	mov    rbp,rdi
    2ad9:	f0 0f c1 07          	lock xadd DWORD PTR [rdi],eax
		if (a_fetch_add(l, -(INT_MIN + 1)) != (INT_MIN + 1)) {
    2add:	3d 01 00 00 80       	cmp    eax,0x80000001
    2ae2:	74 1d                	je     2b01 <__unlock+0x41>
	__syscall(SYS_futex, addr, FUTEX_WAKE|priv, cnt) != -ENOSYS ||
    2ae4:	48 89 fe             	mov    rsi,rdi
    2ae7:	b9 01 00 00 00       	mov    ecx,0x1
    2aec:	ba 81 00 00 00       	mov    edx,0x81
    2af1:	bf ca 00 00 00       	mov    edi,0xca
    2af6:	e8 25 fc ff ff       	call   2720 <__syscall3>
    2afb:	48 83 f8 da          	cmp    rax,0xffffffffffffffda
    2aff:	74 07                	je     2b08 <__unlock+0x48>
			__wake(l, 1, 1);
		}
	}
}
    2b01:	5d                   	pop    rbp
    2b02:	c3                   	ret    
    2b03:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
	__syscall(SYS_futex, addr, FUTEX_WAKE, cnt);
    2b08:	48 89 ee             	mov    rsi,rbp
    2b0b:	b9 01 00 00 00       	mov    ecx,0x1
    2b10:	ba 01 00 00 00       	mov    edx,0x1
    2b15:	5d                   	pop    rbp
    2b16:	bf ca 00 00 00       	mov    edi,0xca
    2b1b:	e9 00 fc ff ff       	jmp    2720 <__syscall3>

0000000000002b20 <__wait>:
#include "pthread_impl.h"

void __wait(volatile int *addr, volatile int *waiters, int val, int priv)
{
    2b20:	41 56                	push   r14
	int spins=100;
	if (priv) priv = FUTEX_PRIVATE;
    2b22:	b8 64 00 00 00       	mov    eax,0x64
{
    2b27:	41 55                	push   r13
	if (priv) priv = FUTEX_PRIVATE;
    2b29:	45 31 ed             	xor    r13d,r13d
    2b2c:	85 c9                	test   ecx,ecx
    2b2e:	41 0f 95 c5          	setne  r13b
{
    2b32:	41 54                	push   r12
    2b34:	49 89 f4             	mov    r12,rsi
    2b37:	55                   	push   rbp
	if (priv) priv = FUTEX_PRIVATE;
    2b38:	49 c1 e5 07          	shl    r13,0x7
{
    2b3c:	89 d5                	mov    ebp,edx
    2b3e:	53                   	push   rbx
    2b3f:	48 89 fb             	mov    rbx,rdi
    2b42:	48 85 f6             	test   rsi,rsi
    2b45:	75 16                	jne    2b5d <__wait+0x3d>
    2b47:	eb 77                	jmp    2bc0 <__wait+0xa0>
    2b49:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
	while (spins-- && (!waiters || !*waiters)) {
		if (*addr==val) a_spin();
    2b50:	8b 13                	mov    edx,DWORD PTR [rbx]
    2b52:	39 d5                	cmp    ebp,edx
    2b54:	75 46                	jne    2b9c <__wait+0x7c>
	__asm__ __volatile__( "pause" : : : "memory" );
    2b56:	f3 90                	pause  
	while (spins-- && (!waiters || !*waiters)) {
    2b58:	83 e8 01             	sub    eax,0x1
    2b5b:	74 08                	je     2b65 <__wait+0x45>
    2b5d:	41 8b 14 24          	mov    edx,DWORD PTR [r12]
    2b61:	85 d2                	test   edx,edx
    2b63:	74 eb                	je     2b50 <__wait+0x30>
	__asm__ __volatile__(
    2b65:	f0 41 ff 04 24       	lock inc DWORD PTR [r12]
		else return;
	}
	if (waiters) a_inc(waiters);
	while (*addr==val) {
		__syscall(SYS_futex, addr, FUTEX_WAIT|priv, val, 0) != -ENOSYS
    2b6a:	4c 63 f5             	movsxd r14,ebp
    2b6d:	eb 1d                	jmp    2b8c <__wait+0x6c>
    2b6f:	90                   	nop
    2b70:	45 31 c0             	xor    r8d,r8d
    2b73:	4c 89 f1             	mov    rcx,r14
    2b76:	4c 89 ea             	mov    rdx,r13
    2b79:	48 89 de             	mov    rsi,rbx
    2b7c:	bf ca 00 00 00       	mov    edi,0xca
    2b81:	e8 ba fb ff ff       	call   2740 <__syscall4>
		|| __syscall(SYS_futex, addr, FUTEX_WAIT, val, 0);
    2b86:	48 83 f8 da          	cmp    rax,0xffffffffffffffda
    2b8a:	74 1c                	je     2ba8 <__wait+0x88>
	while (*addr==val) {
    2b8c:	8b 03                	mov    eax,DWORD PTR [rbx]
    2b8e:	39 e8                	cmp    eax,ebp
    2b90:	74 de                	je     2b70 <__wait+0x50>
	}
	if (waiters) a_dec(waiters);
    2b92:	4d 85 e4             	test   r12,r12
    2b95:	74 05                	je     2b9c <__wait+0x7c>
	__asm__ __volatile__(
    2b97:	f0 41 ff 0c 24       	lock dec DWORD PTR [r12]
}
    2b9c:	5b                   	pop    rbx
    2b9d:	5d                   	pop    rbp
    2b9e:	41 5c                	pop    r12
    2ba0:	41 5d                	pop    r13
    2ba2:	41 5e                	pop    r14
    2ba4:	c3                   	ret    
    2ba5:	0f 1f 00             	nop    DWORD PTR [rax]
		|| __syscall(SYS_futex, addr, FUTEX_WAIT, val, 0);
    2ba8:	45 31 c0             	xor    r8d,r8d
    2bab:	4c 89 f1             	mov    rcx,r14
    2bae:	31 d2                	xor    edx,edx
    2bb0:	48 89 de             	mov    rsi,rbx
    2bb3:	bf ca 00 00 00       	mov    edi,0xca
    2bb8:	e8 83 fb ff ff       	call   2740 <__syscall4>
    2bbd:	eb cd                	jmp    2b8c <__wait+0x6c>
    2bbf:	90                   	nop
	if (priv) priv = FUTEX_PRIVATE;
    2bc0:	b8 64 00 00 00       	mov    eax,0x64
    2bc5:	eb 10                	jmp    2bd7 <__wait+0xb7>
    2bc7:	66 0f 1f 84 00 00 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]
	__asm__ __volatile__( "pause" : : : "memory" );
    2bd0:	f3 90                	pause  
	while (spins-- && (!waiters || !*waiters)) {
    2bd2:	83 e8 01             	sub    eax,0x1
    2bd5:	74 93                	je     2b6a <__wait+0x4a>
		if (*addr==val) a_spin();
    2bd7:	8b 13                	mov    edx,DWORD PTR [rbx]
    2bd9:	39 ea                	cmp    edx,ebp
    2bdb:	74 f3                	je     2bd0 <__wait+0xb0>
}
    2bdd:	5b                   	pop    rbx
    2bde:	5d                   	pop    rbp
    2bdf:	41 5c                	pop    r12
    2be1:	41 5d                	pop    r13
    2be3:	41 5e                	pop    r14
    2be5:	c3                   	ret    
    2be6:	66 2e 0f 1f 84 00 00 00 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]

0000000000002bf0 <__init_tp>:
#include "syscall.h"

volatile int __thread_list_lock;

int __init_tp(void *p)
{
    2bf0:	53                   	push   rbx
    2bf1:	48 89 fb             	mov    rbx,rdi
    2bf4:	48 83 ec 10          	sub    rsp,0x10
	pthread_t td = p;
	td->self = td;
    2bf8:	48 89 3f             	mov    QWORD PTR [rdi],rdi
	int r = __set_thread_area(TP_ADJ(p));
    2bfb:	e8 70 32 00 00       	call   5e70 <__set_thread_area>
	if (r < 0) return -1;
    2c00:	85 c0                	test   eax,eax
    2c02:	78 70                	js     2c74 <__init_tp+0x84>

	if (!r) libc.can_do_threads = 1;
    2c04:	74 62                	je     2c68 <__init_tp+0x78>
    2c06:	66 48 0f 6e c3       	movq   xmm0,rbx
	td->detach_state = DT_JOINABLE;
	td->tid = __syscall(SYS_set_tid_address, &__thread_list_lock);
    2c0b:	be 94 d0 00 00       	mov    esi,0xd094
    2c10:	bf da 00 00 00       	mov    edi,0xda
	td->detach_state = DT_JOINABLE;
    2c15:	c7 43 40 01 00 00 00 	mov    DWORD PTR [rbx+0x40],0x1
    2c1c:	66 0f 6c c0          	punpcklqdq xmm0,xmm0
    2c20:	0f 29 04 24          	movaps XMMWORD PTR [rsp],xmm0
	td->tid = __syscall(SYS_set_tid_address, &__thread_list_lock);
    2c24:	e8 b7 fa ff ff       	call   26e0 <__syscall1>
	td->locale = &libc.global_locale;
	td->robust_list.head = &td->robust_list.head;
	td->sysinfo = __sysinfo;
	td->next = td->prev = td;
    2c29:	66 0f 6f 04 24       	movdqa xmm0,XMMWORD PTR [rsp]
	td->locale = &libc.global_locale;
    2c2e:	48 c7 83 b0 00 00 00 60 d0 00 00 	mov    QWORD PTR [rbx+0xb0],0xd060
	td->tid = __syscall(SYS_set_tid_address, &__thread_list_lock);
    2c39:	89 43 38             	mov    DWORD PTR [rbx+0x38],eax
	td->robust_list.head = &td->robust_list.head;
    2c3c:	48 8d 83 90 00 00 00 	lea    rax,[rbx+0x90]
    2c43:	48 89 83 90 00 00 00 	mov    QWORD PTR [rbx+0x90],rax
	td->sysinfo = __sysinfo;
    2c4a:	48 8b 05 af 43 00 00 	mov    rax,QWORD PTR [rip+0x43af]        # 7000 <__sysinfo>
	td->next = td->prev = td;
    2c51:	0f 11 43 10          	movups XMMWORD PTR [rbx+0x10],xmm0
	td->sysinfo = __sysinfo;
    2c55:	48 89 43 20          	mov    QWORD PTR [rbx+0x20],rax
	return 0;
    2c59:	31 c0                	xor    eax,eax
}
    2c5b:	48 83 c4 10          	add    rsp,0x10
    2c5f:	5b                   	pop    rbx
    2c60:	c3                   	ret    
    2c61:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
	if (!r) libc.can_do_threads = 1;
    2c68:	c7 05 ae a3 00 00 01 00 00 00 	mov    DWORD PTR [rip+0xa3ae],0x1        # d020 <__libc>
    2c72:	eb 92                	jmp    2c06 <__init_tp+0x16>
	if (r < 0) return -1;
    2c74:	b8 ff ff ff ff       	mov    eax,0xffffffff
    2c79:	eb e0                	jmp    2c5b <__init_tp+0x6b>
    2c7b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

0000000000002c80 <__copy_tls>:
#define MIN_TLS_ALIGN offsetof(struct builtin_tls, pt)

static struct tls_module main_tls;

void *__copy_tls(unsigned char *mem)
{
    2c80:	41 55                	push   r13
    2c82:	49 89 fd             	mov    r13,rdi
    2c85:	41 54                	push   r12
    2c87:	55                   	push   rbp
    2c88:	53                   	push   rbx
    2c89:	48 83 ec 08          	sub    rsp,0x8
		memcpy(mem + p->offset, p->image, p->len);
	}
#else
	dtv = (uintptr_t *)mem;

	mem += libc.tls_size - sizeof(struct pthread);
    2c8d:	48 8b 05 ac a3 00 00 	mov    rax,QWORD PTR [rip+0xa3ac]        # d040 <__libc+0x20>
	mem -= (uintptr_t)mem & (libc.tls_align-1);
    2c94:	4c 8b 25 ad a3 00 00 	mov    r12,QWORD PTR [rip+0xa3ad]        # d048 <__libc+0x28>
	td = (pthread_t)mem;

	for (i=1, p=libc.tls_head; p; i++, p=p->next) {
    2c9b:	48 8b 1d 96 a3 00 00 	mov    rbx,QWORD PTR [rip+0xa396]        # d038 <__libc+0x18>
	mem += libc.tls_size - sizeof(struct pthread);
    2ca2:	48 8d 84 07 20 ff ff ff 	lea    rax,[rdi+rax*1-0xe0]
	mem -= (uintptr_t)mem & (libc.tls_align-1);
    2caa:	49 f7 dc             	neg    r12
    2cad:	49 21 c4             	and    r12,rax
	for (i=1, p=libc.tls_head; p; i++, p=p->next) {
    2cb0:	48 85 db             	test   rbx,rbx
    2cb3:	74 36                	je     2ceb <__copy_tls+0x6b>
    2cb5:	48 8d 6f 08          	lea    rbp,[rdi+0x8]
    2cb9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
		dtv[i] = (uintptr_t)(mem - p->offset) + DTP_OFFSET;
    2cc0:	4c 89 e0             	mov    rax,r12
    2cc3:	48 2b 43 28          	sub    rax,QWORD PTR [rbx+0x28]
		memcpy(mem - p->offset, p->image, p->len);
    2cc7:	48 8b 73 08          	mov    rsi,QWORD PTR [rbx+0x8]
    2ccb:	4c 89 e7             	mov    rdi,r12
		dtv[i] = (uintptr_t)(mem - p->offset) + DTP_OFFSET;
    2cce:	48 89 45 00          	mov    QWORD PTR [rbp+0x0],rax
		memcpy(mem - p->offset, p->image, p->len);
    2cd2:	48 8b 53 10          	mov    rdx,QWORD PTR [rbx+0x10]
    2cd6:	48 83 c5 08          	add    rbp,0x8
    2cda:	48 2b 7b 28          	sub    rdi,QWORD PTR [rbx+0x28]
    2cde:	e8 8d fa ff ff       	call   2770 <memcpy>
	for (i=1, p=libc.tls_head; p; i++, p=p->next) {
    2ce3:	48 8b 1b             	mov    rbx,QWORD PTR [rbx]
    2ce6:	48 85 db             	test   rbx,rbx
    2ce9:	75 d5                	jne    2cc0 <__copy_tls+0x40>
	}
#endif
	dtv[0] = libc.tls_cnt;
    2ceb:	48 8b 05 5e a3 00 00 	mov    rax,QWORD PTR [rip+0xa35e]        # d050 <__libc+0x30>
    2cf2:	49 89 45 00          	mov    QWORD PTR [r13+0x0],rax
	td->dtv = td->dtv_copy = dtv;
	return td;
}
    2cf6:	4c 89 e0             	mov    rax,r12
	td->dtv = td->dtv_copy = dtv;
    2cf9:	4d 89 ac 24 d8 00 00 00 	mov    QWORD PTR [r12+0xd8],r13
    2d01:	4d 89 6c 24 08       	mov    QWORD PTR [r12+0x8],r13
}
    2d06:	48 83 c4 08          	add    rsp,0x8
    2d0a:	5b                   	pop    rbx
    2d0b:	5d                   	pop    rbp
    2d0c:	41 5c                	pop    r12
    2d0e:	41 5d                	pop    r13
    2d10:	c3                   	ret    
    2d11:	66 66 2e 0f 1f 84 00 00 00 00 00 	data16 nop WORD PTR cs:[rax+rax*1+0x0]
    2d1c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

0000000000002d20 <__init_tls>:
#endif

extern weak hidden const size_t _DYNAMIC[];

static void static_init_tls(size_t *aux)
{
    2d20:	41 55                	push   r13
    2d22:	41 54                	push   r12
    2d24:	55                   	push   rbp
    2d25:	53                   	push   rbx
    2d26:	48 83 ec 18          	sub    rsp,0x18
	size_t n;
	Phdr *phdr, *tls_phdr=0;
	size_t base = 0;
	void *mem;

	for (p=(void *)aux[AT_PHDR],n=aux[AT_PHNUM]; n; n--,p+=aux[AT_PHENT]) {
    2d2a:	48 8b 57 28          	mov    rdx,QWORD PTR [rdi+0x28]
    2d2e:	4c 8b 4f 18          	mov    r9,QWORD PTR [rdi+0x18]
    2d32:	48 85 d2             	test   rdx,rdx
    2d35:	0f 84 b5 02 00 00    	je     2ff0 <__init_tls+0x2d0>
    2d3b:	41 bb 00 00 00 00    	mov    r11d,0x0
    2d41:	48 8b 7f 20          	mov    rdi,QWORD PTR [rdi+0x20]
    2d45:	4c 89 c8             	mov    rax,r9
    2d48:	31 db                	xor    ebx,ebx
    2d4a:	44 8b 05 b7 42 00 00 	mov    r8d,DWORD PTR [rip+0x42b7]        # 7008 <__default_stacksize>
    2d51:	4d 85 db             	test   r11,r11
    2d54:	0f 84 b6 02 00 00    	je     3010 <__init_tls+0x2f0>
	size_t base = 0;
    2d5a:	31 c9                	xor    ecx,ecx
	Phdr *phdr, *tls_phdr=0;
    2d5c:	31 ed                	xor    ebp,ebp
			tls_phdr = phdr;
		if (phdr->p_type == PT_GNU_STACK &&
		    phdr->p_memsz > __default_stacksize)
			__default_stacksize =
				phdr->p_memsz < DEFAULT_STACK_MAX ?
				phdr->p_memsz : DEFAULT_STACK_MAX;
    2d5e:	41 bc 00 00 80 00    	mov    r12d,0x800000
    2d64:	eb 1f                	jmp    2d85 <__init_tls+0x65>
    2d66:	66 2e 0f 1f 84 00 00 00 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
		if (phdr->p_type == PT_TLS)
    2d70:	83 fe 07             	cmp    esi,0x7
    2d73:	0f 85 db 01 00 00    	jne    2f54 <__init_tls+0x234>
    2d79:	48 89 c5             	mov    rbp,rax
	for (p=(void *)aux[AT_PHDR],n=aux[AT_PHNUM]; n; n--,p+=aux[AT_PHENT]) {
    2d7c:	48 01 f8             	add    rax,rdi
    2d7f:	48 83 ea 01          	sub    rdx,0x1
    2d83:	74 20                	je     2da5 <__init_tls+0x85>
		if (phdr->p_type == PT_PHDR)
    2d85:	8b 30                	mov    esi,DWORD PTR [rax]
    2d87:	83 fe 06             	cmp    esi,0x6
    2d8a:	0f 84 b8 01 00 00    	je     2f48 <__init_tls+0x228>
		if (phdr->p_type == PT_DYNAMIC && _DYNAMIC)
    2d90:	83 fe 02             	cmp    esi,0x2
    2d93:	75 db                	jne    2d70 <__init_tls+0x50>
			base = (size_t)_DYNAMIC - phdr->p_vaddr;
    2d95:	4c 89 d9             	mov    rcx,r11
    2d98:	48 2b 48 10          	sub    rcx,QWORD PTR [rax+0x10]
	for (p=(void *)aux[AT_PHDR],n=aux[AT_PHNUM]; n; n--,p+=aux[AT_PHENT]) {
    2d9c:	48 01 f8             	add    rax,rdi
    2d9f:	48 83 ea 01          	sub    rdx,0x1
    2da3:	75 e0                	jne    2d85 <__init_tls+0x65>
    2da5:	84 db                	test   bl,bl
    2da7:	74 07                	je     2db0 <__init_tls+0x90>
    2da9:	44 89 05 58 42 00 00 	mov    DWORD PTR [rip+0x4258],r8d        # 7008 <__default_stacksize>
	}

	if (tls_phdr) {
    2db0:	48 85 ed             	test   rbp,rbp
    2db3:	0f 84 37 02 00 00    	je     2ff0 <__init_tls+0x2d0>
		main_tls.image = (void *)(base + tls_phdr->p_vaddr);
		main_tls.len = tls_phdr->p_filesz;
		main_tls.size = tls_phdr->p_memsz;
		main_tls.align = tls_phdr->p_align;
    2db9:	48 8b 75 30          	mov    rsi,QWORD PTR [rbp+0x30]
		main_tls.image = (void *)(base + tls_phdr->p_vaddr);
    2dbd:	48 03 4d 10          	add    rcx,QWORD PTR [rbp+0x10]
		libc.tls_cnt = 1;
		libc.tls_head = &main_tls;
    2dc1:	48 c7 05 6c a2 00 00 20 d7 00 00 	mov    QWORD PTR [rip+0xa26c],0xd720        # d038 <__libc+0x18>
		main_tls.len = tls_phdr->p_filesz;
    2dcc:	f3 0f 6f 55 20       	movdqu xmm2,XMMWORD PTR [rbp+0x20]
		main_tls.size = tls_phdr->p_memsz;
    2dd1:	48 8b 55 28          	mov    rdx,QWORD PTR [rbp+0x28]
		main_tls.image = (void *)(base + tls_phdr->p_vaddr);
    2dd5:	48 89 0d 4c a9 00 00 	mov    QWORD PTR [rip+0xa94c],rcx        # d728 <main_tls+0x8>
		main_tls.align = tls_phdr->p_align;
    2ddc:	48 89 35 5d a9 00 00 	mov    QWORD PTR [rip+0xa95d],rsi        # d740 <main_tls+0x20>
		libc.tls_cnt = 1;
    2de3:	48 c7 05 62 a2 00 00 01 00 00 00 	mov    QWORD PTR [rip+0xa262],0x1        # d050 <__libc+0x30>
		main_tls.len = tls_phdr->p_filesz;
    2dee:	0f 29 15 3b a9 00 00 	movaps XMMWORD PTR [rip+0xa93b],xmm2        # d730 <main_tls+0x10>
	}

	main_tls.size += (-main_tls.size - (uintptr_t)main_tls.image)
    2df5:	48 01 d1             	add    rcx,rdx
		& (main_tls.align-1);
    2df8:	48 8d 46 ff          	lea    rax,[rsi-0x1]
	main_tls.size += (-main_tls.size - (uintptr_t)main_tls.image)
    2dfc:	48 f7 d9             	neg    rcx
		& (main_tls.align-1);
    2dff:	48 21 c1             	and    rcx,rax
	main_tls.size += (-main_tls.size - (uintptr_t)main_tls.image)
    2e02:	48 01 ca             	add    rdx,rcx
    2e05:	48 8d 8e f7 00 00 00 	lea    rcx,[rsi+0xf7]
    2e0c:	48 89 15 25 a9 00 00 	mov    QWORD PTR [rip+0xa925],rdx        # d738 <main_tls+0x18>
#ifdef TLS_ABOVE_TP
	main_tls.offset = GAP_ABOVE_TP;
	main_tls.offset += (-GAP_ABOVE_TP + (uintptr_t)main_tls.image)
		& (main_tls.align-1);
#else
	main_tls.offset = main_tls.size;
    2e13:	48 89 15 2e a9 00 00 	mov    QWORD PTR [rip+0xa92e],rdx        # d748 <main_tls+0x28>
#endif
	if (main_tls.align < MIN_TLS_ALIGN) main_tls.align = MIN_TLS_ALIGN;
    2e1a:	48 83 fe 07          	cmp    rsi,0x7
    2e1e:	77 1a                	ja     2e3a <__init_tls+0x11a>
    2e20:	b8 07 00 00 00       	mov    eax,0x7
    2e25:	b9 ff 00 00 00       	mov    ecx,0xff
    2e2a:	be 08 00 00 00       	mov    esi,0x8
    2e2f:	48 c7 05 06 a9 00 00 08 00 00 00 	mov    QWORD PTR [rip+0xa906],0x8        # d740 <main_tls+0x20>
	libc.tls_size = 2*sizeof(void *) + sizeof(struct pthread)
#ifdef TLS_ABOVE_TP
		+ main_tls.offset
#endif
		+ main_tls.size + main_tls.align
		+ MIN_TLS_ALIGN-1 & -MIN_TLS_ALIGN;
    2e3a:	48 01 ca             	add    rdx,rcx
	libc.tls_align = main_tls.align;
    2e3d:	48 89 35 04 a2 00 00 	mov    QWORD PTR [rip+0xa204],rsi        # d048 <__libc+0x28>
			MAP_ANONYMOUS|MAP_PRIVATE, -1, 0);
		/* -4095...-1 cast to void * will crash on dereference anyway,
		 * so don't bloat the init code checking for error codes and
		 * explicitly calling a_crash(). */
	} else {
		mem = builtin_tls;
    2e44:	41 bd 60 d7 00 00    	mov    r13d,0xd760
		+ MIN_TLS_ALIGN-1 & -MIN_TLS_ALIGN;
    2e4a:	48 83 e2 f8          	and    rdx,0xfffffffffffffff8
	libc.tls_size = 2*sizeof(void *) + sizeof(struct pthread)
    2e4e:	48 89 15 eb a1 00 00 	mov    QWORD PTR [rip+0xa1eb],rdx        # d040 <__libc+0x20>
	if (libc.tls_size > sizeof builtin_tls) {
    2e55:	48 81 fa 68 01 00 00 	cmp    rdx,0x168
    2e5c:	0f 87 4e 01 00 00    	ja     2fb0 <__init_tls+0x290>
	mem += libc.tls_size - sizeof(struct pthread);
    2e62:	49 8d ac 15 20 ff ff ff 	lea    rbp,[r13+rdx*1-0xe0]
	for (i=1, p=libc.tls_head; p; i++, p=p->next) {
    2e6a:	48 8b 1d c7 a1 00 00 	mov    rbx,QWORD PTR [rip+0xa1c7]        # d038 <__libc+0x18>
    2e71:	4d 8d 65 08          	lea    r12,[r13+0x8]
	mem -= (uintptr_t)mem & (libc.tls_align-1);
    2e75:	48 21 e8             	and    rax,rbp
    2e78:	48 29 c5             	sub    rbp,rax
	for (i=1, p=libc.tls_head; p; i++, p=p->next) {
    2e7b:	48 85 db             	test   rbx,rbx
    2e7e:	74 2b                	je     2eab <__init_tls+0x18b>
		dtv[i] = (uintptr_t)(mem - p->offset) + DTP_OFFSET;
    2e80:	48 89 e8             	mov    rax,rbp
    2e83:	48 2b 43 28          	sub    rax,QWORD PTR [rbx+0x28]
		memcpy(mem - p->offset, p->image, p->len);
    2e87:	48 8b 73 08          	mov    rsi,QWORD PTR [rbx+0x8]
    2e8b:	48 89 ef             	mov    rdi,rbp
		dtv[i] = (uintptr_t)(mem - p->offset) + DTP_OFFSET;
    2e8e:	49 89 04 24          	mov    QWORD PTR [r12],rax
		memcpy(mem - p->offset, p->image, p->len);
    2e92:	48 8b 53 10          	mov    rdx,QWORD PTR [rbx+0x10]
    2e96:	49 83 c4 08          	add    r12,0x8
    2e9a:	48 2b 7b 28          	sub    rdi,QWORD PTR [rbx+0x28]
    2e9e:	e8 cd f8 ff ff       	call   2770 <memcpy>
	for (i=1, p=libc.tls_head; p; i++, p=p->next) {
    2ea3:	48 8b 1b             	mov    rbx,QWORD PTR [rbx]
    2ea6:	48 85 db             	test   rbx,rbx
    2ea9:	75 d5                	jne    2e80 <__init_tls+0x160>
	dtv[0] = libc.tls_cnt;
    2eab:	48 8b 05 9e a1 00 00 	mov    rax,QWORD PTR [rip+0xa19e]        # d050 <__libc+0x30>
	td->self = td;
    2eb2:	66 48 0f 6e c5       	movq   xmm0,rbp
    2eb7:	66 49 0f 6e cd       	movq   xmm1,r13
	int r = __set_thread_area(TP_ADJ(p));
    2ebc:	48 89 ef             	mov    rdi,rbp
	td->self = td;
    2ebf:	66 0f 6c c1          	punpcklqdq xmm0,xmm1
	dtv[0] = libc.tls_cnt;
    2ec3:	49 89 45 00          	mov    QWORD PTR [r13+0x0],rax
	td->dtv = td->dtv_copy = dtv;
    2ec7:	4c 89 ad d8 00 00 00 	mov    QWORD PTR [rbp+0xd8],r13
	td->self = td;
    2ece:	0f 11 45 00          	movups XMMWORD PTR [rbp+0x0],xmm0
	int r = __set_thread_area(TP_ADJ(p));
    2ed2:	e8 99 2f 00 00       	call   5e70 <__set_thread_area>
	if (r < 0) return -1;
    2ed7:	85 c0                	test   eax,eax
    2ed9:	0f 88 c0 00 00 00    	js     2f9f <__init_tls+0x27f>
	if (!r) libc.can_do_threads = 1;
    2edf:	0f 84 ab 00 00 00    	je     2f90 <__init_tls+0x270>
    2ee5:	66 48 0f 6e c5       	movq   xmm0,rbp
	td->tid = __syscall(SYS_set_tid_address, &__thread_list_lock);
    2eea:	be 94 d0 00 00       	mov    esi,0xd094
    2eef:	bf da 00 00 00       	mov    edi,0xda
	td->detach_state = DT_JOINABLE;
    2ef4:	c7 45 40 01 00 00 00 	mov    DWORD PTR [rbp+0x40],0x1
    2efb:	66 0f 6c c0          	punpcklqdq xmm0,xmm0
    2eff:	0f 29 04 24          	movaps XMMWORD PTR [rsp],xmm0
	td->tid = __syscall(SYS_set_tid_address, &__thread_list_lock);
    2f03:	e8 d8 f7 ff ff       	call   26e0 <__syscall1>
	td->next = td->prev = td;
    2f08:	66 0f 6f 04 24       	movdqa xmm0,XMMWORD PTR [rsp]
	td->locale = &libc.global_locale;
    2f0d:	48 c7 85 b0 00 00 00 60 d0 00 00 	mov    QWORD PTR [rbp+0xb0],0xd060
	td->tid = __syscall(SYS_set_tid_address, &__thread_list_lock);
    2f18:	89 45 38             	mov    DWORD PTR [rbp+0x38],eax
	td->robust_list.head = &td->robust_list.head;
    2f1b:	48 8d 85 90 00 00 00 	lea    rax,[rbp+0x90]
    2f22:	48 89 85 90 00 00 00 	mov    QWORD PTR [rbp+0x90],rax
	td->sysinfo = __sysinfo;
    2f29:	48 8b 05 d0 40 00 00 	mov    rax,QWORD PTR [rip+0x40d0]        # 7000 <__sysinfo>
	td->next = td->prev = td;
    2f30:	0f 11 45 10          	movups XMMWORD PTR [rbp+0x10],xmm0
	td->sysinfo = __sysinfo;
    2f34:	48 89 45 20          	mov    QWORD PTR [rbp+0x20],rax
	}

	/* Failure to initialize thread pointer is always fatal. */
	if (__init_tp(__copy_tls(mem)) < 0)
		a_crash();
}
    2f38:	48 83 c4 18          	add    rsp,0x18
    2f3c:	5b                   	pop    rbx
    2f3d:	5d                   	pop    rbp
    2f3e:	41 5c                	pop    r12
    2f40:	41 5d                	pop    r13
    2f42:	c3                   	ret    
    2f43:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
			base = aux[AT_PHDR] - phdr->p_vaddr;
    2f48:	4c 89 c9             	mov    rcx,r9
    2f4b:	48 2b 48 10          	sub    rcx,QWORD PTR [rax+0x10]
		if (phdr->p_type == PT_GNU_STACK &&
    2f4f:	e9 28 fe ff ff       	jmp    2d7c <__init_tls+0x5c>
    2f54:	81 fe 51 e5 74 64    	cmp    esi,0x6474e551
    2f5a:	0f 85 1c fe ff ff    	jne    2d7c <__init_tls+0x5c>
		    phdr->p_memsz > __default_stacksize)
    2f60:	48 8b 70 28          	mov    rsi,QWORD PTR [rax+0x28]
    2f64:	45 89 c2             	mov    r10d,r8d
		if (phdr->p_type == PT_GNU_STACK &&
    2f67:	4c 39 d6             	cmp    rsi,r10
    2f6a:	0f 86 0c fe ff ff    	jbe    2d7c <__init_tls+0x5c>
				phdr->p_memsz : DEFAULT_STACK_MAX;
    2f70:	48 81 fe 00 00 80 00 	cmp    rsi,0x800000
			__default_stacksize =
    2f77:	bb 01 00 00 00       	mov    ebx,0x1
    2f7c:	49 0f 47 f4          	cmova  rsi,r12
    2f80:	49 89 f0             	mov    r8,rsi
    2f83:	e9 f4 fd ff ff       	jmp    2d7c <__init_tls+0x5c>
    2f88:	0f 1f 84 00 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
	if (!r) libc.can_do_threads = 1;
    2f90:	c7 05 86 a0 00 00 01 00 00 00 	mov    DWORD PTR [rip+0xa086],0x1        # d020 <__libc>
    2f9a:	e9 46 ff ff ff       	jmp    2ee5 <__init_tls+0x1c5>
	__asm__ __volatile__( "hlt" : : : "memory" );
    2f9f:	f4                   	hlt    
}
    2fa0:	48 83 c4 18          	add    rsp,0x18
    2fa4:	5b                   	pop    rbx
    2fa5:	5d                   	pop    rbp
    2fa6:	41 5c                	pop    r12
    2fa8:	41 5d                	pop    r13
    2faa:	c3                   	ret    
    2fab:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
		mem = (void *)__syscall(
    2fb0:	48 83 ec 08          	sub    rsp,0x8
    2fb4:	b9 03 00 00 00       	mov    ecx,0x3
    2fb9:	31 f6                	xor    esi,esi
    2fbb:	bf 09 00 00 00       	mov    edi,0x9
    2fc0:	6a 00                	push   0x0
    2fc2:	49 c7 c1 ff ff ff ff 	mov    r9,0xffffffffffffffff
    2fc9:	41 b8 22 00 00 00    	mov    r8d,0x22
    2fcf:	e8 6c ee ff ff       	call   1e40 <__syscall6>
    2fd4:	59                   	pop    rcx
    2fd5:	48 8b 15 64 a0 00 00 	mov    rdx,QWORD PTR [rip+0xa064]        # d040 <__libc+0x20>
    2fdc:	49 89 c5             	mov    r13,rax
    2fdf:	48 8b 05 62 a0 00 00 	mov    rax,QWORD PTR [rip+0xa062]        # d048 <__libc+0x28>
    2fe6:	5e                   	pop    rsi
    2fe7:	48 83 e8 01          	sub    rax,0x1
    2feb:	e9 72 fe ff ff       	jmp    2e62 <__init_tls+0x142>
    2ff0:	48 8b 15 41 a7 00 00 	mov    rdx,QWORD PTR [rip+0xa741]        # d738 <main_tls+0x18>
    2ff7:	48 8b 0d 2a a7 00 00 	mov    rcx,QWORD PTR [rip+0xa72a]        # d728 <main_tls+0x8>
    2ffe:	48 8b 35 3b a7 00 00 	mov    rsi,QWORD PTR [rip+0xa73b]        # d740 <main_tls+0x20>
    3005:	e9 eb fd ff ff       	jmp    2df5 <__init_tls+0xd5>
    300a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
	size_t base = 0;
    3010:	4c 89 d9             	mov    rcx,r11
	Phdr *phdr, *tls_phdr=0;
    3013:	4c 89 dd             	mov    rbp,r11
				phdr->p_memsz : DEFAULT_STACK_MAX;
    3016:	41 bb 00 00 80 00    	mov    r11d,0x800000
    301c:	eb 1c                	jmp    303a <__init_tls+0x31a>
    301e:	66 90                	xchg   ax,ax
		if (phdr->p_type == PT_DYNAMIC && _DYNAMIC)
    3020:	83 fe 02             	cmp    esi,0x2
    3023:	74 08                	je     302d <__init_tls+0x30d>
		if (phdr->p_type == PT_TLS)
    3025:	83 fe 07             	cmp    esi,0x7
    3028:	75 20                	jne    304a <__init_tls+0x32a>
    302a:	48 89 c5             	mov    rbp,rax
	for (p=(void *)aux[AT_PHDR],n=aux[AT_PHNUM]; n; n--,p+=aux[AT_PHENT]) {
    302d:	48 01 f8             	add    rax,rdi
    3030:	48 83 ea 01          	sub    rdx,0x1
    3034:	0f 84 6b fd ff ff    	je     2da5 <__init_tls+0x85>
		if (phdr->p_type == PT_PHDR)
    303a:	8b 30                	mov    esi,DWORD PTR [rax]
    303c:	83 fe 06             	cmp    esi,0x6
    303f:	75 df                	jne    3020 <__init_tls+0x300>
			base = aux[AT_PHDR] - phdr->p_vaddr;
    3041:	4c 89 c9             	mov    rcx,r9
    3044:	48 2b 48 10          	sub    rcx,QWORD PTR [rax+0x10]
		if (phdr->p_type == PT_GNU_STACK &&
    3048:	eb e3                	jmp    302d <__init_tls+0x30d>
    304a:	81 fe 51 e5 74 64    	cmp    esi,0x6474e551
    3050:	75 db                	jne    302d <__init_tls+0x30d>
		    phdr->p_memsz > __default_stacksize)
    3052:	48 8b 70 28          	mov    rsi,QWORD PTR [rax+0x28]
    3056:	45 89 c2             	mov    r10d,r8d
		if (phdr->p_type == PT_GNU_STACK &&
    3059:	49 39 f2             	cmp    r10,rsi
    305c:	73 cf                	jae    302d <__init_tls+0x30d>
				phdr->p_memsz : DEFAULT_STACK_MAX;
    305e:	48 81 fe 00 00 80 00 	cmp    rsi,0x800000
			__default_stacksize =
    3065:	bb 01 00 00 00       	mov    ebx,0x1
    306a:	49 0f 47 f3          	cmova  rsi,r11
    306e:	49 89 f0             	mov    r8,rsi
    3071:	eb ba                	jmp    302d <__init_tls+0x30d>
    3073:	66 2e 0f 1f 84 00 00 00 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
    307d:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000003080 <__errno_location>:

static inline struct pthread *__pthread_self()
{
	struct pthread *self;
	__asm__ ("mov %%fs:0,%0" : "=r" (self) );
    3080:	64 48 8b 04 25 00 00 00 00 	mov    rax,QWORD PTR fs:0x0
#include <errno.h>
#include "pthread_impl.h"

int *__errno_location(void)
{
	return &__pthread_self()->errno_val;
    3089:	48 83 c0 3c          	add    rax,0x3c
}
    308d:	c3                   	ret    
    308e:	66 90                	xchg   ax,ax

0000000000003090 <__syscall_ret>:
#include <errno.h>
#include "syscall.h"

long __syscall_ret(unsigned long r)
{
	if (r > -4096UL) {
    3090:	48 81 ff 00 f0 ff ff 	cmp    rdi,0xfffffffffffff000
    3097:	77 07                	ja     30a0 <__syscall_ret+0x10>
		errno = -r;
		return -1;
	}
	return r;
    3099:	48 89 f8             	mov    rax,rdi
}
    309c:	c3                   	ret    
    309d:	0f 1f 00             	nop    DWORD PTR [rax]
{
    30a0:	48 83 ec 18          	sub    rsp,0x18
    30a4:	48 89 7c 24 08       	mov    QWORD PTR [rsp+0x8],rdi
		errno = -r;
    30a9:	e8 d2 ff ff ff       	call   3080 <__errno_location>
    30ae:	48 8b 7c 24 08       	mov    rdi,QWORD PTR [rsp+0x8]
    30b3:	f7 df                	neg    edi
    30b5:	89 38                	mov    DWORD PTR [rax],edi
		return -1;
    30b7:	48 c7 c0 ff ff ff ff 	mov    rax,0xffffffffffffffff
}
    30be:	48 83 c4 18          	add    rsp,0x18
    30c2:	c3                   	ret    
    30c3:	66 2e 0f 1f 84 00 00 00 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
    30cd:	0f 1f 00             	nop    DWORD PTR [rax]

00000000000030d0 <__expand_heap>:
{
	static uintptr_t brk;
	static unsigned mmap_step;
	size_t n = *pn;

	if (n > SIZE_MAX/2 - PAGE_SIZE) {
    30d0:	48 ba ff ef ff ff ff ff ff 7f 	movabs rdx,0x7fffffffffffefff
{
    30da:	55                   	push   rbp
    30db:	53                   	push   rbx
    30dc:	48 83 ec 18          	sub    rsp,0x18
	size_t n = *pn;
    30e0:	48 8b 07             	mov    rax,QWORD PTR [rdi]
	if (n > SIZE_MAX/2 - PAGE_SIZE) {
    30e3:	48 39 d0             	cmp    rax,rdx
    30e6:	0f 87 34 01 00 00    	ja     3220 <__expand_heap+0x150>
		errno = ENOMEM;
		return 0;
	}
	n += -n & PAGE_SIZE-1;
    30ec:	48 89 c3             	mov    rbx,rax
    30ef:	48 89 fd             	mov    rbp,rdi
    30f2:	48 f7 db             	neg    rbx
    30f5:	81 e3 ff 0f 00 00    	and    ebx,0xfff
    30fb:	48 01 c3             	add    rbx,rax

	if (!brk) {
    30fe:	48 8b 05 cb a7 00 00 	mov    rax,QWORD PTR [rip+0xa7cb]        # d8d0 <brk.2213>
    3105:	48 85 c0             	test   rax,rax
    3108:	0f 84 e2 00 00 00    	je     31f0 <__expand_heap+0x120>
		brk = __syscall(SYS_brk, 0);
		brk += -brk & PAGE_SIZE-1;
	}

	if (n < SIZE_MAX-brk && !traverses_stack_p(brk, brk+n)
    310e:	48 89 c2             	mov    rdx,rax
    3111:	48 f7 d2             	not    rdx
    3114:	48 39 da             	cmp    rdx,rbx
    3117:	76 2c                	jbe    3145 <__expand_heap+0x75>
	b = (uintptr_t)libc.auxv;
    3119:	48 8b 0d 10 9f 00 00 	mov    rcx,QWORD PTR [rip+0x9f10]        # d030 <__libc+0x10>
	a = b > len ? b-len : 0;
    3120:	ba 00 00 80 00       	mov    edx,0x800000
	if (n < SIZE_MAX-brk && !traverses_stack_p(brk, brk+n)
    3125:	48 8d 34 03          	lea    rsi,[rbx+rax*1]
	a = b > len ? b-len : 0;
    3129:	48 81 f9 00 00 80 00 	cmp    rcx,0x800000
    3130:	48 0f 43 d1          	cmovae rdx,rcx
    3134:	48 81 ea 00 00 80 00 	sub    rdx,0x800000
	if (new>a && old<b) return 1;
    313b:	48 39 d6             	cmp    rsi,rdx
    313e:	76 58                	jbe    3198 <__expand_heap+0xc8>
    3140:	48 39 c1             	cmp    rcx,rax
    3143:	76 53                	jbe    3198 <__expand_heap+0xc8>
		*pn = n;
		brk += n;
		return (void *)(brk-n);
	}

	size_t min = (size_t)PAGE_SIZE << mmap_step/2;
    3145:	8b 0d 7d a7 00 00    	mov    ecx,DWORD PTR [rip+0xa77d]        # d8c8 <mmap_step.2214>
    314b:	b8 00 10 00 00       	mov    eax,0x1000
	if (n < min) n = min;
	void *area = __mmap(0, n, PROT_READ|PROT_WRITE,
    3150:	41 b8 ff ff ff ff    	mov    r8d,0xffffffff
    3156:	ba 03 00 00 00       	mov    edx,0x3
	size_t min = (size_t)PAGE_SIZE << mmap_step/2;
    315b:	d1 e9                	shr    ecx,1
    315d:	48 d3 e0             	shl    rax,cl
	void *area = __mmap(0, n, PROT_READ|PROT_WRITE,
    3160:	b9 22 00 00 00       	mov    ecx,0x22
    3165:	48 39 d8             	cmp    rax,rbx
    3168:	48 0f 43 d8          	cmovae rbx,rax
    316c:	45 31 c9             	xor    r9d,r9d
    316f:	31 ff                	xor    edi,edi
    3171:	48 89 de             	mov    rsi,rbx
    3174:	e8 b7 ea ff ff       	call   1c30 <__mmap>
		MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);
	if (area == MAP_FAILED) return 0;
    3179:	48 83 f8 ff          	cmp    rax,0xffffffffffffffff
    317d:	0f 84 b5 00 00 00    	je     3238 <__expand_heap+0x168>
	*pn = n;
	mmap_step++;
    3183:	83 05 3e a7 00 00 01 	add    DWORD PTR [rip+0xa73e],0x1        # d8c8 <mmap_step.2214>
	*pn = n;
    318a:	48 89 5d 00          	mov    QWORD PTR [rbp+0x0],rbx
	return area;
}
    318e:	48 83 c4 18          	add    rsp,0x18
    3192:	5b                   	pop    rbx
    3193:	5d                   	pop    rbp
    3194:	c3                   	ret    
    3195:	0f 1f 00             	nop    DWORD PTR [rax]
	b = (uintptr_t)&b;
    3198:	48 8d 4c 24 08       	lea    rcx,[rsp+0x8]
	a = b > len ? b-len : 0;
    319d:	ba 00 00 80 00       	mov    edx,0x800000
    31a2:	48 81 f9 00 00 80 00 	cmp    rcx,0x800000
    31a9:	48 0f 43 d1          	cmovae rdx,rcx
    31ad:	48 81 ea 00 00 80 00 	sub    rdx,0x800000
	if (new>a && old<b) return 1;
    31b4:	48 39 d6             	cmp    rsi,rdx
    31b7:	76 05                	jbe    31be <__expand_heap+0xee>
    31b9:	48 39 c1             	cmp    rcx,rax
    31bc:	77 87                	ja     3145 <__expand_heap+0x75>
	    && __syscall(SYS_brk, brk+n)==brk+n) {
    31be:	bf 0c 00 00 00       	mov    edi,0xc
    31c3:	e8 18 f5 ff ff       	call   26e0 <__syscall1>
    31c8:	48 89 c2             	mov    rdx,rax
    31cb:	48 8b 05 fe a6 00 00 	mov    rax,QWORD PTR [rip+0xa6fe]        # d8d0 <brk.2213>
    31d2:	48 8d 0c 18          	lea    rcx,[rax+rbx*1]
    31d6:	48 39 ca             	cmp    rdx,rcx
    31d9:	0f 85 66 ff ff ff    	jne    3145 <__expand_heap+0x75>
		*pn = n;
    31df:	48 89 5d 00          	mov    QWORD PTR [rbp+0x0],rbx
		brk += n;
    31e3:	48 89 15 e6 a6 00 00 	mov    QWORD PTR [rip+0xa6e6],rdx        # d8d0 <brk.2213>
		return (void *)(brk-n);
    31ea:	eb a2                	jmp    318e <__expand_heap+0xbe>
    31ec:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
		brk = __syscall(SYS_brk, 0);
    31f0:	31 f6                	xor    esi,esi
    31f2:	bf 0c 00 00 00       	mov    edi,0xc
    31f7:	e8 e4 f4 ff ff       	call   26e0 <__syscall1>
    31fc:	48 89 c2             	mov    rdx,rax
		brk += -brk & PAGE_SIZE-1;
    31ff:	48 f7 d8             	neg    rax
    3202:	25 ff 0f 00 00       	and    eax,0xfff
    3207:	48 01 d0             	add    rax,rdx
    320a:	48 89 05 bf a6 00 00 	mov    QWORD PTR [rip+0xa6bf],rax        # d8d0 <brk.2213>
    3211:	e9 f8 fe ff ff       	jmp    310e <__expand_heap+0x3e>
    3216:	66 2e 0f 1f 84 00 00 00 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
		errno = ENOMEM;
    3220:	e8 5b fe ff ff       	call   3080 <__errno_location>
    3225:	c7 00 0c 00 00 00    	mov    DWORD PTR [rax],0xc
}
    322b:	48 83 c4 18          	add    rsp,0x18
		return 0;
    322f:	31 c0                	xor    eax,eax
}
    3231:	5b                   	pop    rbx
    3232:	5d                   	pop    rbp
    3233:	c3                   	ret    
    3234:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
	if (area == MAP_FAILED) return 0;
    3238:	31 c0                	xor    eax,eax
    323a:	e9 4f ff ff ff       	jmp    318e <__expand_heap+0xbe>
    323f:	90                   	nop

0000000000003240 <perception::linux_syscalls::_sysctl()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long _sysctl() {
    3240:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call _sysctl is unimplemented.\n";
    3244:	be 10 8e 00 00       	mov    esi,0x8e10
    3249:	bf d8 d8 00 00       	mov    edi,0xd8d8
    324e:	e8 2d 2d 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    3253:	31 c0                	xor    eax,eax
    3255:	48 83 c4 08          	add    rsp,0x8
    3259:	c3                   	ret    
    325a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000003260 <perception::linux_syscalls::accept()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long accept() {
    3260:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call accept is unimplemented.\n";
    3264:	be 38 8e 00 00       	mov    esi,0x8e38
    3269:	bf d8 d8 00 00       	mov    edi,0xd8d8
    326e:	e8 0d 2d 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    3273:	31 c0                	xor    eax,eax
    3275:	48 83 c4 08          	add    rsp,0x8
    3279:	c3                   	ret    
    327a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000003280 <perception::linux_syscalls::accept4()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long accept4() {
    3280:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call accept4 is unimplemented.\n";
    3284:	be 60 8e 00 00       	mov    esi,0x8e60
    3289:	bf d8 d8 00 00       	mov    edi,0xd8d8
    328e:	e8 ed 2c 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    3293:	31 c0                	xor    eax,eax
    3295:	48 83 c4 08          	add    rsp,0x8
    3299:	c3                   	ret    
    329a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

00000000000032a0 <perception::linux_syscalls::access()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long access() {
    32a0:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call access is unimplemented.\n";
    32a4:	be 88 8e 00 00       	mov    esi,0x8e88
    32a9:	bf d8 d8 00 00       	mov    edi,0xd8d8
    32ae:	e8 cd 2c 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    32b3:	31 c0                	xor    eax,eax
    32b5:	48 83 c4 08          	add    rsp,0x8
    32b9:	c3                   	ret    
    32ba:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

00000000000032c0 <perception::linux_syscalls::acct()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long acct() {
    32c0:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call acct is unimplemented.\n";
    32c4:	be b0 8e 00 00       	mov    esi,0x8eb0
    32c9:	bf d8 d8 00 00       	mov    edi,0xd8d8
    32ce:	e8 ad 2c 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    32d3:	31 c0                	xor    eax,eax
    32d5:	48 83 c4 08          	add    rsp,0x8
    32d9:	c3                   	ret    
    32da:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

00000000000032e0 <perception::linux_syscalls::add_key()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long add_key() {
    32e0:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call add_key is unimplemented.\n";
    32e4:	be d8 8e 00 00       	mov    esi,0x8ed8
    32e9:	bf d8 d8 00 00       	mov    edi,0xd8d8
    32ee:	e8 8d 2c 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    32f3:	31 c0                	xor    eax,eax
    32f5:	48 83 c4 08          	add    rsp,0x8
    32f9:	c3                   	ret    
    32fa:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000003300 <perception::linux_syscalls::adjtimex()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long adjtimex() {
    3300:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call adjtimex is unimplemented.\n";
    3304:	be 00 8f 00 00       	mov    esi,0x8f00
    3309:	bf d8 d8 00 00       	mov    edi,0xd8d8
    330e:	e8 6d 2c 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    3313:	31 c0                	xor    eax,eax
    3315:	48 83 c4 08          	add    rsp,0x8
    3319:	c3                   	ret    
    331a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000003320 <perception::linux_syscalls::afs_syscall()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long afs_syscall() {
    3320:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call afs_syscall is unimplemented.\n";
    3324:	be 28 8f 00 00       	mov    esi,0x8f28
    3329:	bf d8 d8 00 00       	mov    edi,0xd8d8
    332e:	e8 4d 2c 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    3333:	31 c0                	xor    eax,eax
    3335:	48 83 c4 08          	add    rsp,0x8
    3339:	c3                   	ret    
    333a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000003340 <perception::linux_syscalls::alarm()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long alarm() {
    3340:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call alarm is unimplemented.\n";
    3344:	be 58 8f 00 00       	mov    esi,0x8f58
    3349:	bf d8 d8 00 00       	mov    edi,0xd8d8
    334e:	e8 2d 2c 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    3353:	31 c0                	xor    eax,eax
    3355:	48 83 c4 08          	add    rsp,0x8
    3359:	c3                   	ret    
    335a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000003360 <perception::linux_syscalls::arch_prctl()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long arch_prctl() {
    3360:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call arch_prctl is unimplemented.\n";
    3364:	be 80 8f 00 00       	mov    esi,0x8f80
    3369:	bf d8 d8 00 00       	mov    edi,0xd8d8
    336e:	e8 0d 2c 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    3373:	31 c0                	xor    eax,eax
    3375:	48 83 c4 08          	add    rsp,0x8
    3379:	c3                   	ret    
    337a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000003380 <perception::linux_syscalls::bind()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long bind() {
    3380:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call bind is unimplemented.\n";
    3384:	be b0 8f 00 00       	mov    esi,0x8fb0
    3389:	bf d8 d8 00 00       	mov    edi,0xd8d8
    338e:	e8 ed 2b 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    3393:	31 c0                	xor    eax,eax
    3395:	48 83 c4 08          	add    rsp,0x8
    3399:	c3                   	ret    
    339a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

00000000000033a0 <perception::linux_syscalls::bpf()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long bpf() {
    33a0:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call bpf is unimplemented.\n";
    33a4:	be d8 8f 00 00       	mov    esi,0x8fd8
    33a9:	bf d8 d8 00 00       	mov    edi,0xd8d8
    33ae:	e8 cd 2b 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    33b3:	31 c0                	xor    eax,eax
    33b5:	48 83 c4 08          	add    rsp,0x8
    33b9:	c3                   	ret    
    33ba:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

00000000000033c0 <perception::linux_syscalls::brk()>:
namespace perception {
namespace linux_syscalls {

long brk() {
	// We don't support brk, instead use mmap.
	return __syscall_ret(-ENOSYS);
    33c0:	48 c7 c7 da ff ff ff 	mov    rdi,0xffffffffffffffda
    33c7:	e9 c4 fc ff ff       	jmp    3090 <__syscall_ret>
    33cc:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

00000000000033d0 <perception::linux_syscalls::capget()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long capget() {
    33d0:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call capget is unimplemented.\n";
    33d4:	be 00 90 00 00       	mov    esi,0x9000
    33d9:	bf d8 d8 00 00       	mov    edi,0xd8d8
    33de:	e8 9d 2b 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    33e3:	31 c0                	xor    eax,eax
    33e5:	48 83 c4 08          	add    rsp,0x8
    33e9:	c3                   	ret    
    33ea:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

00000000000033f0 <perception::linux_syscalls::capset()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long capset() {
    33f0:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call capset is unimplemented.\n";
    33f4:	be 28 90 00 00       	mov    esi,0x9028
    33f9:	bf d8 d8 00 00       	mov    edi,0xd8d8
    33fe:	e8 7d 2b 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    3403:	31 c0                	xor    eax,eax
    3405:	48 83 c4 08          	add    rsp,0x8
    3409:	c3                   	ret    
    340a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000003410 <perception::linux_syscalls::chdir()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long chdir() {
    3410:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call chdir is unimplemented.\n";
    3414:	be 50 90 00 00       	mov    esi,0x9050
    3419:	bf d8 d8 00 00       	mov    edi,0xd8d8
    341e:	e8 5d 2b 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    3423:	31 c0                	xor    eax,eax
    3425:	48 83 c4 08          	add    rsp,0x8
    3429:	c3                   	ret    
    342a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000003430 <perception::linux_syscalls::chmod()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long chmod() {
    3430:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call chmod is unimplemented.\n";
    3434:	be 78 90 00 00       	mov    esi,0x9078
    3439:	bf d8 d8 00 00       	mov    edi,0xd8d8
    343e:	e8 3d 2b 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    3443:	31 c0                	xor    eax,eax
    3445:	48 83 c4 08          	add    rsp,0x8
    3449:	c3                   	ret    
    344a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000003450 <perception::linux_syscalls::chown()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long chown() {
    3450:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call chown is unimplemented.\n";
    3454:	be a0 90 00 00       	mov    esi,0x90a0
    3459:	bf d8 d8 00 00       	mov    edi,0xd8d8
    345e:	e8 1d 2b 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    3463:	31 c0                	xor    eax,eax
    3465:	48 83 c4 08          	add    rsp,0x8
    3469:	c3                   	ret    
    346a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000003470 <perception::linux_syscalls::chroot()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long chroot() {
    3470:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call chroot is unimplemented.\n";
    3474:	be c8 90 00 00       	mov    esi,0x90c8
    3479:	bf d8 d8 00 00       	mov    edi,0xd8d8
    347e:	e8 fd 2a 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    3483:	31 c0                	xor    eax,eax
    3485:	48 83 c4 08          	add    rsp,0x8
    3489:	c3                   	ret    
    348a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000003490 <perception::linux_syscalls::clock_adjtime()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long clock_adjtime() {
    3490:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call clock_adjtime is unimplemented.\n";
    3494:	be f0 90 00 00       	mov    esi,0x90f0
    3499:	bf d8 d8 00 00       	mov    edi,0xd8d8
    349e:	e8 dd 2a 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    34a3:	31 c0                	xor    eax,eax
    34a5:	48 83 c4 08          	add    rsp,0x8
    34a9:	c3                   	ret    
    34aa:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

00000000000034b0 <perception::linux_syscalls::clock_getres()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long clock_getres() {
    34b0:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call clock_getres is unimplemented.\n";
    34b4:	be 20 91 00 00       	mov    esi,0x9120
    34b9:	bf d8 d8 00 00       	mov    edi,0xd8d8
    34be:	e8 bd 2a 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    34c3:	31 c0                	xor    eax,eax
    34c5:	48 83 c4 08          	add    rsp,0x8
    34c9:	c3                   	ret    
    34ca:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

00000000000034d0 <perception::linux_syscalls::clock_gettime()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long clock_gettime() {
    34d0:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call clock_gettime is unimplemented.\n";
    34d4:	be 50 91 00 00       	mov    esi,0x9150
    34d9:	bf d8 d8 00 00       	mov    edi,0xd8d8
    34de:	e8 9d 2a 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    34e3:	31 c0                	xor    eax,eax
    34e5:	48 83 c4 08          	add    rsp,0x8
    34e9:	c3                   	ret    
    34ea:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

00000000000034f0 <perception::linux_syscalls::clock_nanosleep()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long clock_nanosleep() {
    34f0:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call clock_nanosleep is unimplemented.\n";
    34f4:	be 80 91 00 00       	mov    esi,0x9180
    34f9:	bf d8 d8 00 00       	mov    edi,0xd8d8
    34fe:	e8 7d 2a 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    3503:	31 c0                	xor    eax,eax
    3505:	48 83 c4 08          	add    rsp,0x8
    3509:	c3                   	ret    
    350a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000003510 <perception::linux_syscalls::clock_settime()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long clock_settime() {
    3510:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call clock_settime is unimplemented.\n";
    3514:	be b0 91 00 00       	mov    esi,0x91b0
    3519:	bf d8 d8 00 00       	mov    edi,0xd8d8
    351e:	e8 5d 2a 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    3523:	31 c0                	xor    eax,eax
    3525:	48 83 c4 08          	add    rsp,0x8
    3529:	c3                   	ret    
    352a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000003530 <perception::linux_syscalls::clone()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long clone() {
    3530:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call clone is unimplemented.\n";
    3534:	be e0 91 00 00       	mov    esi,0x91e0
    3539:	bf d8 d8 00 00       	mov    edi,0xd8d8
    353e:	e8 3d 2a 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    3543:	31 c0                	xor    eax,eax
    3545:	48 83 c4 08          	add    rsp,0x8
    3549:	c3                   	ret    
    354a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000003550 <perception::linux_syscalls::clone3()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long clone3() {
    3550:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call clone3 is unimplemented.\n";
    3554:	be 08 92 00 00       	mov    esi,0x9208
    3559:	bf d8 d8 00 00       	mov    edi,0xd8d8
    355e:	e8 1d 2a 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    3563:	31 c0                	xor    eax,eax
    3565:	48 83 c4 08          	add    rsp,0x8
    3569:	c3                   	ret    
    356a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000003570 <perception::linux_syscalls::close()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long close() {
    3570:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call close is unimplemented.\n";
    3574:	be 30 92 00 00       	mov    esi,0x9230
    3579:	bf d8 d8 00 00       	mov    edi,0xd8d8
    357e:	e8 fd 29 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    3583:	31 c0                	xor    eax,eax
    3585:	48 83 c4 08          	add    rsp,0x8
    3589:	c3                   	ret    
    358a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000003590 <perception::linux_syscalls::connect()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long connect() {
    3590:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call connect is unimplemented.\n";
    3594:	be 58 92 00 00       	mov    esi,0x9258
    3599:	bf d8 d8 00 00       	mov    edi,0xd8d8
    359e:	e8 dd 29 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    35a3:	31 c0                	xor    eax,eax
    35a5:	48 83 c4 08          	add    rsp,0x8
    35a9:	c3                   	ret    
    35aa:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

00000000000035b0 <perception::linux_syscalls::copy_file_range()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long copy_file_range() {
    35b0:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call copy_file_range is unimplemented.\n";
    35b4:	be 80 92 00 00       	mov    esi,0x9280
    35b9:	bf d8 d8 00 00       	mov    edi,0xd8d8
    35be:	e8 bd 29 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    35c3:	31 c0                	xor    eax,eax
    35c5:	48 83 c4 08          	add    rsp,0x8
    35c9:	c3                   	ret    
    35ca:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

00000000000035d0 <perception::linux_syscalls::creat()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long creat() {
    35d0:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call creat is unimplemented.\n";
    35d4:	be b0 92 00 00       	mov    esi,0x92b0
    35d9:	bf d8 d8 00 00       	mov    edi,0xd8d8
    35de:	e8 9d 29 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    35e3:	31 c0                	xor    eax,eax
    35e5:	48 83 c4 08          	add    rsp,0x8
    35e9:	c3                   	ret    
    35ea:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

00000000000035f0 <perception::linux_syscalls::create_module()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long create_module() {
    35f0:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call create_module is unimplemented.\n";
    35f4:	be d8 92 00 00       	mov    esi,0x92d8
    35f9:	bf d8 d8 00 00       	mov    edi,0xd8d8
    35fe:	e8 7d 29 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    3603:	31 c0                	xor    eax,eax
    3605:	48 83 c4 08          	add    rsp,0x8
    3609:	c3                   	ret    
    360a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000003610 <perception::linux_syscalls::delete_module()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long delete_module() {
    3610:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call delete_module is unimplemented.\n";
    3614:	be 08 93 00 00       	mov    esi,0x9308
    3619:	bf d8 d8 00 00       	mov    edi,0xd8d8
    361e:	e8 5d 29 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    3623:	31 c0                	xor    eax,eax
    3625:	48 83 c4 08          	add    rsp,0x8
    3629:	c3                   	ret    
    362a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000003630 <perception::linux_syscalls::dup()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long dup() {
    3630:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call dup is unimplemented.\n";
    3634:	be 38 93 00 00       	mov    esi,0x9338
    3639:	bf d8 d8 00 00       	mov    edi,0xd8d8
    363e:	e8 3d 29 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    3643:	31 c0                	xor    eax,eax
    3645:	48 83 c4 08          	add    rsp,0x8
    3649:	c3                   	ret    
    364a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000003650 <perception::linux_syscalls::dup2()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long dup2() {
    3650:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call dup2 is unimplemented.\n";
    3654:	be 60 93 00 00       	mov    esi,0x9360
    3659:	bf d8 d8 00 00       	mov    edi,0xd8d8
    365e:	e8 1d 29 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    3663:	31 c0                	xor    eax,eax
    3665:	48 83 c4 08          	add    rsp,0x8
    3669:	c3                   	ret    
    366a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000003670 <perception::linux_syscalls::dup3()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long dup3() {
    3670:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call dup3 is unimplemented.\n";
    3674:	be 88 93 00 00       	mov    esi,0x9388
    3679:	bf d8 d8 00 00       	mov    edi,0xd8d8
    367e:	e8 fd 28 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    3683:	31 c0                	xor    eax,eax
    3685:	48 83 c4 08          	add    rsp,0x8
    3689:	c3                   	ret    
    368a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000003690 <perception::linux_syscalls::epoll_create()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long epoll_create() {
    3690:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call epoll_create is unimplemented.\n";
    3694:	be b0 93 00 00       	mov    esi,0x93b0
    3699:	bf d8 d8 00 00       	mov    edi,0xd8d8
    369e:	e8 dd 28 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    36a3:	31 c0                	xor    eax,eax
    36a5:	48 83 c4 08          	add    rsp,0x8
    36a9:	c3                   	ret    
    36aa:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

00000000000036b0 <perception::linux_syscalls::epoll_create1()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long epoll_create1() {
    36b0:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call epoll_create1 is unimplemented.\n";
    36b4:	be e0 93 00 00       	mov    esi,0x93e0
    36b9:	bf d8 d8 00 00       	mov    edi,0xd8d8
    36be:	e8 bd 28 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    36c3:	31 c0                	xor    eax,eax
    36c5:	48 83 c4 08          	add    rsp,0x8
    36c9:	c3                   	ret    
    36ca:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

00000000000036d0 <perception::linux_syscalls::epoll_ctl()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long epoll_ctl() {
    36d0:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call epoll_ctl is unimplemented.\n";
    36d4:	be 10 94 00 00       	mov    esi,0x9410
    36d9:	bf d8 d8 00 00       	mov    edi,0xd8d8
    36de:	e8 9d 28 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    36e3:	31 c0                	xor    eax,eax
    36e5:	48 83 c4 08          	add    rsp,0x8
    36e9:	c3                   	ret    
    36ea:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

00000000000036f0 <perception::linux_syscalls::epoll_ctl_old()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long epoll_ctl_old() {
    36f0:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call epoll_ctl_old is unimplemented.\n";
    36f4:	be 40 94 00 00       	mov    esi,0x9440
    36f9:	bf d8 d8 00 00       	mov    edi,0xd8d8
    36fe:	e8 7d 28 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    3703:	31 c0                	xor    eax,eax
    3705:	48 83 c4 08          	add    rsp,0x8
    3709:	c3                   	ret    
    370a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000003710 <perception::linux_syscalls::epoll_pwait()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long epoll_pwait() {
    3710:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call epoll_pwait is unimplemented.\n";
    3714:	be 70 94 00 00       	mov    esi,0x9470
    3719:	bf d8 d8 00 00       	mov    edi,0xd8d8
    371e:	e8 5d 28 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    3723:	31 c0                	xor    eax,eax
    3725:	48 83 c4 08          	add    rsp,0x8
    3729:	c3                   	ret    
    372a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000003730 <perception::linux_syscalls::epoll_wait()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long epoll_wait() {
    3730:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call epoll_wait is unimplemented.\n";
    3734:	be a0 94 00 00       	mov    esi,0x94a0
    3739:	bf d8 d8 00 00       	mov    edi,0xd8d8
    373e:	e8 3d 28 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    3743:	31 c0                	xor    eax,eax
    3745:	48 83 c4 08          	add    rsp,0x8
    3749:	c3                   	ret    
    374a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000003750 <perception::linux_syscalls::epoll_wait_old()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long epoll_wait_old() {
    3750:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call epoll_wait_old is unimplemented.\n";
    3754:	be d0 94 00 00       	mov    esi,0x94d0
    3759:	bf d8 d8 00 00       	mov    edi,0xd8d8
    375e:	e8 1d 28 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    3763:	31 c0                	xor    eax,eax
    3765:	48 83 c4 08          	add    rsp,0x8
    3769:	c3                   	ret    
    376a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000003770 <perception::linux_syscalls::eventfd()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long eventfd() {
    3770:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call eventfd is unimplemented.\n";
    3774:	be 00 95 00 00       	mov    esi,0x9500
    3779:	bf d8 d8 00 00       	mov    edi,0xd8d8
    377e:	e8 fd 27 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    3783:	31 c0                	xor    eax,eax
    3785:	48 83 c4 08          	add    rsp,0x8
    3789:	c3                   	ret    
    378a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000003790 <perception::linux_syscalls::eventfd2()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long eventfd2() {
    3790:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call eventfd2 is unimplemented.\n";
    3794:	be 28 95 00 00       	mov    esi,0x9528
    3799:	bf d8 d8 00 00       	mov    edi,0xd8d8
    379e:	e8 dd 27 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    37a3:	31 c0                	xor    eax,eax
    37a5:	48 83 c4 08          	add    rsp,0x8
    37a9:	c3                   	ret    
    37aa:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

00000000000037b0 <perception::linux_syscalls::execve()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long execve() {
    37b0:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call execve is unimplemented.\n";
    37b4:	be 50 95 00 00       	mov    esi,0x9550
    37b9:	bf d8 d8 00 00       	mov    edi,0xd8d8
    37be:	e8 bd 27 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    37c3:	31 c0                	xor    eax,eax
    37c5:	48 83 c4 08          	add    rsp,0x8
    37c9:	c3                   	ret    
    37ca:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

00000000000037d0 <perception::linux_syscalls::execveat()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long execveat() {
    37d0:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call execveat is unimplemented.\n";
    37d4:	be 78 95 00 00       	mov    esi,0x9578
    37d9:	bf d8 d8 00 00       	mov    edi,0xd8d8
    37de:	e8 9d 27 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    37e3:	31 c0                	xor    eax,eax
    37e5:	48 83 c4 08          	add    rsp,0x8
    37e9:	c3                   	ret    
    37ea:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

00000000000037f0 <perception::linux_syscalls::exit()>:
#include "perception/threads.h"

namespace perception {
namespace linux_syscalls {

long exit() {
    37f0:	48 83 ec 08          	sub    rsp,0x8
	// todo: Thread might have things wanting to run at exit.
	perception::TerminateThread();
    37f4:	e8 67 28 00 00       	call   6060 <perception::TerminateThread()>
	return 0;
}
    37f9:	31 c0                	xor    eax,eax
    37fb:	48 83 c4 08          	add    rsp,0x8
    37ff:	c3                   	ret    

0000000000003800 <perception::linux_syscalls::exit_group()>:
#include "perception/threads.h"

namespace perception {
namespace linux_syscalls {

long exit_group() {
    3800:	48 83 ec 08          	sub    rsp,0x8
	perception::TerminateProcess();
    3804:	e8 47 28 00 00       	call   6050 <perception::TerminateProcess()>
	return 0;
}
    3809:	31 c0                	xor    eax,eax
    380b:	48 83 c4 08          	add    rsp,0x8
    380f:	c3                   	ret    

0000000000003810 <perception::linux_syscalls::faccessat()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long faccessat() {
    3810:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call faccessat is unimplemented.\n";
    3814:	be a0 95 00 00       	mov    esi,0x95a0
    3819:	bf d8 d8 00 00       	mov    edi,0xd8d8
    381e:	e8 5d 27 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    3823:	31 c0                	xor    eax,eax
    3825:	48 83 c4 08          	add    rsp,0x8
    3829:	c3                   	ret    
    382a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000003830 <perception::linux_syscalls::fadvise64()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long fadvise64() {
    3830:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call fadvise64 is unimplemented.\n";
    3834:	be d0 95 00 00       	mov    esi,0x95d0
    3839:	bf d8 d8 00 00       	mov    edi,0xd8d8
    383e:	e8 3d 27 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    3843:	31 c0                	xor    eax,eax
    3845:	48 83 c4 08          	add    rsp,0x8
    3849:	c3                   	ret    
    384a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000003850 <perception::linux_syscalls::fallocate()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long fallocate() {
    3850:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call fallocate is unimplemented.\n";
    3854:	be 00 96 00 00       	mov    esi,0x9600
    3859:	bf d8 d8 00 00       	mov    edi,0xd8d8
    385e:	e8 1d 27 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    3863:	31 c0                	xor    eax,eax
    3865:	48 83 c4 08          	add    rsp,0x8
    3869:	c3                   	ret    
    386a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000003870 <perception::linux_syscalls::fanotify_init()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long fanotify_init() {
    3870:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call fanotify_init is unimplemented.\n";
    3874:	be 30 96 00 00       	mov    esi,0x9630
    3879:	bf d8 d8 00 00       	mov    edi,0xd8d8
    387e:	e8 fd 26 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    3883:	31 c0                	xor    eax,eax
    3885:	48 83 c4 08          	add    rsp,0x8
    3889:	c3                   	ret    
    388a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000003890 <perception::linux_syscalls::fanotify_mark()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long fanotify_mark() {
    3890:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call fanotify_mark is unimplemented.\n";
    3894:	be 60 96 00 00       	mov    esi,0x9660
    3899:	bf d8 d8 00 00       	mov    edi,0xd8d8
    389e:	e8 dd 26 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    38a3:	31 c0                	xor    eax,eax
    38a5:	48 83 c4 08          	add    rsp,0x8
    38a9:	c3                   	ret    
    38aa:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

00000000000038b0 <perception::linux_syscalls::fchdir()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long fchdir() {
    38b0:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call fchdir is unimplemented.\n";
    38b4:	be 90 96 00 00       	mov    esi,0x9690
    38b9:	bf d8 d8 00 00       	mov    edi,0xd8d8
    38be:	e8 bd 26 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    38c3:	31 c0                	xor    eax,eax
    38c5:	48 83 c4 08          	add    rsp,0x8
    38c9:	c3                   	ret    
    38ca:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

00000000000038d0 <perception::linux_syscalls::fchmod()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long fchmod() {
    38d0:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call fchmod is unimplemented.\n";
    38d4:	be b8 96 00 00       	mov    esi,0x96b8
    38d9:	bf d8 d8 00 00       	mov    edi,0xd8d8
    38de:	e8 9d 26 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    38e3:	31 c0                	xor    eax,eax
    38e5:	48 83 c4 08          	add    rsp,0x8
    38e9:	c3                   	ret    
    38ea:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

00000000000038f0 <perception::linux_syscalls::fchmodat()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long fchmodat() {
    38f0:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call fchmodat is unimplemented.\n";
    38f4:	be e0 96 00 00       	mov    esi,0x96e0
    38f9:	bf d8 d8 00 00       	mov    edi,0xd8d8
    38fe:	e8 7d 26 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    3903:	31 c0                	xor    eax,eax
    3905:	48 83 c4 08          	add    rsp,0x8
    3909:	c3                   	ret    
    390a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000003910 <perception::linux_syscalls::fchown()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long fchown() {
    3910:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call fchown is unimplemented.\n";
    3914:	be 08 97 00 00       	mov    esi,0x9708
    3919:	bf d8 d8 00 00       	mov    edi,0xd8d8
    391e:	e8 5d 26 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    3923:	31 c0                	xor    eax,eax
    3925:	48 83 c4 08          	add    rsp,0x8
    3929:	c3                   	ret    
    392a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000003930 <perception::linux_syscalls::fchownat()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long fchownat() {
    3930:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call fchownat is unimplemented.\n";
    3934:	be 30 97 00 00       	mov    esi,0x9730
    3939:	bf d8 d8 00 00       	mov    edi,0xd8d8
    393e:	e8 3d 26 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    3943:	31 c0                	xor    eax,eax
    3945:	48 83 c4 08          	add    rsp,0x8
    3949:	c3                   	ret    
    394a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000003950 <perception::linux_syscalls::fcntl()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long fcntl() {
    3950:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call fcntl is unimplemented.\n";
    3954:	be 58 97 00 00       	mov    esi,0x9758
    3959:	bf d8 d8 00 00       	mov    edi,0xd8d8
    395e:	e8 1d 26 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    3963:	31 c0                	xor    eax,eax
    3965:	48 83 c4 08          	add    rsp,0x8
    3969:	c3                   	ret    
    396a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000003970 <perception::linux_syscalls::fdatasync()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long fdatasync() {
    3970:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call fdatasync is unimplemented.\n";
    3974:	be 80 97 00 00       	mov    esi,0x9780
    3979:	bf d8 d8 00 00       	mov    edi,0xd8d8
    397e:	e8 fd 25 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    3983:	31 c0                	xor    eax,eax
    3985:	48 83 c4 08          	add    rsp,0x8
    3989:	c3                   	ret    
    398a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000003990 <perception::linux_syscalls::fgetxattr()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long fgetxattr() {
    3990:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call fgetxattr is unimplemented.\n";
    3994:	be b0 97 00 00       	mov    esi,0x97b0
    3999:	bf d8 d8 00 00       	mov    edi,0xd8d8
    399e:	e8 dd 25 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    39a3:	31 c0                	xor    eax,eax
    39a5:	48 83 c4 08          	add    rsp,0x8
    39a9:	c3                   	ret    
    39aa:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

00000000000039b0 <perception::linux_syscalls::finit_module()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long finit_module() {
    39b0:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call finit_module is unimplemented.\n";
    39b4:	be e0 97 00 00       	mov    esi,0x97e0
    39b9:	bf d8 d8 00 00       	mov    edi,0xd8d8
    39be:	e8 bd 25 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    39c3:	31 c0                	xor    eax,eax
    39c5:	48 83 c4 08          	add    rsp,0x8
    39c9:	c3                   	ret    
    39ca:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

00000000000039d0 <perception::linux_syscalls::flistxattr()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long flistxattr() {
    39d0:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call flistxattr is unimplemented.\n";
    39d4:	be 10 98 00 00       	mov    esi,0x9810
    39d9:	bf d8 d8 00 00       	mov    edi,0xd8d8
    39de:	e8 9d 25 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    39e3:	31 c0                	xor    eax,eax
    39e5:	48 83 c4 08          	add    rsp,0x8
    39e9:	c3                   	ret    
    39ea:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

00000000000039f0 <perception::linux_syscalls::flock()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long flock() {
    39f0:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call flock is unimplemented.\n";
    39f4:	be 40 98 00 00       	mov    esi,0x9840
    39f9:	bf d8 d8 00 00       	mov    edi,0xd8d8
    39fe:	e8 7d 25 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    3a03:	31 c0                	xor    eax,eax
    3a05:	48 83 c4 08          	add    rsp,0x8
    3a09:	c3                   	ret    
    3a0a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000003a10 <perception::linux_syscalls::fork()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long fork() {
    3a10:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call fork is unimplemented.\n";
    3a14:	be 68 98 00 00       	mov    esi,0x9868
    3a19:	bf d8 d8 00 00       	mov    edi,0xd8d8
    3a1e:	e8 5d 25 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    3a23:	31 c0                	xor    eax,eax
    3a25:	48 83 c4 08          	add    rsp,0x8
    3a29:	c3                   	ret    
    3a2a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000003a30 <perception::linux_syscalls::fremovexattr()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long fremovexattr() {
    3a30:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call fremovexattr is unimplemented.\n";
    3a34:	be 90 98 00 00       	mov    esi,0x9890
    3a39:	bf d8 d8 00 00       	mov    edi,0xd8d8
    3a3e:	e8 3d 25 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    3a43:	31 c0                	xor    eax,eax
    3a45:	48 83 c4 08          	add    rsp,0x8
    3a49:	c3                   	ret    
    3a4a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000003a50 <perception::linux_syscalls::fsconfig()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long fsconfig() {
    3a50:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call fsconfig is unimplemented.\n";
    3a54:	be c0 98 00 00       	mov    esi,0x98c0
    3a59:	bf d8 d8 00 00       	mov    edi,0xd8d8
    3a5e:	e8 1d 25 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    3a63:	31 c0                	xor    eax,eax
    3a65:	48 83 c4 08          	add    rsp,0x8
    3a69:	c3                   	ret    
    3a6a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000003a70 <perception::linux_syscalls::fsetxattr()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long fsetxattr() {
    3a70:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call fsetxattr is unimplemented.\n";
    3a74:	be e8 98 00 00       	mov    esi,0x98e8
    3a79:	bf d8 d8 00 00       	mov    edi,0xd8d8
    3a7e:	e8 fd 24 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    3a83:	31 c0                	xor    eax,eax
    3a85:	48 83 c4 08          	add    rsp,0x8
    3a89:	c3                   	ret    
    3a8a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000003a90 <perception::linux_syscalls::fsmount()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long fsmount() {
    3a90:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call fsmount is unimplemented.\n";
    3a94:	be 18 99 00 00       	mov    esi,0x9918
    3a99:	bf d8 d8 00 00       	mov    edi,0xd8d8
    3a9e:	e8 dd 24 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    3aa3:	31 c0                	xor    eax,eax
    3aa5:	48 83 c4 08          	add    rsp,0x8
    3aa9:	c3                   	ret    
    3aaa:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000003ab0 <perception::linux_syscalls::fsopen()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long fsopen() {
    3ab0:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call fsopen is unimplemented.\n";
    3ab4:	be 40 99 00 00       	mov    esi,0x9940
    3ab9:	bf d8 d8 00 00       	mov    edi,0xd8d8
    3abe:	e8 bd 24 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    3ac3:	31 c0                	xor    eax,eax
    3ac5:	48 83 c4 08          	add    rsp,0x8
    3ac9:	c3                   	ret    
    3aca:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000003ad0 <perception::linux_syscalls::fspick()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long fspick() {
    3ad0:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call fspick is unimplemented.\n";
    3ad4:	be 68 99 00 00       	mov    esi,0x9968
    3ad9:	bf d8 d8 00 00       	mov    edi,0xd8d8
    3ade:	e8 9d 24 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    3ae3:	31 c0                	xor    eax,eax
    3ae5:	48 83 c4 08          	add    rsp,0x8
    3ae9:	c3                   	ret    
    3aea:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000003af0 <perception::linux_syscalls::fstat()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long fstat() {
    3af0:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call fstat is unimplemented.\n";
    3af4:	be 90 99 00 00       	mov    esi,0x9990
    3af9:	bf d8 d8 00 00       	mov    edi,0xd8d8
    3afe:	e8 7d 24 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    3b03:	31 c0                	xor    eax,eax
    3b05:	48 83 c4 08          	add    rsp,0x8
    3b09:	c3                   	ret    
    3b0a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000003b10 <perception::linux_syscalls::fstatfs()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long fstatfs() {
    3b10:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call fstatfs is unimplemented.\n";
    3b14:	be b8 99 00 00       	mov    esi,0x99b8
    3b19:	bf d8 d8 00 00       	mov    edi,0xd8d8
    3b1e:	e8 5d 24 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    3b23:	31 c0                	xor    eax,eax
    3b25:	48 83 c4 08          	add    rsp,0x8
    3b29:	c3                   	ret    
    3b2a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000003b30 <perception::linux_syscalls::fsync()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long fsync() {
    3b30:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call fsync is unimplemented.\n";
    3b34:	be e0 99 00 00       	mov    esi,0x99e0
    3b39:	bf d8 d8 00 00       	mov    edi,0xd8d8
    3b3e:	e8 3d 24 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    3b43:	31 c0                	xor    eax,eax
    3b45:	48 83 c4 08          	add    rsp,0x8
    3b49:	c3                   	ret    
    3b4a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000003b50 <perception::linux_syscalls::ftruncate()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long ftruncate() {
    3b50:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call ftruncate is unimplemented.\n";
    3b54:	be 08 9a 00 00       	mov    esi,0x9a08
    3b59:	bf d8 d8 00 00       	mov    edi,0xd8d8
    3b5e:	e8 1d 24 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    3b63:	31 c0                	xor    eax,eax
    3b65:	48 83 c4 08          	add    rsp,0x8
    3b69:	c3                   	ret    
    3b6a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000003b70 <perception::linux_syscalls::futex()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long futex() {
    3b70:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call futex is unimplemented.\n";
    3b74:	be 38 9a 00 00       	mov    esi,0x9a38
    3b79:	bf d8 d8 00 00       	mov    edi,0xd8d8
    3b7e:	e8 fd 23 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    3b83:	31 c0                	xor    eax,eax
    3b85:	48 83 c4 08          	add    rsp,0x8
    3b89:	c3                   	ret    
    3b8a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000003b90 <perception::linux_syscalls::futimesat()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long futimesat() {
    3b90:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call futimesat is unimplemented.\n";
    3b94:	be 60 9a 00 00       	mov    esi,0x9a60
    3b99:	bf d8 d8 00 00       	mov    edi,0xd8d8
    3b9e:	e8 dd 23 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    3ba3:	31 c0                	xor    eax,eax
    3ba5:	48 83 c4 08          	add    rsp,0x8
    3ba9:	c3                   	ret    
    3baa:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000003bb0 <perception::linux_syscalls::get_kernel_syms()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long get_kernel_syms() {
    3bb0:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call get_kernel_syms is unimplemented.\n";
    3bb4:	be 90 9a 00 00       	mov    esi,0x9a90
    3bb9:	bf d8 d8 00 00       	mov    edi,0xd8d8
    3bbe:	e8 bd 23 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    3bc3:	31 c0                	xor    eax,eax
    3bc5:	48 83 c4 08          	add    rsp,0x8
    3bc9:	c3                   	ret    
    3bca:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000003bd0 <perception::linux_syscalls::get_mempolicy()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long get_mempolicy() {
    3bd0:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call get_mempolicy is unimplemented.\n";
    3bd4:	be c0 9a 00 00       	mov    esi,0x9ac0
    3bd9:	bf d8 d8 00 00       	mov    edi,0xd8d8
    3bde:	e8 9d 23 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    3be3:	31 c0                	xor    eax,eax
    3be5:	48 83 c4 08          	add    rsp,0x8
    3be9:	c3                   	ret    
    3bea:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000003bf0 <perception::linux_syscalls::get_robust_list()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long get_robust_list() {
    3bf0:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call get_robust_list is unimplemented.\n";
    3bf4:	be f0 9a 00 00       	mov    esi,0x9af0
    3bf9:	bf d8 d8 00 00       	mov    edi,0xd8d8
    3bfe:	e8 7d 23 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    3c03:	31 c0                	xor    eax,eax
    3c05:	48 83 c4 08          	add    rsp,0x8
    3c09:	c3                   	ret    
    3c0a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000003c10 <perception::linux_syscalls::get_thread_area()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long get_thread_area() {
    3c10:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call get_thread_area is unimplemented.\n";
    3c14:	be 20 9b 00 00       	mov    esi,0x9b20
    3c19:	bf d8 d8 00 00       	mov    edi,0xd8d8
    3c1e:	e8 5d 23 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    3c23:	31 c0                	xor    eax,eax
    3c25:	48 83 c4 08          	add    rsp,0x8
    3c29:	c3                   	ret    
    3c2a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000003c30 <perception::linux_syscalls::getcpu()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long getcpu() {
    3c30:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call getcpu is unimplemented.\n";
    3c34:	be 50 9b 00 00       	mov    esi,0x9b50
    3c39:	bf d8 d8 00 00       	mov    edi,0xd8d8
    3c3e:	e8 3d 23 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    3c43:	31 c0                	xor    eax,eax
    3c45:	48 83 c4 08          	add    rsp,0x8
    3c49:	c3                   	ret    
    3c4a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000003c50 <perception::linux_syscalls::getcwd()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long getcwd() {
    3c50:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call getcwd is unimplemented.\n";
    3c54:	be 78 9b 00 00       	mov    esi,0x9b78
    3c59:	bf d8 d8 00 00       	mov    edi,0xd8d8
    3c5e:	e8 1d 23 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    3c63:	31 c0                	xor    eax,eax
    3c65:	48 83 c4 08          	add    rsp,0x8
    3c69:	c3                   	ret    
    3c6a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000003c70 <perception::linux_syscalls::getdents()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long getdents() {
    3c70:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call getdents is unimplemented.\n";
    3c74:	be a0 9b 00 00       	mov    esi,0x9ba0
    3c79:	bf d8 d8 00 00       	mov    edi,0xd8d8
    3c7e:	e8 fd 22 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    3c83:	31 c0                	xor    eax,eax
    3c85:	48 83 c4 08          	add    rsp,0x8
    3c89:	c3                   	ret    
    3c8a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000003c90 <perception::linux_syscalls::getdents64()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long getdents64() {
    3c90:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call getdents64 is unimplemented.\n";
    3c94:	be c8 9b 00 00       	mov    esi,0x9bc8
    3c99:	bf d8 d8 00 00       	mov    edi,0xd8d8
    3c9e:	e8 dd 22 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    3ca3:	31 c0                	xor    eax,eax
    3ca5:	48 83 c4 08          	add    rsp,0x8
    3ca9:	c3                   	ret    
    3caa:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000003cb0 <perception::linux_syscalls::getegid()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long getegid() {
    3cb0:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call getegid is unimplemented.\n";
    3cb4:	be f8 9b 00 00       	mov    esi,0x9bf8
    3cb9:	bf d8 d8 00 00       	mov    edi,0xd8d8
    3cbe:	e8 bd 22 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    3cc3:	31 c0                	xor    eax,eax
    3cc5:	48 83 c4 08          	add    rsp,0x8
    3cc9:	c3                   	ret    
    3cca:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000003cd0 <perception::linux_syscalls::geteuid()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long geteuid() {
    3cd0:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call geteuid is unimplemented.\n";
    3cd4:	be 20 9c 00 00       	mov    esi,0x9c20
    3cd9:	bf d8 d8 00 00       	mov    edi,0xd8d8
    3cde:	e8 9d 22 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    3ce3:	31 c0                	xor    eax,eax
    3ce5:	48 83 c4 08          	add    rsp,0x8
    3ce9:	c3                   	ret    
    3cea:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000003cf0 <perception::linux_syscalls::getgid()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long getgid() {
    3cf0:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call getgid is unimplemented.\n";
    3cf4:	be 48 9c 00 00       	mov    esi,0x9c48
    3cf9:	bf d8 d8 00 00       	mov    edi,0xd8d8
    3cfe:	e8 7d 22 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    3d03:	31 c0                	xor    eax,eax
    3d05:	48 83 c4 08          	add    rsp,0x8
    3d09:	c3                   	ret    
    3d0a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000003d10 <perception::linux_syscalls::getgroups()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long getgroups() {
    3d10:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call getgroups is unimplemented.\n";
    3d14:	be 70 9c 00 00       	mov    esi,0x9c70
    3d19:	bf d8 d8 00 00       	mov    edi,0xd8d8
    3d1e:	e8 5d 22 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    3d23:	31 c0                	xor    eax,eax
    3d25:	48 83 c4 08          	add    rsp,0x8
    3d29:	c3                   	ret    
    3d2a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000003d30 <perception::linux_syscalls::getitimer()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long getitimer() {
    3d30:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call getitimer is unimplemented.\n";
    3d34:	be a0 9c 00 00       	mov    esi,0x9ca0
    3d39:	bf d8 d8 00 00       	mov    edi,0xd8d8
    3d3e:	e8 3d 22 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    3d43:	31 c0                	xor    eax,eax
    3d45:	48 83 c4 08          	add    rsp,0x8
    3d49:	c3                   	ret    
    3d4a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000003d50 <perception::linux_syscalls::getpeername()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long getpeername() {
    3d50:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call getpeername is unimplemented.\n";
    3d54:	be d0 9c 00 00       	mov    esi,0x9cd0
    3d59:	bf d8 d8 00 00       	mov    edi,0xd8d8
    3d5e:	e8 1d 22 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    3d63:	31 c0                	xor    eax,eax
    3d65:	48 83 c4 08          	add    rsp,0x8
    3d69:	c3                   	ret    
    3d6a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000003d70 <perception::linux_syscalls::getpgid()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long getpgid() {
    3d70:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call getpgid is unimplemented.\n";
    3d74:	be 00 9d 00 00       	mov    esi,0x9d00
    3d79:	bf d8 d8 00 00       	mov    edi,0xd8d8
    3d7e:	e8 fd 21 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    3d83:	31 c0                	xor    eax,eax
    3d85:	48 83 c4 08          	add    rsp,0x8
    3d89:	c3                   	ret    
    3d8a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000003d90 <perception::linux_syscalls::getpgrp()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long getpgrp() {
    3d90:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call getpgrp is unimplemented.\n";
    3d94:	be 28 9d 00 00       	mov    esi,0x9d28
    3d99:	bf d8 d8 00 00       	mov    edi,0xd8d8
    3d9e:	e8 dd 21 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    3da3:	31 c0                	xor    eax,eax
    3da5:	48 83 c4 08          	add    rsp,0x8
    3da9:	c3                   	ret    
    3daa:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000003db0 <perception::linux_syscalls::getpid()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long getpid() {
    3db0:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call getpid is unimplemented.\n";
    3db4:	be 50 9d 00 00       	mov    esi,0x9d50
    3db9:	bf d8 d8 00 00       	mov    edi,0xd8d8
    3dbe:	e8 bd 21 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    3dc3:	31 c0                	xor    eax,eax
    3dc5:	48 83 c4 08          	add    rsp,0x8
    3dc9:	c3                   	ret    
    3dca:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000003dd0 <perception::linux_syscalls::getpmsg()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long getpmsg() {
    3dd0:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call getpmsg is unimplemented.\n";
    3dd4:	be 78 9d 00 00       	mov    esi,0x9d78
    3dd9:	bf d8 d8 00 00       	mov    edi,0xd8d8
    3dde:	e8 9d 21 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    3de3:	31 c0                	xor    eax,eax
    3de5:	48 83 c4 08          	add    rsp,0x8
    3de9:	c3                   	ret    
    3dea:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000003df0 <perception::linux_syscalls::getppid()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long getppid() {
    3df0:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call getppid is unimplemented.\n";
    3df4:	be a0 9d 00 00       	mov    esi,0x9da0
    3df9:	bf d8 d8 00 00       	mov    edi,0xd8d8
    3dfe:	e8 7d 21 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    3e03:	31 c0                	xor    eax,eax
    3e05:	48 83 c4 08          	add    rsp,0x8
    3e09:	c3                   	ret    
    3e0a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000003e10 <perception::linux_syscalls::getpriority()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long getpriority() {
    3e10:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call getpriority is unimplemented.\n";
    3e14:	be c8 9d 00 00       	mov    esi,0x9dc8
    3e19:	bf d8 d8 00 00       	mov    edi,0xd8d8
    3e1e:	e8 5d 21 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    3e23:	31 c0                	xor    eax,eax
    3e25:	48 83 c4 08          	add    rsp,0x8
    3e29:	c3                   	ret    
    3e2a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000003e30 <perception::linux_syscalls::getrandom()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long getrandom() {
    3e30:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call getrandom is unimplemented.\n";
    3e34:	be f8 9d 00 00       	mov    esi,0x9df8
    3e39:	bf d8 d8 00 00       	mov    edi,0xd8d8
    3e3e:	e8 3d 21 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    3e43:	31 c0                	xor    eax,eax
    3e45:	48 83 c4 08          	add    rsp,0x8
    3e49:	c3                   	ret    
    3e4a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000003e50 <perception::linux_syscalls::getresgid()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long getresgid() {
    3e50:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call getresgid is unimplemented.\n";
    3e54:	be 28 9e 00 00       	mov    esi,0x9e28
    3e59:	bf d8 d8 00 00       	mov    edi,0xd8d8
    3e5e:	e8 1d 21 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    3e63:	31 c0                	xor    eax,eax
    3e65:	48 83 c4 08          	add    rsp,0x8
    3e69:	c3                   	ret    
    3e6a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000003e70 <perception::linux_syscalls::getresuid()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long getresuid() {
    3e70:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call getresuid is unimplemented.\n";
    3e74:	be 58 9e 00 00       	mov    esi,0x9e58
    3e79:	bf d8 d8 00 00       	mov    edi,0xd8d8
    3e7e:	e8 fd 20 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    3e83:	31 c0                	xor    eax,eax
    3e85:	48 83 c4 08          	add    rsp,0x8
    3e89:	c3                   	ret    
    3e8a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000003e90 <perception::linux_syscalls::getrlimit()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long getrlimit() {
    3e90:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call getrlimit is unimplemented.\n";
    3e94:	be 88 9e 00 00       	mov    esi,0x9e88
    3e99:	bf d8 d8 00 00       	mov    edi,0xd8d8
    3e9e:	e8 dd 20 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    3ea3:	31 c0                	xor    eax,eax
    3ea5:	48 83 c4 08          	add    rsp,0x8
    3ea9:	c3                   	ret    
    3eaa:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000003eb0 <perception::linux_syscalls::getrusage()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long getrusage() {
    3eb0:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call getrusage is unimplemented.\n";
    3eb4:	be b8 9e 00 00       	mov    esi,0x9eb8
    3eb9:	bf d8 d8 00 00       	mov    edi,0xd8d8
    3ebe:	e8 bd 20 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    3ec3:	31 c0                	xor    eax,eax
    3ec5:	48 83 c4 08          	add    rsp,0x8
    3ec9:	c3                   	ret    
    3eca:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000003ed0 <perception::linux_syscalls::getsid()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long getsid() {
    3ed0:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call getsid is unimplemented.\n";
    3ed4:	be e8 9e 00 00       	mov    esi,0x9ee8
    3ed9:	bf d8 d8 00 00       	mov    edi,0xd8d8
    3ede:	e8 9d 20 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    3ee3:	31 c0                	xor    eax,eax
    3ee5:	48 83 c4 08          	add    rsp,0x8
    3ee9:	c3                   	ret    
    3eea:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000003ef0 <perception::linux_syscalls::getsockname()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long getsockname() {
    3ef0:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call getsockname is unimplemented.\n";
    3ef4:	be 10 9f 00 00       	mov    esi,0x9f10
    3ef9:	bf d8 d8 00 00       	mov    edi,0xd8d8
    3efe:	e8 7d 20 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    3f03:	31 c0                	xor    eax,eax
    3f05:	48 83 c4 08          	add    rsp,0x8
    3f09:	c3                   	ret    
    3f0a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000003f10 <perception::linux_syscalls::getsockopt()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long getsockopt() {
    3f10:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call getsockopt is unimplemented.\n";
    3f14:	be 40 9f 00 00       	mov    esi,0x9f40
    3f19:	bf d8 d8 00 00       	mov    edi,0xd8d8
    3f1e:	e8 5d 20 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    3f23:	31 c0                	xor    eax,eax
    3f25:	48 83 c4 08          	add    rsp,0x8
    3f29:	c3                   	ret    
    3f2a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000003f30 <perception::linux_syscalls::gettid()>:

namespace perception {
namespace linux_syscalls {

long gettid() {
	return GetThreadId();
    3f30:	e9 0b 21 00 00       	jmp    6040 <perception::GetThreadId()>
    3f35:	66 2e 0f 1f 84 00 00 00 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
    3f3f:	90                   	nop

0000000000003f40 <perception::linux_syscalls::gettimeofday()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long gettimeofday() {
    3f40:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call gettimeofday is unimplemented.\n";
    3f44:	be 70 9f 00 00       	mov    esi,0x9f70
    3f49:	bf d8 d8 00 00       	mov    edi,0xd8d8
    3f4e:	e8 2d 20 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    3f53:	31 c0                	xor    eax,eax
    3f55:	48 83 c4 08          	add    rsp,0x8
    3f59:	c3                   	ret    
    3f5a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000003f60 <perception::linux_syscalls::getuid()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long getuid() {
    3f60:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call getuid is unimplemented.\n";
    3f64:	be a0 9f 00 00       	mov    esi,0x9fa0
    3f69:	bf d8 d8 00 00       	mov    edi,0xd8d8
    3f6e:	e8 0d 20 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    3f73:	31 c0                	xor    eax,eax
    3f75:	48 83 c4 08          	add    rsp,0x8
    3f79:	c3                   	ret    
    3f7a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000003f80 <perception::linux_syscalls::getxattr()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long getxattr() {
    3f80:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call getxattr is unimplemented.\n";
    3f84:	be c8 9f 00 00       	mov    esi,0x9fc8
    3f89:	bf d8 d8 00 00       	mov    edi,0xd8d8
    3f8e:	e8 ed 1f 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    3f93:	31 c0                	xor    eax,eax
    3f95:	48 83 c4 08          	add    rsp,0x8
    3f99:	c3                   	ret    
    3f9a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000003fa0 <perception::linux_syscalls::init_module()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long init_module() {
    3fa0:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call init_module is unimplemented.\n";
    3fa4:	be f0 9f 00 00       	mov    esi,0x9ff0
    3fa9:	bf d8 d8 00 00       	mov    edi,0xd8d8
    3fae:	e8 cd 1f 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    3fb3:	31 c0                	xor    eax,eax
    3fb5:	48 83 c4 08          	add    rsp,0x8
    3fb9:	c3                   	ret    
    3fba:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000003fc0 <perception::linux_syscalls::inotify_add_watch()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long inotify_add_watch() {
    3fc0:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call inotify_add_watch is unimplemented.\n";
    3fc4:	be 20 a0 00 00       	mov    esi,0xa020
    3fc9:	bf d8 d8 00 00       	mov    edi,0xd8d8
    3fce:	e8 ad 1f 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    3fd3:	31 c0                	xor    eax,eax
    3fd5:	48 83 c4 08          	add    rsp,0x8
    3fd9:	c3                   	ret    
    3fda:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000003fe0 <perception::linux_syscalls::inotify_init()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long inotify_init() {
    3fe0:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call inotify_init is unimplemented.\n";
    3fe4:	be 58 a0 00 00       	mov    esi,0xa058
    3fe9:	bf d8 d8 00 00       	mov    edi,0xd8d8
    3fee:	e8 8d 1f 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    3ff3:	31 c0                	xor    eax,eax
    3ff5:	48 83 c4 08          	add    rsp,0x8
    3ff9:	c3                   	ret    
    3ffa:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000004000 <perception::linux_syscalls::inotify_init1()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long inotify_init1() {
    4000:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call inotify_init1 is unimplemented.\n";
    4004:	be 88 a0 00 00       	mov    esi,0xa088
    4009:	bf d8 d8 00 00       	mov    edi,0xd8d8
    400e:	e8 6d 1f 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    4013:	31 c0                	xor    eax,eax
    4015:	48 83 c4 08          	add    rsp,0x8
    4019:	c3                   	ret    
    401a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000004020 <perception::linux_syscalls::inotify_rm_watch()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long inotify_rm_watch() {
    4020:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call inotify_rm_watch is unimplemented.\n";
    4024:	be b8 a0 00 00       	mov    esi,0xa0b8
    4029:	bf d8 d8 00 00       	mov    edi,0xd8d8
    402e:	e8 4d 1f 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    4033:	31 c0                	xor    eax,eax
    4035:	48 83 c4 08          	add    rsp,0x8
    4039:	c3                   	ret    
    403a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000004040 <perception::linux_syscalls::io_cancel()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long io_cancel() {
    4040:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call io_cancel is unimplemented.\n";
    4044:	be e8 a0 00 00       	mov    esi,0xa0e8
    4049:	bf d8 d8 00 00       	mov    edi,0xd8d8
    404e:	e8 2d 1f 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    4053:	31 c0                	xor    eax,eax
    4055:	48 83 c4 08          	add    rsp,0x8
    4059:	c3                   	ret    
    405a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000004060 <perception::linux_syscalls::io_destroy()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long io_destroy() {
    4060:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call io_destroy is unimplemented.\n";
    4064:	be 18 a1 00 00       	mov    esi,0xa118
    4069:	bf d8 d8 00 00       	mov    edi,0xd8d8
    406e:	e8 0d 1f 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    4073:	31 c0                	xor    eax,eax
    4075:	48 83 c4 08          	add    rsp,0x8
    4079:	c3                   	ret    
    407a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000004080 <perception::linux_syscalls::io_getevents()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long io_getevents() {
    4080:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call io_getevents is unimplemented.\n";
    4084:	be 48 a1 00 00       	mov    esi,0xa148
    4089:	bf d8 d8 00 00       	mov    edi,0xd8d8
    408e:	e8 ed 1e 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    4093:	31 c0                	xor    eax,eax
    4095:	48 83 c4 08          	add    rsp,0x8
    4099:	c3                   	ret    
    409a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

00000000000040a0 <perception::linux_syscalls::io_pgetevents()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long io_pgetevents() {
    40a0:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call io_pgetevents is unimplemented.\n";
    40a4:	be 78 a1 00 00       	mov    esi,0xa178
    40a9:	bf d8 d8 00 00       	mov    edi,0xd8d8
    40ae:	e8 cd 1e 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    40b3:	31 c0                	xor    eax,eax
    40b5:	48 83 c4 08          	add    rsp,0x8
    40b9:	c3                   	ret    
    40ba:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

00000000000040c0 <perception::linux_syscalls::io_setup()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long io_setup() {
    40c0:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call io_setup is unimplemented.\n";
    40c4:	be a8 a1 00 00       	mov    esi,0xa1a8
    40c9:	bf d8 d8 00 00       	mov    edi,0xd8d8
    40ce:	e8 ad 1e 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    40d3:	31 c0                	xor    eax,eax
    40d5:	48 83 c4 08          	add    rsp,0x8
    40d9:	c3                   	ret    
    40da:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

00000000000040e0 <perception::linux_syscalls::io_submit()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long io_submit() {
    40e0:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call io_submit is unimplemented.\n";
    40e4:	be d0 a1 00 00       	mov    esi,0xa1d0
    40e9:	bf d8 d8 00 00       	mov    edi,0xd8d8
    40ee:	e8 8d 1e 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    40f3:	31 c0                	xor    eax,eax
    40f5:	48 83 c4 08          	add    rsp,0x8
    40f9:	c3                   	ret    
    40fa:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000004100 <perception::linux_syscalls::io_uring_enter()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long io_uring_enter() {
    4100:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call io_uring_enter is unimplemented.\n";
    4104:	be 00 a2 00 00       	mov    esi,0xa200
    4109:	bf d8 d8 00 00       	mov    edi,0xd8d8
    410e:	e8 6d 1e 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    4113:	31 c0                	xor    eax,eax
    4115:	48 83 c4 08          	add    rsp,0x8
    4119:	c3                   	ret    
    411a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000004120 <perception::linux_syscalls::io_uring_register()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long io_uring_register() {
    4120:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call io_uring_register is unimplemented.\n";
    4124:	be 30 a2 00 00       	mov    esi,0xa230
    4129:	bf d8 d8 00 00       	mov    edi,0xd8d8
    412e:	e8 4d 1e 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    4133:	31 c0                	xor    eax,eax
    4135:	48 83 c4 08          	add    rsp,0x8
    4139:	c3                   	ret    
    413a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000004140 <perception::linux_syscalls::io_uring_setup()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long io_uring_setup() {
    4140:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call io_uring_setup is unimplemented.\n";
    4144:	be 68 a2 00 00       	mov    esi,0xa268
    4149:	bf d8 d8 00 00       	mov    edi,0xd8d8
    414e:	e8 2d 1e 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    4153:	31 c0                	xor    eax,eax
    4155:	48 83 c4 08          	add    rsp,0x8
    4159:	c3                   	ret    
    415a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000004160 <perception::linux_syscalls::ioctl(long, long, long)>:

namespace perception {
namespace linux_syscalls {

long ioctl(long file_descriptor, long request, long arg) {
	switch (request) {
    4160:	48 8d 86 ed ab ff ff 	lea    rax,[rsi-0x5413]
    4167:	48 83 f8 01          	cmp    rax,0x1
    416b:	77 03                	ja     4170 <perception::linux_syscalls::ioctl(long, long, long)+0x10>
			break;
			default:
				DebugPrinterSingleton << "Unhandled ioctl request " << (size_t)request << ", arg: " << (size_t)arg << "\n";
		}
	return 0;
}
    416d:	31 c0                	xor    eax,eax
    416f:	c3                   	ret    
long ioctl(long file_descriptor, long request, long arg) {
    4170:	41 54                	push   r12
				DebugPrinterSingleton << "Unhandled ioctl request " << (size_t)request << ", arg: " << (size_t)arg << "\n";
    4172:	bf d8 d8 00 00       	mov    edi,0xd8d8
    4177:	49 89 d4             	mov    r12,rdx
long ioctl(long file_descriptor, long request, long arg) {
    417a:	55                   	push   rbp
    417b:	48 89 f5             	mov    rbp,rsi
				DebugPrinterSingleton << "Unhandled ioctl request " << (size_t)request << ", arg: " << (size_t)arg << "\n";
    417e:	be 96 a2 00 00       	mov    esi,0xa296
long ioctl(long file_descriptor, long request, long arg) {
    4183:	48 83 ec 08          	sub    rsp,0x8
				DebugPrinterSingleton << "Unhandled ioctl request " << (size_t)request << ", arg: " << (size_t)arg << "\n";
    4187:	e8 f4 1d 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
    418c:	48 89 ee             	mov    rsi,rbp
    418f:	48 89 c7             	mov    rdi,rax
    4192:	e8 09 1d 00 00       	call   5ea0 <perception::DebugPrinter::operator<<(unsigned long)>
    4197:	be af a2 00 00       	mov    esi,0xa2af
    419c:	48 89 c7             	mov    rdi,rax
    419f:	e8 dc 1d 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
    41a4:	4c 89 e6             	mov    rsi,r12
    41a7:	48 89 c7             	mov    rdi,rax
    41aa:	e8 f1 1c 00 00       	call   5ea0 <perception::DebugPrinter::operator<<(unsigned long)>
    41af:	be b7 a2 00 00       	mov    esi,0xa2b7
    41b4:	48 89 c7             	mov    rdi,rax
    41b7:	e8 c4 1d 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
}
    41bc:	48 83 c4 08          	add    rsp,0x8
    41c0:	31 c0                	xor    eax,eax
    41c2:	5d                   	pop    rbp
    41c3:	41 5c                	pop    r12
    41c5:	c3                   	ret    
    41c6:	66 2e 0f 1f 84 00 00 00 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]

00000000000041d0 <perception::linux_syscalls::ioperm()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long ioperm() {
    41d0:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call ioperm is unimplemented.\n";
    41d4:	be c0 a2 00 00       	mov    esi,0xa2c0
    41d9:	bf d8 d8 00 00       	mov    edi,0xd8d8
    41de:	e8 9d 1d 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    41e3:	31 c0                	xor    eax,eax
    41e5:	48 83 c4 08          	add    rsp,0x8
    41e9:	c3                   	ret    
    41ea:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

00000000000041f0 <perception::linux_syscalls::iopl()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long iopl() {
    41f0:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call iopl is unimplemented.\n";
    41f4:	be e8 a2 00 00       	mov    esi,0xa2e8
    41f9:	bf d8 d8 00 00       	mov    edi,0xd8d8
    41fe:	e8 7d 1d 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    4203:	31 c0                	xor    eax,eax
    4205:	48 83 c4 08          	add    rsp,0x8
    4209:	c3                   	ret    
    420a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000004210 <perception::linux_syscalls::ioprio_get()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long ioprio_get() {
    4210:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call ioprio_get is unimplemented.\n";
    4214:	be 10 a3 00 00       	mov    esi,0xa310
    4219:	bf d8 d8 00 00       	mov    edi,0xd8d8
    421e:	e8 5d 1d 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    4223:	31 c0                	xor    eax,eax
    4225:	48 83 c4 08          	add    rsp,0x8
    4229:	c3                   	ret    
    422a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000004230 <perception::linux_syscalls::ioprio_set()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long ioprio_set() {
    4230:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call ioprio_set is unimplemented.\n";
    4234:	be 40 a3 00 00       	mov    esi,0xa340
    4239:	bf d8 d8 00 00       	mov    edi,0xd8d8
    423e:	e8 3d 1d 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    4243:	31 c0                	xor    eax,eax
    4245:	48 83 c4 08          	add    rsp,0x8
    4249:	c3                   	ret    
    424a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000004250 <perception::linux_syscalls::kcmp()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long kcmp() {
    4250:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call kcmp is unimplemented.\n";
    4254:	be 70 a3 00 00       	mov    esi,0xa370
    4259:	bf d8 d8 00 00       	mov    edi,0xd8d8
    425e:	e8 1d 1d 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    4263:	31 c0                	xor    eax,eax
    4265:	48 83 c4 08          	add    rsp,0x8
    4269:	c3                   	ret    
    426a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000004270 <perception::linux_syscalls::kexec_file_load()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long kexec_file_load() {
    4270:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call kexec_file_load is unimplemented.\n";
    4274:	be 98 a3 00 00       	mov    esi,0xa398
    4279:	bf d8 d8 00 00       	mov    edi,0xd8d8
    427e:	e8 fd 1c 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    4283:	31 c0                	xor    eax,eax
    4285:	48 83 c4 08          	add    rsp,0x8
    4289:	c3                   	ret    
    428a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000004290 <perception::linux_syscalls::kexec_load()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long kexec_load() {
    4290:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call kexec_load is unimplemented.\n";
    4294:	be c8 a3 00 00       	mov    esi,0xa3c8
    4299:	bf d8 d8 00 00       	mov    edi,0xd8d8
    429e:	e8 dd 1c 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    42a3:	31 c0                	xor    eax,eax
    42a5:	48 83 c4 08          	add    rsp,0x8
    42a9:	c3                   	ret    
    42aa:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

00000000000042b0 <perception::linux_syscalls::keyctl()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long keyctl() {
    42b0:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call keyctl is unimplemented.\n";
    42b4:	be f8 a3 00 00       	mov    esi,0xa3f8
    42b9:	bf d8 d8 00 00       	mov    edi,0xd8d8
    42be:	e8 bd 1c 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    42c3:	31 c0                	xor    eax,eax
    42c5:	48 83 c4 08          	add    rsp,0x8
    42c9:	c3                   	ret    
    42ca:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

00000000000042d0 <perception::linux_syscalls::kill()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long kill() {
    42d0:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call kill is unimplemented.\n";
    42d4:	be 20 a4 00 00       	mov    esi,0xa420
    42d9:	bf d8 d8 00 00       	mov    edi,0xd8d8
    42de:	e8 9d 1c 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    42e3:	31 c0                	xor    eax,eax
    42e5:	48 83 c4 08          	add    rsp,0x8
    42e9:	c3                   	ret    
    42ea:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

00000000000042f0 <perception::linux_syscalls::lchown()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long lchown() {
    42f0:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call lchown is unimplemented.\n";
    42f4:	be 48 a4 00 00       	mov    esi,0xa448
    42f9:	bf d8 d8 00 00       	mov    edi,0xd8d8
    42fe:	e8 7d 1c 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    4303:	31 c0                	xor    eax,eax
    4305:	48 83 c4 08          	add    rsp,0x8
    4309:	c3                   	ret    
    430a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000004310 <perception::linux_syscalls::lgetxattr()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long lgetxattr() {
    4310:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call lgetxattr is unimplemented.\n";
    4314:	be 70 a4 00 00       	mov    esi,0xa470
    4319:	bf d8 d8 00 00       	mov    edi,0xd8d8
    431e:	e8 5d 1c 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    4323:	31 c0                	xor    eax,eax
    4325:	48 83 c4 08          	add    rsp,0x8
    4329:	c3                   	ret    
    432a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000004330 <perception::linux_syscalls::link()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long link() {
    4330:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call link is unimplemented.\n";
    4334:	be a0 a4 00 00       	mov    esi,0xa4a0
    4339:	bf d8 d8 00 00       	mov    edi,0xd8d8
    433e:	e8 3d 1c 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    4343:	31 c0                	xor    eax,eax
    4345:	48 83 c4 08          	add    rsp,0x8
    4349:	c3                   	ret    
    434a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000004350 <perception::linux_syscalls::linkat()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long linkat() {
    4350:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call linkat is unimplemented.\n";
    4354:	be c8 a4 00 00       	mov    esi,0xa4c8
    4359:	bf d8 d8 00 00       	mov    edi,0xd8d8
    435e:	e8 1d 1c 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    4363:	31 c0                	xor    eax,eax
    4365:	48 83 c4 08          	add    rsp,0x8
    4369:	c3                   	ret    
    436a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000004370 <perception::linux_syscalls::listen()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long listen() {
    4370:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call listen is unimplemented.\n";
    4374:	be f0 a4 00 00       	mov    esi,0xa4f0
    4379:	bf d8 d8 00 00       	mov    edi,0xd8d8
    437e:	e8 fd 1b 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    4383:	31 c0                	xor    eax,eax
    4385:	48 83 c4 08          	add    rsp,0x8
    4389:	c3                   	ret    
    438a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000004390 <perception::linux_syscalls::listxattr()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long listxattr() {
    4390:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call listxattr is unimplemented.\n";
    4394:	be 18 a5 00 00       	mov    esi,0xa518
    4399:	bf d8 d8 00 00       	mov    edi,0xd8d8
    439e:	e8 dd 1b 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    43a3:	31 c0                	xor    eax,eax
    43a5:	48 83 c4 08          	add    rsp,0x8
    43a9:	c3                   	ret    
    43aa:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

00000000000043b0 <perception::linux_syscalls::llistxattr()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long llistxattr() {
    43b0:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call llistxattr is unimplemented.\n";
    43b4:	be 48 a5 00 00       	mov    esi,0xa548
    43b9:	bf d8 d8 00 00       	mov    edi,0xd8d8
    43be:	e8 bd 1b 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    43c3:	31 c0                	xor    eax,eax
    43c5:	48 83 c4 08          	add    rsp,0x8
    43c9:	c3                   	ret    
    43ca:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

00000000000043d0 <perception::linux_syscalls::lookup_dcookie()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long lookup_dcookie() {
    43d0:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call lookup_dcookie is unimplemented.\n";
    43d4:	be 78 a5 00 00       	mov    esi,0xa578
    43d9:	bf d8 d8 00 00       	mov    edi,0xd8d8
    43de:	e8 9d 1b 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    43e3:	31 c0                	xor    eax,eax
    43e5:	48 83 c4 08          	add    rsp,0x8
    43e9:	c3                   	ret    
    43ea:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

00000000000043f0 <perception::linux_syscalls::lremovexattr()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long lremovexattr() {
    43f0:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call lremovexattr is unimplemented.\n";
    43f4:	be a8 a5 00 00       	mov    esi,0xa5a8
    43f9:	bf d8 d8 00 00       	mov    edi,0xd8d8
    43fe:	e8 7d 1b 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    4403:	31 c0                	xor    eax,eax
    4405:	48 83 c4 08          	add    rsp,0x8
    4409:	c3                   	ret    
    440a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000004410 <perception::linux_syscalls::lseek()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long lseek() {
    4410:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call lseek is unimplemented.\n";
    4414:	be d8 a5 00 00       	mov    esi,0xa5d8
    4419:	bf d8 d8 00 00       	mov    edi,0xd8d8
    441e:	e8 5d 1b 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    4423:	31 c0                	xor    eax,eax
    4425:	48 83 c4 08          	add    rsp,0x8
    4429:	c3                   	ret    
    442a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000004430 <perception::linux_syscalls::lsetxattr()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long lsetxattr() {
    4430:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call lsetxattr is unimplemented.\n";
    4434:	be 00 a6 00 00       	mov    esi,0xa600
    4439:	bf d8 d8 00 00       	mov    edi,0xd8d8
    443e:	e8 3d 1b 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    4443:	31 c0                	xor    eax,eax
    4445:	48 83 c4 08          	add    rsp,0x8
    4449:	c3                   	ret    
    444a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000004450 <perception::linux_syscalls::lstat()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long lstat() {
    4450:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call lstat is unimplemented.\n";
    4454:	be 30 a6 00 00       	mov    esi,0xa630
    4459:	bf d8 d8 00 00       	mov    edi,0xd8d8
    445e:	e8 1d 1b 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    4463:	31 c0                	xor    eax,eax
    4465:	48 83 c4 08          	add    rsp,0x8
    4469:	c3                   	ret    
    446a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000004470 <perception::linux_syscalls::madvise()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long madvise() {
    4470:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call madvise is unimplemented.\n";
    4474:	be 58 a6 00 00       	mov    esi,0xa658
    4479:	bf d8 d8 00 00       	mov    edi,0xd8d8
    447e:	e8 fd 1a 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    4483:	31 c0                	xor    eax,eax
    4485:	48 83 c4 08          	add    rsp,0x8
    4489:	c3                   	ret    
    448a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000004490 <perception::linux_syscalls::mbind()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long mbind() {
    4490:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call mbind is unimplemented.\n";
    4494:	be 80 a6 00 00       	mov    esi,0xa680
    4499:	bf d8 d8 00 00       	mov    edi,0xd8d8
    449e:	e8 dd 1a 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    44a3:	31 c0                	xor    eax,eax
    44a5:	48 83 c4 08          	add    rsp,0x8
    44a9:	c3                   	ret    
    44aa:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

00000000000044b0 <perception::linux_syscalls::membarrier()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long membarrier() {
    44b0:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call membarrier is unimplemented.\n";
    44b4:	be a8 a6 00 00       	mov    esi,0xa6a8
    44b9:	bf d8 d8 00 00       	mov    edi,0xd8d8
    44be:	e8 bd 1a 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    44c3:	31 c0                	xor    eax,eax
    44c5:	48 83 c4 08          	add    rsp,0x8
    44c9:	c3                   	ret    
    44ca:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

00000000000044d0 <perception::linux_syscalls::memfd_create()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long memfd_create() {
    44d0:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call memfd_create is unimplemented.\n";
    44d4:	be d8 a6 00 00       	mov    esi,0xa6d8
    44d9:	bf d8 d8 00 00       	mov    edi,0xd8d8
    44de:	e8 9d 1a 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    44e3:	31 c0                	xor    eax,eax
    44e5:	48 83 c4 08          	add    rsp,0x8
    44e9:	c3                   	ret    
    44ea:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

00000000000044f0 <perception::linux_syscalls::migrate_pages()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long migrate_pages() {
    44f0:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call migrate_pages is unimplemented.\n";
    44f4:	be 08 a7 00 00       	mov    esi,0xa708
    44f9:	bf d8 d8 00 00       	mov    edi,0xd8d8
    44fe:	e8 7d 1a 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    4503:	31 c0                	xor    eax,eax
    4505:	48 83 c4 08          	add    rsp,0x8
    4509:	c3                   	ret    
    450a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000004510 <perception::linux_syscalls::mincore()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long mincore() {
    4510:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call mincore is unimplemented.\n";
    4514:	be 38 a7 00 00       	mov    esi,0xa738
    4519:	bf d8 d8 00 00       	mov    edi,0xd8d8
    451e:	e8 5d 1a 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    4523:	31 c0                	xor    eax,eax
    4525:	48 83 c4 08          	add    rsp,0x8
    4529:	c3                   	ret    
    452a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000004530 <perception::linux_syscalls::mkdir()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long mkdir() {
    4530:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call mkdir is unimplemented.\n";
    4534:	be 60 a7 00 00       	mov    esi,0xa760
    4539:	bf d8 d8 00 00       	mov    edi,0xd8d8
    453e:	e8 3d 1a 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    4543:	31 c0                	xor    eax,eax
    4545:	48 83 c4 08          	add    rsp,0x8
    4549:	c3                   	ret    
    454a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000004550 <perception::linux_syscalls::mkdirat()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long mkdirat() {
    4550:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call mkdirat is unimplemented.\n";
    4554:	be 88 a7 00 00       	mov    esi,0xa788
    4559:	bf d8 d8 00 00       	mov    edi,0xd8d8
    455e:	e8 1d 1a 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    4563:	31 c0                	xor    eax,eax
    4565:	48 83 c4 08          	add    rsp,0x8
    4569:	c3                   	ret    
    456a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000004570 <perception::linux_syscalls::mknod()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long mknod() {
    4570:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call mknod is unimplemented.\n";
    4574:	be b0 a7 00 00       	mov    esi,0xa7b0
    4579:	bf d8 d8 00 00       	mov    edi,0xd8d8
    457e:	e8 fd 19 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    4583:	31 c0                	xor    eax,eax
    4585:	48 83 c4 08          	add    rsp,0x8
    4589:	c3                   	ret    
    458a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000004590 <perception::linux_syscalls::mknodat()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long mknodat() {
    4590:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call mknodat is unimplemented.\n";
    4594:	be d8 a7 00 00       	mov    esi,0xa7d8
    4599:	bf d8 d8 00 00       	mov    edi,0xd8d8
    459e:	e8 dd 19 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    45a3:	31 c0                	xor    eax,eax
    45a5:	48 83 c4 08          	add    rsp,0x8
    45a9:	c3                   	ret    
    45aa:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

00000000000045b0 <perception::linux_syscalls::mlock()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long mlock() {
    45b0:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call mlock is unimplemented.\n";
    45b4:	be 00 a8 00 00       	mov    esi,0xa800
    45b9:	bf d8 d8 00 00       	mov    edi,0xd8d8
    45be:	e8 bd 19 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    45c3:	31 c0                	xor    eax,eax
    45c5:	48 83 c4 08          	add    rsp,0x8
    45c9:	c3                   	ret    
    45ca:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

00000000000045d0 <perception::linux_syscalls::mlock2()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long mlock2() {
    45d0:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call mlock2 is unimplemented.\n";
    45d4:	be 28 a8 00 00       	mov    esi,0xa828
    45d9:	bf d8 d8 00 00       	mov    edi,0xd8d8
    45de:	e8 9d 19 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    45e3:	31 c0                	xor    eax,eax
    45e5:	48 83 c4 08          	add    rsp,0x8
    45e9:	c3                   	ret    
    45ea:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

00000000000045f0 <perception::linux_syscalls::mlockall()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long mlockall() {
    45f0:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call mlockall is unimplemented.\n";
    45f4:	be 50 a8 00 00       	mov    esi,0xa850
    45f9:	bf d8 d8 00 00       	mov    edi,0xd8d8
    45fe:	e8 7d 19 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    4603:	31 c0                	xor    eax,eax
    4605:	48 83 c4 08          	add    rsp,0x8
    4609:	c3                   	ret    
    460a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000004610 <perception::linux_syscalls::mmap(long, long, long, long, long, long)>:

namespace perception {
namespace linux_syscalls {

long mmap(long addr, long length, long prot, long flags,
                  long fd, long offset) {
    4610:	41 54                	push   r12
    4612:	55                   	push   rbp
    4613:	53                   	push   rbx

	if (addr != 0) {
    4614:	48 85 ff             	test   rdi,rdi
    4617:	75 57                	jne    4670 <perception::linux_syscalls::mmap(long, long, long, long, long, long)+0x60>
    4619:	48 89 f3             	mov    rbx,rsi
    461c:	49 89 cc             	mov    r12,rcx
		perception::DebugPrinterSingleton << "mmap wants to place at a specific addr (" << (size_t)addr << ") but this isn't yet implemented.\n";
		return 0;
	}

	if (flags != (MAP_ANON | MAP_PRIVATE)) {
    461f:	48 83 f9 22          	cmp    rcx,0x22
    4623:	75 13                	jne    4638 <perception::linux_syscalls::mmap(long, long, long, long, long, long)+0x28>
	}

	// 'prot' sepecifies if the memory can be executed, read, written, etc. The kernel doesn't yet support this level
	// of control, so we make all program memory x/r/w and can ignore this parameter.

	return (long)AllocateMemoryPages((size_t)length / kPageSize);
    4625:	48 c1 eb 0c          	shr    rbx,0xc
    4629:	48 89 df             	mov    rdi,rbx
}
    462c:	5b                   	pop    rbx
    462d:	5d                   	pop    rbp
    462e:	41 5c                	pop    r12
	return (long)AllocateMemoryPages((size_t)length / kPageSize);
    4630:	e9 5b bb ff ff       	jmp    190 <perception::AllocateMemoryPages(unsigned long)>
    4635:	0f 1f 00             	nop    DWORD PTR [rax]
		perception::DebugPrinterSingleton << "mmap passed flags " << (size_t)flags << " but currently only MAP_ANON | MAP_FIXED is supported.\n";
    4638:	be 08 a9 00 00       	mov    esi,0xa908
    463d:	bf d8 d8 00 00       	mov    edi,0xd8d8
	return (long)AllocateMemoryPages((size_t)length / kPageSize);
    4642:	48 c1 eb 0c          	shr    rbx,0xc
		perception::DebugPrinterSingleton << "mmap passed flags " << (size_t)flags << " but currently only MAP_ANON | MAP_FIXED is supported.\n";
    4646:	e8 35 19 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
    464b:	4c 89 e6             	mov    rsi,r12
    464e:	48 89 c7             	mov    rdi,rax
    4651:	e8 4a 18 00 00       	call   5ea0 <perception::DebugPrinter::operator<<(unsigned long)>
    4656:	be d0 a8 00 00       	mov    esi,0xa8d0
    465b:	48 89 c7             	mov    rdi,rax
    465e:	e8 1d 19 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return (long)AllocateMemoryPages((size_t)length / kPageSize);
    4663:	48 89 df             	mov    rdi,rbx
}
    4666:	5b                   	pop    rbx
    4667:	5d                   	pop    rbp
    4668:	41 5c                	pop    r12
	return (long)AllocateMemoryPages((size_t)length / kPageSize);
    466a:	e9 21 bb ff ff       	jmp    190 <perception::AllocateMemoryPages(unsigned long)>
    466f:	90                   	nop
    4670:	48 89 fd             	mov    rbp,rdi
		perception::DebugPrinterSingleton << "mmap wants to place at a specific addr (" << (size_t)addr << ") but this isn't yet implemented.\n";
    4673:	be 78 a8 00 00       	mov    esi,0xa878
    4678:	bf d8 d8 00 00       	mov    edi,0xd8d8
    467d:	e8 fe 18 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
    4682:	48 89 ee             	mov    rsi,rbp
    4685:	48 89 c7             	mov    rdi,rax
    4688:	e8 13 18 00 00       	call   5ea0 <perception::DebugPrinter::operator<<(unsigned long)>
    468d:	be a8 a8 00 00       	mov    esi,0xa8a8
    4692:	48 89 c7             	mov    rdi,rax
    4695:	e8 e6 18 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
}
    469a:	5b                   	pop    rbx
    469b:	31 c0                	xor    eax,eax
    469d:	5d                   	pop    rbp
    469e:	41 5c                	pop    r12
    46a0:	c3                   	ret    
    46a1:	66 2e 0f 1f 84 00 00 00 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
    46ab:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

00000000000046b0 <perception::linux_syscalls::modify_ldt()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long modify_ldt() {
    46b0:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call modify_ldt is unimplemented.\n";
    46b4:	be 20 a9 00 00       	mov    esi,0xa920
    46b9:	bf d8 d8 00 00       	mov    edi,0xd8d8
    46be:	e8 bd 18 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    46c3:	31 c0                	xor    eax,eax
    46c5:	48 83 c4 08          	add    rsp,0x8
    46c9:	c3                   	ret    
    46ca:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

00000000000046d0 <perception::linux_syscalls::mount()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long mount() {
    46d0:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call mount is unimplemented.\n";
    46d4:	be 50 a9 00 00       	mov    esi,0xa950
    46d9:	bf d8 d8 00 00       	mov    edi,0xd8d8
    46de:	e8 9d 18 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    46e3:	31 c0                	xor    eax,eax
    46e5:	48 83 c4 08          	add    rsp,0x8
    46e9:	c3                   	ret    
    46ea:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

00000000000046f0 <perception::linux_syscalls::move_mount()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long move_mount() {
    46f0:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call move_mount is unimplemented.\n";
    46f4:	be 78 a9 00 00       	mov    esi,0xa978
    46f9:	bf d8 d8 00 00       	mov    edi,0xd8d8
    46fe:	e8 7d 18 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    4703:	31 c0                	xor    eax,eax
    4705:	48 83 c4 08          	add    rsp,0x8
    4709:	c3                   	ret    
    470a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000004710 <perception::linux_syscalls::move_pages()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long move_pages() {
    4710:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call move_pages is unimplemented.\n";
    4714:	be a8 a9 00 00       	mov    esi,0xa9a8
    4719:	bf d8 d8 00 00       	mov    edi,0xd8d8
    471e:	e8 5d 18 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    4723:	31 c0                	xor    eax,eax
    4725:	48 83 c4 08          	add    rsp,0x8
    4729:	c3                   	ret    
    472a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000004730 <perception::linux_syscalls::mprotect()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long mprotect() {
    4730:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call mprotect is unimplemented.\n";
    4734:	be d8 a9 00 00       	mov    esi,0xa9d8
    4739:	bf d8 d8 00 00       	mov    edi,0xd8d8
    473e:	e8 3d 18 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    4743:	31 c0                	xor    eax,eax
    4745:	48 83 c4 08          	add    rsp,0x8
    4749:	c3                   	ret    
    474a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000004750 <perception::linux_syscalls::mq_getsetattr()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long mq_getsetattr() {
    4750:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call mq_getsetattr is unimplemented.\n";
    4754:	be 00 aa 00 00       	mov    esi,0xaa00
    4759:	bf d8 d8 00 00       	mov    edi,0xd8d8
    475e:	e8 1d 18 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    4763:	31 c0                	xor    eax,eax
    4765:	48 83 c4 08          	add    rsp,0x8
    4769:	c3                   	ret    
    476a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000004770 <perception::linux_syscalls::mq_notify()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long mq_notify() {
    4770:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call mq_notify is unimplemented.\n";
    4774:	be 30 aa 00 00       	mov    esi,0xaa30
    4779:	bf d8 d8 00 00       	mov    edi,0xd8d8
    477e:	e8 fd 17 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    4783:	31 c0                	xor    eax,eax
    4785:	48 83 c4 08          	add    rsp,0x8
    4789:	c3                   	ret    
    478a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000004790 <perception::linux_syscalls::mq_open()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long mq_open() {
    4790:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call mq_open is unimplemented.\n";
    4794:	be 60 aa 00 00       	mov    esi,0xaa60
    4799:	bf d8 d8 00 00       	mov    edi,0xd8d8
    479e:	e8 dd 17 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    47a3:	31 c0                	xor    eax,eax
    47a5:	48 83 c4 08          	add    rsp,0x8
    47a9:	c3                   	ret    
    47aa:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

00000000000047b0 <perception::linux_syscalls::mq_timedreceive()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long mq_timedreceive() {
    47b0:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call mq_timedreceive is unimplemented.\n";
    47b4:	be 88 aa 00 00       	mov    esi,0xaa88
    47b9:	bf d8 d8 00 00       	mov    edi,0xd8d8
    47be:	e8 bd 17 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    47c3:	31 c0                	xor    eax,eax
    47c5:	48 83 c4 08          	add    rsp,0x8
    47c9:	c3                   	ret    
    47ca:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

00000000000047d0 <perception::linux_syscalls::mq_timedsend()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long mq_timedsend() {
    47d0:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call mq_timedsend is unimplemented.\n";
    47d4:	be b8 aa 00 00       	mov    esi,0xaab8
    47d9:	bf d8 d8 00 00       	mov    edi,0xd8d8
    47de:	e8 9d 17 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    47e3:	31 c0                	xor    eax,eax
    47e5:	48 83 c4 08          	add    rsp,0x8
    47e9:	c3                   	ret    
    47ea:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

00000000000047f0 <perception::linux_syscalls::mq_unlink()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long mq_unlink() {
    47f0:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call mq_unlink is unimplemented.\n";
    47f4:	be e8 aa 00 00       	mov    esi,0xaae8
    47f9:	bf d8 d8 00 00       	mov    edi,0xd8d8
    47fe:	e8 7d 17 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    4803:	31 c0                	xor    eax,eax
    4805:	48 83 c4 08          	add    rsp,0x8
    4809:	c3                   	ret    
    480a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000004810 <perception::linux_syscalls::mremap()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long mremap() {
    4810:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call mremap is unimplemented.\n";
    4814:	be 18 ab 00 00       	mov    esi,0xab18
    4819:	bf d8 d8 00 00       	mov    edi,0xd8d8
    481e:	e8 5d 17 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    4823:	31 c0                	xor    eax,eax
    4825:	48 83 c4 08          	add    rsp,0x8
    4829:	c3                   	ret    
    482a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000004830 <perception::linux_syscalls::msgctl()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long msgctl() {
    4830:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call msgctl is unimplemented.\n";
    4834:	be 40 ab 00 00       	mov    esi,0xab40
    4839:	bf d8 d8 00 00       	mov    edi,0xd8d8
    483e:	e8 3d 17 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    4843:	31 c0                	xor    eax,eax
    4845:	48 83 c4 08          	add    rsp,0x8
    4849:	c3                   	ret    
    484a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000004850 <perception::linux_syscalls::msgget()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long msgget() {
    4850:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call msgget is unimplemented.\n";
    4854:	be 68 ab 00 00       	mov    esi,0xab68
    4859:	bf d8 d8 00 00       	mov    edi,0xd8d8
    485e:	e8 1d 17 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    4863:	31 c0                	xor    eax,eax
    4865:	48 83 c4 08          	add    rsp,0x8
    4869:	c3                   	ret    
    486a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000004870 <perception::linux_syscalls::msgrcv()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long msgrcv() {
    4870:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call msgrcv is unimplemented.\n";
    4874:	be 90 ab 00 00       	mov    esi,0xab90
    4879:	bf d8 d8 00 00       	mov    edi,0xd8d8
    487e:	e8 fd 16 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    4883:	31 c0                	xor    eax,eax
    4885:	48 83 c4 08          	add    rsp,0x8
    4889:	c3                   	ret    
    488a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000004890 <perception::linux_syscalls::msgsnd()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long msgsnd() {
    4890:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call msgsnd is unimplemented.\n";
    4894:	be b8 ab 00 00       	mov    esi,0xabb8
    4899:	bf d8 d8 00 00       	mov    edi,0xd8d8
    489e:	e8 dd 16 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    48a3:	31 c0                	xor    eax,eax
    48a5:	48 83 c4 08          	add    rsp,0x8
    48a9:	c3                   	ret    
    48aa:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

00000000000048b0 <perception::linux_syscalls::msync()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long msync() {
    48b0:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call msync is unimplemented.\n";
    48b4:	be e0 ab 00 00       	mov    esi,0xabe0
    48b9:	bf d8 d8 00 00       	mov    edi,0xd8d8
    48be:	e8 bd 16 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    48c3:	31 c0                	xor    eax,eax
    48c5:	48 83 c4 08          	add    rsp,0x8
    48c9:	c3                   	ret    
    48ca:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

00000000000048d0 <perception::linux_syscalls::munlock()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long munlock() {
    48d0:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call munlock is unimplemented.\n";
    48d4:	be 08 ac 00 00       	mov    esi,0xac08
    48d9:	bf d8 d8 00 00       	mov    edi,0xd8d8
    48de:	e8 9d 16 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    48e3:	31 c0                	xor    eax,eax
    48e5:	48 83 c4 08          	add    rsp,0x8
    48e9:	c3                   	ret    
    48ea:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

00000000000048f0 <perception::linux_syscalls::munlockall()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long munlockall() {
    48f0:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call munlockall is unimplemented.\n";
    48f4:	be 30 ac 00 00       	mov    esi,0xac30
    48f9:	bf d8 d8 00 00       	mov    edi,0xd8d8
    48fe:	e8 7d 16 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    4903:	31 c0                	xor    eax,eax
    4905:	48 83 c4 08          	add    rsp,0x8
    4909:	c3                   	ret    
    490a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000004910 <perception::linux_syscalls::munmap(long, long)>:
#include "perception/memory.h"

namespace perception {
namespace linux_syscalls {

long munmap(long addr, long length) {
    4910:	48 83 ec 08          	sub    rsp,0x8
	ReleaseMemoryPages((void*)addr, (size_t)length / kPageSize);
    4914:	48 c1 ee 0c          	shr    rsi,0xc
    4918:	e8 83 b8 ff ff       	call   1a0 <perception::ReleaseMemoryPages(void*, unsigned long)>
	return 0;
}
    491d:	31 c0                	xor    eax,eax
    491f:	48 83 c4 08          	add    rsp,0x8
    4923:	c3                   	ret    
    4924:	66 2e 0f 1f 84 00 00 00 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
    492e:	66 90                	xchg   ax,ax

0000000000004930 <perception::linux_syscalls::name_to_handle_at()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long name_to_handle_at() {
    4930:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call name_to_handle_at is unimplemented.\n";
    4934:	be 60 ac 00 00       	mov    esi,0xac60
    4939:	bf d8 d8 00 00       	mov    edi,0xd8d8
    493e:	e8 3d 16 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    4943:	31 c0                	xor    eax,eax
    4945:	48 83 c4 08          	add    rsp,0x8
    4949:	c3                   	ret    
    494a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000004950 <perception::linux_syscalls::nanosleep()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long nanosleep() {
    4950:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call nanosleep is unimplemented.\n";
    4954:	be 98 ac 00 00       	mov    esi,0xac98
    4959:	bf d8 d8 00 00       	mov    edi,0xd8d8
    495e:	e8 1d 16 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    4963:	31 c0                	xor    eax,eax
    4965:	48 83 c4 08          	add    rsp,0x8
    4969:	c3                   	ret    
    496a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000004970 <perception::linux_syscalls::newfstatat()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long newfstatat() {
    4970:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call newfstatat is unimplemented.\n";
    4974:	be c8 ac 00 00       	mov    esi,0xacc8
    4979:	bf d8 d8 00 00       	mov    edi,0xd8d8
    497e:	e8 fd 15 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    4983:	31 c0                	xor    eax,eax
    4985:	48 83 c4 08          	add    rsp,0x8
    4989:	c3                   	ret    
    498a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000004990 <perception::linux_syscalls::nfsservctl()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long nfsservctl() {
    4990:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call nfsservctl is unimplemented.\n";
    4994:	be f8 ac 00 00       	mov    esi,0xacf8
    4999:	bf d8 d8 00 00       	mov    edi,0xd8d8
    499e:	e8 dd 15 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    49a3:	31 c0                	xor    eax,eax
    49a5:	48 83 c4 08          	add    rsp,0x8
    49a9:	c3                   	ret    
    49aa:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

00000000000049b0 <perception::linux_syscalls::open()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long open() {
    49b0:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call open is unimplemented.\n";
    49b4:	be 28 ad 00 00       	mov    esi,0xad28
    49b9:	bf d8 d8 00 00       	mov    edi,0xd8d8
    49be:	e8 bd 15 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    49c3:	31 c0                	xor    eax,eax
    49c5:	48 83 c4 08          	add    rsp,0x8
    49c9:	c3                   	ret    
    49ca:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

00000000000049d0 <perception::linux_syscalls::open_by_handle_at()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long open_by_handle_at() {
    49d0:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call open_by_handle_at is unimplemented.\n";
    49d4:	be 50 ad 00 00       	mov    esi,0xad50
    49d9:	bf d8 d8 00 00       	mov    edi,0xd8d8
    49de:	e8 9d 15 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    49e3:	31 c0                	xor    eax,eax
    49e5:	48 83 c4 08          	add    rsp,0x8
    49e9:	c3                   	ret    
    49ea:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

00000000000049f0 <perception::linux_syscalls::open_tree()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long open_tree() {
    49f0:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call open_tree is unimplemented.\n";
    49f4:	be 88 ad 00 00       	mov    esi,0xad88
    49f9:	bf d8 d8 00 00       	mov    edi,0xd8d8
    49fe:	e8 7d 15 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    4a03:	31 c0                	xor    eax,eax
    4a05:	48 83 c4 08          	add    rsp,0x8
    4a09:	c3                   	ret    
    4a0a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000004a10 <perception::linux_syscalls::openat()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long openat() {
    4a10:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call openat is unimplemented.\n";
    4a14:	be b8 ad 00 00       	mov    esi,0xadb8
    4a19:	bf d8 d8 00 00       	mov    edi,0xd8d8
    4a1e:	e8 5d 15 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    4a23:	31 c0                	xor    eax,eax
    4a25:	48 83 c4 08          	add    rsp,0x8
    4a29:	c3                   	ret    
    4a2a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000004a30 <perception::linux_syscalls::pause()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long pause() {
    4a30:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call pause is unimplemented.\n";
    4a34:	be e0 ad 00 00       	mov    esi,0xade0
    4a39:	bf d8 d8 00 00       	mov    edi,0xd8d8
    4a3e:	e8 3d 15 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    4a43:	31 c0                	xor    eax,eax
    4a45:	48 83 c4 08          	add    rsp,0x8
    4a49:	c3                   	ret    
    4a4a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000004a50 <perception::linux_syscalls::perf_event_open()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long perf_event_open() {
    4a50:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call perf_event_open is unimplemented.\n";
    4a54:	be 08 ae 00 00       	mov    esi,0xae08
    4a59:	bf d8 d8 00 00       	mov    edi,0xd8d8
    4a5e:	e8 1d 15 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    4a63:	31 c0                	xor    eax,eax
    4a65:	48 83 c4 08          	add    rsp,0x8
    4a69:	c3                   	ret    
    4a6a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000004a70 <perception::linux_syscalls::personality()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long personality() {
    4a70:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call personality is unimplemented.\n";
    4a74:	be 38 ae 00 00       	mov    esi,0xae38
    4a79:	bf d8 d8 00 00       	mov    edi,0xd8d8
    4a7e:	e8 fd 14 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    4a83:	31 c0                	xor    eax,eax
    4a85:	48 83 c4 08          	add    rsp,0x8
    4a89:	c3                   	ret    
    4a8a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000004a90 <perception::linux_syscalls::pidfd_open()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long pidfd_open() {
    4a90:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call pidfd_open is unimplemented.\n";
    4a94:	be 68 ae 00 00       	mov    esi,0xae68
    4a99:	bf d8 d8 00 00       	mov    edi,0xd8d8
    4a9e:	e8 dd 14 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    4aa3:	31 c0                	xor    eax,eax
    4aa5:	48 83 c4 08          	add    rsp,0x8
    4aa9:	c3                   	ret    
    4aaa:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000004ab0 <perception::linux_syscalls::pidfd_send_signal()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long pidfd_send_signal() {
    4ab0:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call pidfd_send_signal is unimplemented.\n";
    4ab4:	be 98 ae 00 00       	mov    esi,0xae98
    4ab9:	bf d8 d8 00 00       	mov    edi,0xd8d8
    4abe:	e8 bd 14 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    4ac3:	31 c0                	xor    eax,eax
    4ac5:	48 83 c4 08          	add    rsp,0x8
    4ac9:	c3                   	ret    
    4aca:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000004ad0 <perception::linux_syscalls::pipe()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long pipe() {
    4ad0:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call pipe is unimplemented.\n";
    4ad4:	be d0 ae 00 00       	mov    esi,0xaed0
    4ad9:	bf d8 d8 00 00       	mov    edi,0xd8d8
    4ade:	e8 9d 14 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    4ae3:	31 c0                	xor    eax,eax
    4ae5:	48 83 c4 08          	add    rsp,0x8
    4ae9:	c3                   	ret    
    4aea:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000004af0 <perception::linux_syscalls::pipe2()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long pipe2() {
    4af0:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call pipe2 is unimplemented.\n";
    4af4:	be f8 ae 00 00       	mov    esi,0xaef8
    4af9:	bf d8 d8 00 00       	mov    edi,0xd8d8
    4afe:	e8 7d 14 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    4b03:	31 c0                	xor    eax,eax
    4b05:	48 83 c4 08          	add    rsp,0x8
    4b09:	c3                   	ret    
    4b0a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000004b10 <perception::linux_syscalls::pivot_root()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long pivot_root() {
    4b10:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call pivot_root is unimplemented.\n";
    4b14:	be 20 af 00 00       	mov    esi,0xaf20
    4b19:	bf d8 d8 00 00       	mov    edi,0xd8d8
    4b1e:	e8 5d 14 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    4b23:	31 c0                	xor    eax,eax
    4b25:	48 83 c4 08          	add    rsp,0x8
    4b29:	c3                   	ret    
    4b2a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000004b30 <perception::linux_syscalls::pkey_alloc()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long pkey_alloc() {
    4b30:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call pkey_alloc is unimplemented.\n";
    4b34:	be 50 af 00 00       	mov    esi,0xaf50
    4b39:	bf d8 d8 00 00       	mov    edi,0xd8d8
    4b3e:	e8 3d 14 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    4b43:	31 c0                	xor    eax,eax
    4b45:	48 83 c4 08          	add    rsp,0x8
    4b49:	c3                   	ret    
    4b4a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000004b50 <perception::linux_syscalls::pkey_free()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long pkey_free() {
    4b50:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call pkey_free is unimplemented.\n";
    4b54:	be 80 af 00 00       	mov    esi,0xaf80
    4b59:	bf d8 d8 00 00       	mov    edi,0xd8d8
    4b5e:	e8 1d 14 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    4b63:	31 c0                	xor    eax,eax
    4b65:	48 83 c4 08          	add    rsp,0x8
    4b69:	c3                   	ret    
    4b6a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000004b70 <perception::linux_syscalls::pkey_mprotect()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long pkey_mprotect() {
    4b70:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call pkey_mprotect is unimplemented.\n";
    4b74:	be b0 af 00 00       	mov    esi,0xafb0
    4b79:	bf d8 d8 00 00       	mov    edi,0xd8d8
    4b7e:	e8 fd 13 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    4b83:	31 c0                	xor    eax,eax
    4b85:	48 83 c4 08          	add    rsp,0x8
    4b89:	c3                   	ret    
    4b8a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000004b90 <perception::linux_syscalls::poll()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long poll() {
    4b90:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call poll is unimplemented.\n";
    4b94:	be e0 af 00 00       	mov    esi,0xafe0
    4b99:	bf d8 d8 00 00       	mov    edi,0xd8d8
    4b9e:	e8 dd 13 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    4ba3:	31 c0                	xor    eax,eax
    4ba5:	48 83 c4 08          	add    rsp,0x8
    4ba9:	c3                   	ret    
    4baa:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000004bb0 <perception::linux_syscalls::ppoll()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long ppoll() {
    4bb0:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call ppoll is unimplemented.\n";
    4bb4:	be 08 b0 00 00       	mov    esi,0xb008
    4bb9:	bf d8 d8 00 00       	mov    edi,0xd8d8
    4bbe:	e8 bd 13 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    4bc3:	31 c0                	xor    eax,eax
    4bc5:	48 83 c4 08          	add    rsp,0x8
    4bc9:	c3                   	ret    
    4bca:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000004bd0 <perception::linux_syscalls::prctl()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long prctl() {
    4bd0:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call prctl is unimplemented.\n";
    4bd4:	be 30 b0 00 00       	mov    esi,0xb030
    4bd9:	bf d8 d8 00 00       	mov    edi,0xd8d8
    4bde:	e8 9d 13 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    4be3:	31 c0                	xor    eax,eax
    4be5:	48 83 c4 08          	add    rsp,0x8
    4be9:	c3                   	ret    
    4bea:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000004bf0 <perception::linux_syscalls::pread64()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long pread64() {
    4bf0:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call pread64 is unimplemented.\n";
    4bf4:	be 58 b0 00 00       	mov    esi,0xb058
    4bf9:	bf d8 d8 00 00       	mov    edi,0xd8d8
    4bfe:	e8 7d 13 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    4c03:	31 c0                	xor    eax,eax
    4c05:	48 83 c4 08          	add    rsp,0x8
    4c09:	c3                   	ret    
    4c0a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000004c10 <perception::linux_syscalls::preadv()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long preadv() {
    4c10:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call preadv is unimplemented.\n";
    4c14:	be 80 b0 00 00       	mov    esi,0xb080
    4c19:	bf d8 d8 00 00       	mov    edi,0xd8d8
    4c1e:	e8 5d 13 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    4c23:	31 c0                	xor    eax,eax
    4c25:	48 83 c4 08          	add    rsp,0x8
    4c29:	c3                   	ret    
    4c2a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000004c30 <perception::linux_syscalls::preadv2()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long preadv2() {
    4c30:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call preadv2 is unimplemented.\n";
    4c34:	be a8 b0 00 00       	mov    esi,0xb0a8
    4c39:	bf d8 d8 00 00       	mov    edi,0xd8d8
    4c3e:	e8 3d 13 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    4c43:	31 c0                	xor    eax,eax
    4c45:	48 83 c4 08          	add    rsp,0x8
    4c49:	c3                   	ret    
    4c4a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000004c50 <perception::linux_syscalls::prlimit64()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long prlimit64() {
    4c50:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call prlimit64 is unimplemented.\n";
    4c54:	be d0 b0 00 00       	mov    esi,0xb0d0
    4c59:	bf d8 d8 00 00       	mov    edi,0xd8d8
    4c5e:	e8 1d 13 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    4c63:	31 c0                	xor    eax,eax
    4c65:	48 83 c4 08          	add    rsp,0x8
    4c69:	c3                   	ret    
    4c6a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000004c70 <perception::linux_syscalls::process_vm_readv()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long process_vm_readv() {
    4c70:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call process_vm_readv is unimplemented.\n";
    4c74:	be 00 b1 00 00       	mov    esi,0xb100
    4c79:	bf d8 d8 00 00       	mov    edi,0xd8d8
    4c7e:	e8 fd 12 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    4c83:	31 c0                	xor    eax,eax
    4c85:	48 83 c4 08          	add    rsp,0x8
    4c89:	c3                   	ret    
    4c8a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000004c90 <perception::linux_syscalls::process_vm_writev()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long process_vm_writev() {
    4c90:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call process_vm_writev is unimplemented.\n";
    4c94:	be 30 b1 00 00       	mov    esi,0xb130
    4c99:	bf d8 d8 00 00       	mov    edi,0xd8d8
    4c9e:	e8 dd 12 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    4ca3:	31 c0                	xor    eax,eax
    4ca5:	48 83 c4 08          	add    rsp,0x8
    4ca9:	c3                   	ret    
    4caa:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000004cb0 <perception::linux_syscalls::pselect6()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long pselect6() {
    4cb0:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call pselect6 is unimplemented.\n";
    4cb4:	be 68 b1 00 00       	mov    esi,0xb168
    4cb9:	bf d8 d8 00 00       	mov    edi,0xd8d8
    4cbe:	e8 bd 12 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    4cc3:	31 c0                	xor    eax,eax
    4cc5:	48 83 c4 08          	add    rsp,0x8
    4cc9:	c3                   	ret    
    4cca:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000004cd0 <perception::linux_syscalls::ptrace()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long ptrace() {
    4cd0:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call ptrace is unimplemented.\n";
    4cd4:	be 90 b1 00 00       	mov    esi,0xb190
    4cd9:	bf d8 d8 00 00       	mov    edi,0xd8d8
    4cde:	e8 9d 12 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    4ce3:	31 c0                	xor    eax,eax
    4ce5:	48 83 c4 08          	add    rsp,0x8
    4ce9:	c3                   	ret    
    4cea:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000004cf0 <perception::linux_syscalls::putpmsg()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long putpmsg() {
    4cf0:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call putpmsg is unimplemented.\n";
    4cf4:	be b8 b1 00 00       	mov    esi,0xb1b8
    4cf9:	bf d8 d8 00 00       	mov    edi,0xd8d8
    4cfe:	e8 7d 12 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    4d03:	31 c0                	xor    eax,eax
    4d05:	48 83 c4 08          	add    rsp,0x8
    4d09:	c3                   	ret    
    4d0a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000004d10 <perception::linux_syscalls::pwrite64()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long pwrite64() {
    4d10:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call pwrite64 is unimplemented.\n";
    4d14:	be e0 b1 00 00       	mov    esi,0xb1e0
    4d19:	bf d8 d8 00 00       	mov    edi,0xd8d8
    4d1e:	e8 5d 12 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    4d23:	31 c0                	xor    eax,eax
    4d25:	48 83 c4 08          	add    rsp,0x8
    4d29:	c3                   	ret    
    4d2a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000004d30 <perception::linux_syscalls::pwritev()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long pwritev() {
    4d30:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call pwritev is unimplemented.\n";
    4d34:	be 08 b2 00 00       	mov    esi,0xb208
    4d39:	bf d8 d8 00 00       	mov    edi,0xd8d8
    4d3e:	e8 3d 12 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    4d43:	31 c0                	xor    eax,eax
    4d45:	48 83 c4 08          	add    rsp,0x8
    4d49:	c3                   	ret    
    4d4a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000004d50 <perception::linux_syscalls::pwritev2()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long pwritev2() {
    4d50:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call pwritev2 is unimplemented.\n";
    4d54:	be 30 b2 00 00       	mov    esi,0xb230
    4d59:	bf d8 d8 00 00       	mov    edi,0xd8d8
    4d5e:	e8 1d 12 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    4d63:	31 c0                	xor    eax,eax
    4d65:	48 83 c4 08          	add    rsp,0x8
    4d69:	c3                   	ret    
    4d6a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000004d70 <perception::linux_syscalls::query_module()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long query_module() {
    4d70:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call query_module is unimplemented.\n";
    4d74:	be 58 b2 00 00       	mov    esi,0xb258
    4d79:	bf d8 d8 00 00       	mov    edi,0xd8d8
    4d7e:	e8 fd 11 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    4d83:	31 c0                	xor    eax,eax
    4d85:	48 83 c4 08          	add    rsp,0x8
    4d89:	c3                   	ret    
    4d8a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000004d90 <perception::linux_syscalls::quotactl()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long quotactl() {
    4d90:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call quotactl is unimplemented.\n";
    4d94:	be 88 b2 00 00       	mov    esi,0xb288
    4d99:	bf d8 d8 00 00       	mov    edi,0xd8d8
    4d9e:	e8 dd 11 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    4da3:	31 c0                	xor    eax,eax
    4da5:	48 83 c4 08          	add    rsp,0x8
    4da9:	c3                   	ret    
    4daa:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000004db0 <perception::linux_syscalls::read()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long read() {
    4db0:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call read is unimplemented.\n";
    4db4:	be b0 b2 00 00       	mov    esi,0xb2b0
    4db9:	bf d8 d8 00 00       	mov    edi,0xd8d8
    4dbe:	e8 bd 11 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    4dc3:	31 c0                	xor    eax,eax
    4dc5:	48 83 c4 08          	add    rsp,0x8
    4dc9:	c3                   	ret    
    4dca:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000004dd0 <perception::linux_syscalls::readahead()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long readahead() {
    4dd0:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call readahead is unimplemented.\n";
    4dd4:	be d8 b2 00 00       	mov    esi,0xb2d8
    4dd9:	bf d8 d8 00 00       	mov    edi,0xd8d8
    4dde:	e8 9d 11 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    4de3:	31 c0                	xor    eax,eax
    4de5:	48 83 c4 08          	add    rsp,0x8
    4de9:	c3                   	ret    
    4dea:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000004df0 <perception::linux_syscalls::readlink()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long readlink() {
    4df0:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call readlink is unimplemented.\n";
    4df4:	be 08 b3 00 00       	mov    esi,0xb308
    4df9:	bf d8 d8 00 00       	mov    edi,0xd8d8
    4dfe:	e8 7d 11 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    4e03:	31 c0                	xor    eax,eax
    4e05:	48 83 c4 08          	add    rsp,0x8
    4e09:	c3                   	ret    
    4e0a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000004e10 <perception::linux_syscalls::readlinkat()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long readlinkat() {
    4e10:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call readlinkat is unimplemented.\n";
    4e14:	be 30 b3 00 00       	mov    esi,0xb330
    4e19:	bf d8 d8 00 00       	mov    edi,0xd8d8
    4e1e:	e8 5d 11 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    4e23:	31 c0                	xor    eax,eax
    4e25:	48 83 c4 08          	add    rsp,0x8
    4e29:	c3                   	ret    
    4e2a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000004e30 <perception::linux_syscalls::readv()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long readv() {
    4e30:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call readv is unimplemented.\n";
    4e34:	be 60 b3 00 00       	mov    esi,0xb360
    4e39:	bf d8 d8 00 00       	mov    edi,0xd8d8
    4e3e:	e8 3d 11 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    4e43:	31 c0                	xor    eax,eax
    4e45:	48 83 c4 08          	add    rsp,0x8
    4e49:	c3                   	ret    
    4e4a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000004e50 <perception::linux_syscalls::reboot()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long reboot() {
    4e50:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call reboot is unimplemented.\n";
    4e54:	be 88 b3 00 00       	mov    esi,0xb388
    4e59:	bf d8 d8 00 00       	mov    edi,0xd8d8
    4e5e:	e8 1d 11 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    4e63:	31 c0                	xor    eax,eax
    4e65:	48 83 c4 08          	add    rsp,0x8
    4e69:	c3                   	ret    
    4e6a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000004e70 <perception::linux_syscalls::recvfrom()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long recvfrom() {
    4e70:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call recvfrom is unimplemented.\n";
    4e74:	be b0 b3 00 00       	mov    esi,0xb3b0
    4e79:	bf d8 d8 00 00       	mov    edi,0xd8d8
    4e7e:	e8 fd 10 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    4e83:	31 c0                	xor    eax,eax
    4e85:	48 83 c4 08          	add    rsp,0x8
    4e89:	c3                   	ret    
    4e8a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000004e90 <perception::linux_syscalls::recvmmsg()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long recvmmsg() {
    4e90:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call recvmmsg is unimplemented.\n";
    4e94:	be d8 b3 00 00       	mov    esi,0xb3d8
    4e99:	bf d8 d8 00 00       	mov    edi,0xd8d8
    4e9e:	e8 dd 10 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    4ea3:	31 c0                	xor    eax,eax
    4ea5:	48 83 c4 08          	add    rsp,0x8
    4ea9:	c3                   	ret    
    4eaa:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000004eb0 <perception::linux_syscalls::recvmsg()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long recvmsg() {
    4eb0:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call recvmsg is unimplemented.\n";
    4eb4:	be 00 b4 00 00       	mov    esi,0xb400
    4eb9:	bf d8 d8 00 00       	mov    edi,0xd8d8
    4ebe:	e8 bd 10 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    4ec3:	31 c0                	xor    eax,eax
    4ec5:	48 83 c4 08          	add    rsp,0x8
    4ec9:	c3                   	ret    
    4eca:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000004ed0 <perception::linux_syscalls::remap_file_pages()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long remap_file_pages() {
    4ed0:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call remap_file_pages is unimplemented.\n";
    4ed4:	be 28 b4 00 00       	mov    esi,0xb428
    4ed9:	bf d8 d8 00 00       	mov    edi,0xd8d8
    4ede:	e8 9d 10 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    4ee3:	31 c0                	xor    eax,eax
    4ee5:	48 83 c4 08          	add    rsp,0x8
    4ee9:	c3                   	ret    
    4eea:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000004ef0 <perception::linux_syscalls::removexattr()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long removexattr() {
    4ef0:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call removexattr is unimplemented.\n";
    4ef4:	be 58 b4 00 00       	mov    esi,0xb458
    4ef9:	bf d8 d8 00 00       	mov    edi,0xd8d8
    4efe:	e8 7d 10 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    4f03:	31 c0                	xor    eax,eax
    4f05:	48 83 c4 08          	add    rsp,0x8
    4f09:	c3                   	ret    
    4f0a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000004f10 <perception::linux_syscalls::rename()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long rename() {
    4f10:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call rename is unimplemented.\n";
    4f14:	be 88 b4 00 00       	mov    esi,0xb488
    4f19:	bf d8 d8 00 00       	mov    edi,0xd8d8
    4f1e:	e8 5d 10 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    4f23:	31 c0                	xor    eax,eax
    4f25:	48 83 c4 08          	add    rsp,0x8
    4f29:	c3                   	ret    
    4f2a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000004f30 <perception::linux_syscalls::renameat()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long renameat() {
    4f30:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call renameat is unimplemented.\n";
    4f34:	be b0 b4 00 00       	mov    esi,0xb4b0
    4f39:	bf d8 d8 00 00       	mov    edi,0xd8d8
    4f3e:	e8 3d 10 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    4f43:	31 c0                	xor    eax,eax
    4f45:	48 83 c4 08          	add    rsp,0x8
    4f49:	c3                   	ret    
    4f4a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000004f50 <perception::linux_syscalls::renameat2()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long renameat2() {
    4f50:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call renameat2 is unimplemented.\n";
    4f54:	be d8 b4 00 00       	mov    esi,0xb4d8
    4f59:	bf d8 d8 00 00       	mov    edi,0xd8d8
    4f5e:	e8 1d 10 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    4f63:	31 c0                	xor    eax,eax
    4f65:	48 83 c4 08          	add    rsp,0x8
    4f69:	c3                   	ret    
    4f6a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000004f70 <perception::linux_syscalls::request_key()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long request_key() {
    4f70:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call request_key is unimplemented.\n";
    4f74:	be 08 b5 00 00       	mov    esi,0xb508
    4f79:	bf d8 d8 00 00       	mov    edi,0xd8d8
    4f7e:	e8 fd 0f 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    4f83:	31 c0                	xor    eax,eax
    4f85:	48 83 c4 08          	add    rsp,0x8
    4f89:	c3                   	ret    
    4f8a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000004f90 <perception::linux_syscalls::restart_syscall()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long restart_syscall() {
    4f90:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call restart_syscall is unimplemented.\n";
    4f94:	be 38 b5 00 00       	mov    esi,0xb538
    4f99:	bf d8 d8 00 00       	mov    edi,0xd8d8
    4f9e:	e8 dd 0f 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    4fa3:	31 c0                	xor    eax,eax
    4fa5:	48 83 c4 08          	add    rsp,0x8
    4fa9:	c3                   	ret    
    4faa:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000004fb0 <perception::linux_syscalls::rmdir()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long rmdir() {
    4fb0:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call rmdir is unimplemented.\n";
    4fb4:	be 68 b5 00 00       	mov    esi,0xb568
    4fb9:	bf d8 d8 00 00       	mov    edi,0xd8d8
    4fbe:	e8 bd 0f 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    4fc3:	31 c0                	xor    eax,eax
    4fc5:	48 83 c4 08          	add    rsp,0x8
    4fc9:	c3                   	ret    
    4fca:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000004fd0 <perception::linux_syscalls::rseq()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long rseq() {
    4fd0:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call rseq is unimplemented.\n";
    4fd4:	be 90 b5 00 00       	mov    esi,0xb590
    4fd9:	bf d8 d8 00 00       	mov    edi,0xd8d8
    4fde:	e8 9d 0f 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    4fe3:	31 c0                	xor    eax,eax
    4fe5:	48 83 c4 08          	add    rsp,0x8
    4fe9:	c3                   	ret    
    4fea:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000004ff0 <perception::linux_syscalls::rt_sigaction()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long rt_sigaction() {
    4ff0:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call rt_sigaction is unimplemented.\n";
    4ff4:	be b8 b5 00 00       	mov    esi,0xb5b8
    4ff9:	bf d8 d8 00 00       	mov    edi,0xd8d8
    4ffe:	e8 7d 0f 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    5003:	31 c0                	xor    eax,eax
    5005:	48 83 c4 08          	add    rsp,0x8
    5009:	c3                   	ret    
    500a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000005010 <perception::linux_syscalls::rt_sigpending()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long rt_sigpending() {
    5010:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call rt_sigpending is unimplemented.\n";
    5014:	be e8 b5 00 00       	mov    esi,0xb5e8
    5019:	bf d8 d8 00 00       	mov    edi,0xd8d8
    501e:	e8 5d 0f 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    5023:	31 c0                	xor    eax,eax
    5025:	48 83 c4 08          	add    rsp,0x8
    5029:	c3                   	ret    
    502a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000005030 <perception::linux_syscalls::rt_sigprocmask()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long rt_sigprocmask() {
    5030:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call rt_sigprocmask is unimplemented.\n";
    5034:	be 18 b6 00 00       	mov    esi,0xb618
    5039:	bf d8 d8 00 00       	mov    edi,0xd8d8
    503e:	e8 3d 0f 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    5043:	31 c0                	xor    eax,eax
    5045:	48 83 c4 08          	add    rsp,0x8
    5049:	c3                   	ret    
    504a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000005050 <perception::linux_syscalls::rt_sigqueueinfo()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long rt_sigqueueinfo() {
    5050:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call rt_sigqueueinfo is unimplemented.\n";
    5054:	be 48 b6 00 00       	mov    esi,0xb648
    5059:	bf d8 d8 00 00       	mov    edi,0xd8d8
    505e:	e8 1d 0f 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    5063:	31 c0                	xor    eax,eax
    5065:	48 83 c4 08          	add    rsp,0x8
    5069:	c3                   	ret    
    506a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000005070 <perception::linux_syscalls::rt_sigreturn()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long rt_sigreturn() {
    5070:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call rt_sigreturn is unimplemented.\n";
    5074:	be 78 b6 00 00       	mov    esi,0xb678
    5079:	bf d8 d8 00 00       	mov    edi,0xd8d8
    507e:	e8 fd 0e 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    5083:	31 c0                	xor    eax,eax
    5085:	48 83 c4 08          	add    rsp,0x8
    5089:	c3                   	ret    
    508a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000005090 <perception::linux_syscalls::rt_sigsuspend()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long rt_sigsuspend() {
    5090:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call rt_sigsuspend is unimplemented.\n";
    5094:	be a8 b6 00 00       	mov    esi,0xb6a8
    5099:	bf d8 d8 00 00       	mov    edi,0xd8d8
    509e:	e8 dd 0e 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    50a3:	31 c0                	xor    eax,eax
    50a5:	48 83 c4 08          	add    rsp,0x8
    50a9:	c3                   	ret    
    50aa:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

00000000000050b0 <perception::linux_syscalls::rt_sigtimedwait()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long rt_sigtimedwait() {
    50b0:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call rt_sigtimedwait is unimplemented.\n";
    50b4:	be d8 b6 00 00       	mov    esi,0xb6d8
    50b9:	bf d8 d8 00 00       	mov    edi,0xd8d8
    50be:	e8 bd 0e 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    50c3:	31 c0                	xor    eax,eax
    50c5:	48 83 c4 08          	add    rsp,0x8
    50c9:	c3                   	ret    
    50ca:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

00000000000050d0 <perception::linux_syscalls::rt_tgsigqueueinfo()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long rt_tgsigqueueinfo() {
    50d0:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call rt_tgsigqueueinfo is unimplemented.\n";
    50d4:	be 08 b7 00 00       	mov    esi,0xb708
    50d9:	bf d8 d8 00 00       	mov    edi,0xd8d8
    50de:	e8 9d 0e 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    50e3:	31 c0                	xor    eax,eax
    50e5:	48 83 c4 08          	add    rsp,0x8
    50e9:	c3                   	ret    
    50ea:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

00000000000050f0 <perception::linux_syscalls::sched_get_priority_max()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long sched_get_priority_max() {
    50f0:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call sched_get_priority_max is unimplemented.\n";
    50f4:	be 40 b7 00 00       	mov    esi,0xb740
    50f9:	bf d8 d8 00 00       	mov    edi,0xd8d8
    50fe:	e8 7d 0e 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    5103:	31 c0                	xor    eax,eax
    5105:	48 83 c4 08          	add    rsp,0x8
    5109:	c3                   	ret    
    510a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000005110 <perception::linux_syscalls::sched_get_priority_min()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long sched_get_priority_min() {
    5110:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call sched_get_priority_min is unimplemented.\n";
    5114:	be 78 b7 00 00       	mov    esi,0xb778
    5119:	bf d8 d8 00 00       	mov    edi,0xd8d8
    511e:	e8 5d 0e 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    5123:	31 c0                	xor    eax,eax
    5125:	48 83 c4 08          	add    rsp,0x8
    5129:	c3                   	ret    
    512a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000005130 <perception::linux_syscalls::sched_getaffinity()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long sched_getaffinity() {
    5130:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call sched_getaffinity is unimplemented.\n";
    5134:	be b0 b7 00 00       	mov    esi,0xb7b0
    5139:	bf d8 d8 00 00       	mov    edi,0xd8d8
    513e:	e8 3d 0e 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    5143:	31 c0                	xor    eax,eax
    5145:	48 83 c4 08          	add    rsp,0x8
    5149:	c3                   	ret    
    514a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000005150 <perception::linux_syscalls::sched_getattr()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long sched_getattr() {
    5150:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call sched_getattr is unimplemented.\n";
    5154:	be e8 b7 00 00       	mov    esi,0xb7e8
    5159:	bf d8 d8 00 00       	mov    edi,0xd8d8
    515e:	e8 1d 0e 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    5163:	31 c0                	xor    eax,eax
    5165:	48 83 c4 08          	add    rsp,0x8
    5169:	c3                   	ret    
    516a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000005170 <perception::linux_syscalls::sched_getparam()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long sched_getparam() {
    5170:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call sched_getparam is unimplemented.\n";
    5174:	be 18 b8 00 00       	mov    esi,0xb818
    5179:	bf d8 d8 00 00       	mov    edi,0xd8d8
    517e:	e8 fd 0d 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    5183:	31 c0                	xor    eax,eax
    5185:	48 83 c4 08          	add    rsp,0x8
    5189:	c3                   	ret    
    518a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000005190 <perception::linux_syscalls::sched_getscheduler()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long sched_getscheduler() {
    5190:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call sched_getscheduler is unimplemented.\n";
    5194:	be 48 b8 00 00       	mov    esi,0xb848
    5199:	bf d8 d8 00 00       	mov    edi,0xd8d8
    519e:	e8 dd 0d 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    51a3:	31 c0                	xor    eax,eax
    51a5:	48 83 c4 08          	add    rsp,0x8
    51a9:	c3                   	ret    
    51aa:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

00000000000051b0 <perception::linux_syscalls::sched_rr_get_interval()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long sched_rr_get_interval() {
    51b0:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call sched_rr_get_interval is unimplemented.\n";
    51b4:	be 80 b8 00 00       	mov    esi,0xb880
    51b9:	bf d8 d8 00 00       	mov    edi,0xd8d8
    51be:	e8 bd 0d 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    51c3:	31 c0                	xor    eax,eax
    51c5:	48 83 c4 08          	add    rsp,0x8
    51c9:	c3                   	ret    
    51ca:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

00000000000051d0 <perception::linux_syscalls::sched_setaffinity()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long sched_setaffinity() {
    51d0:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call sched_setaffinity is unimplemented.\n";
    51d4:	be b8 b8 00 00       	mov    esi,0xb8b8
    51d9:	bf d8 d8 00 00       	mov    edi,0xd8d8
    51de:	e8 9d 0d 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    51e3:	31 c0                	xor    eax,eax
    51e5:	48 83 c4 08          	add    rsp,0x8
    51e9:	c3                   	ret    
    51ea:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

00000000000051f0 <perception::linux_syscalls::sched_setattr()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long sched_setattr() {
    51f0:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call sched_setattr is unimplemented.\n";
    51f4:	be f0 b8 00 00       	mov    esi,0xb8f0
    51f9:	bf d8 d8 00 00       	mov    edi,0xd8d8
    51fe:	e8 7d 0d 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    5203:	31 c0                	xor    eax,eax
    5205:	48 83 c4 08          	add    rsp,0x8
    5209:	c3                   	ret    
    520a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000005210 <perception::linux_syscalls::sched_setparam()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long sched_setparam() {
    5210:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call sched_setparam is unimplemented.\n";
    5214:	be 20 b9 00 00       	mov    esi,0xb920
    5219:	bf d8 d8 00 00       	mov    edi,0xd8d8
    521e:	e8 5d 0d 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    5223:	31 c0                	xor    eax,eax
    5225:	48 83 c4 08          	add    rsp,0x8
    5229:	c3                   	ret    
    522a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000005230 <perception::linux_syscalls::sched_setscheduler()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long sched_setscheduler() {
    5230:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call sched_setscheduler is unimplemented.\n";
    5234:	be 50 b9 00 00       	mov    esi,0xb950
    5239:	bf d8 d8 00 00       	mov    edi,0xd8d8
    523e:	e8 3d 0d 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    5243:	31 c0                	xor    eax,eax
    5245:	48 83 c4 08          	add    rsp,0x8
    5249:	c3                   	ret    
    524a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000005250 <perception::linux_syscalls::sched_yield()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long sched_yield() {
    5250:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call sched_yield is unimplemented.\n";
    5254:	be 88 b9 00 00       	mov    esi,0xb988
    5259:	bf d8 d8 00 00       	mov    edi,0xd8d8
    525e:	e8 1d 0d 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    5263:	31 c0                	xor    eax,eax
    5265:	48 83 c4 08          	add    rsp,0x8
    5269:	c3                   	ret    
    526a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000005270 <perception::linux_syscalls::seccomp()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long seccomp() {
    5270:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call seccomp is unimplemented.\n";
    5274:	be b8 b9 00 00       	mov    esi,0xb9b8
    5279:	bf d8 d8 00 00       	mov    edi,0xd8d8
    527e:	e8 fd 0c 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    5283:	31 c0                	xor    eax,eax
    5285:	48 83 c4 08          	add    rsp,0x8
    5289:	c3                   	ret    
    528a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000005290 <perception::linux_syscalls::security()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long security() {
    5290:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call security is unimplemented.\n";
    5294:	be e0 b9 00 00       	mov    esi,0xb9e0
    5299:	bf d8 d8 00 00       	mov    edi,0xd8d8
    529e:	e8 dd 0c 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    52a3:	31 c0                	xor    eax,eax
    52a5:	48 83 c4 08          	add    rsp,0x8
    52a9:	c3                   	ret    
    52aa:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

00000000000052b0 <perception::linux_syscalls::select()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long select() {
    52b0:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call select is unimplemented.\n";
    52b4:	be 08 ba 00 00       	mov    esi,0xba08
    52b9:	bf d8 d8 00 00       	mov    edi,0xd8d8
    52be:	e8 bd 0c 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    52c3:	31 c0                	xor    eax,eax
    52c5:	48 83 c4 08          	add    rsp,0x8
    52c9:	c3                   	ret    
    52ca:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

00000000000052d0 <perception::linux_syscalls::semctl()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long semctl() {
    52d0:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call semctl is unimplemented.\n";
    52d4:	be 30 ba 00 00       	mov    esi,0xba30
    52d9:	bf d8 d8 00 00       	mov    edi,0xd8d8
    52de:	e8 9d 0c 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    52e3:	31 c0                	xor    eax,eax
    52e5:	48 83 c4 08          	add    rsp,0x8
    52e9:	c3                   	ret    
    52ea:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

00000000000052f0 <perception::linux_syscalls::semget()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long semget() {
    52f0:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call semget is unimplemented.\n";
    52f4:	be 58 ba 00 00       	mov    esi,0xba58
    52f9:	bf d8 d8 00 00       	mov    edi,0xd8d8
    52fe:	e8 7d 0c 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    5303:	31 c0                	xor    eax,eax
    5305:	48 83 c4 08          	add    rsp,0x8
    5309:	c3                   	ret    
    530a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000005310 <perception::linux_syscalls::semop()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long semop() {
    5310:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call semop is unimplemented.\n";
    5314:	be 80 ba 00 00       	mov    esi,0xba80
    5319:	bf d8 d8 00 00       	mov    edi,0xd8d8
    531e:	e8 5d 0c 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    5323:	31 c0                	xor    eax,eax
    5325:	48 83 c4 08          	add    rsp,0x8
    5329:	c3                   	ret    
    532a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000005330 <perception::linux_syscalls::semtimedop()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long semtimedop() {
    5330:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call semtimedop is unimplemented.\n";
    5334:	be a8 ba 00 00       	mov    esi,0xbaa8
    5339:	bf d8 d8 00 00       	mov    edi,0xd8d8
    533e:	e8 3d 0c 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    5343:	31 c0                	xor    eax,eax
    5345:	48 83 c4 08          	add    rsp,0x8
    5349:	c3                   	ret    
    534a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000005350 <perception::linux_syscalls::sendfile()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long sendfile() {
    5350:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call sendfile is unimplemented.\n";
    5354:	be d8 ba 00 00       	mov    esi,0xbad8
    5359:	bf d8 d8 00 00       	mov    edi,0xd8d8
    535e:	e8 1d 0c 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    5363:	31 c0                	xor    eax,eax
    5365:	48 83 c4 08          	add    rsp,0x8
    5369:	c3                   	ret    
    536a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000005370 <perception::linux_syscalls::sendmmsg()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long sendmmsg() {
    5370:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call sendmmsg is unimplemented.\n";
    5374:	be 00 bb 00 00       	mov    esi,0xbb00
    5379:	bf d8 d8 00 00       	mov    edi,0xd8d8
    537e:	e8 fd 0b 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    5383:	31 c0                	xor    eax,eax
    5385:	48 83 c4 08          	add    rsp,0x8
    5389:	c3                   	ret    
    538a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000005390 <perception::linux_syscalls::sendmsg()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long sendmsg() {
    5390:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call sendmsg is unimplemented.\n";
    5394:	be 28 bb 00 00       	mov    esi,0xbb28
    5399:	bf d8 d8 00 00       	mov    edi,0xd8d8
    539e:	e8 dd 0b 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    53a3:	31 c0                	xor    eax,eax
    53a5:	48 83 c4 08          	add    rsp,0x8
    53a9:	c3                   	ret    
    53aa:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

00000000000053b0 <perception::linux_syscalls::sendto()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long sendto() {
    53b0:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call sendto is unimplemented.\n";
    53b4:	be 50 bb 00 00       	mov    esi,0xbb50
    53b9:	bf d8 d8 00 00       	mov    edi,0xd8d8
    53be:	e8 bd 0b 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    53c3:	31 c0                	xor    eax,eax
    53c5:	48 83 c4 08          	add    rsp,0x8
    53c9:	c3                   	ret    
    53ca:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

00000000000053d0 <perception::linux_syscalls::set_mempolicy()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long set_mempolicy() {
    53d0:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call set_mempolicy is unimplemented.\n";
    53d4:	be 78 bb 00 00       	mov    esi,0xbb78
    53d9:	bf d8 d8 00 00       	mov    edi,0xd8d8
    53de:	e8 9d 0b 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    53e3:	31 c0                	xor    eax,eax
    53e5:	48 83 c4 08          	add    rsp,0x8
    53e9:	c3                   	ret    
    53ea:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

00000000000053f0 <perception::linux_syscalls::set_robust_list()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long set_robust_list() {
    53f0:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call set_robust_list is unimplemented.\n";
    53f4:	be a8 bb 00 00       	mov    esi,0xbba8
    53f9:	bf d8 d8 00 00       	mov    edi,0xd8d8
    53fe:	e8 7d 0b 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    5403:	31 c0                	xor    eax,eax
    5405:	48 83 c4 08          	add    rsp,0x8
    5409:	c3                   	ret    
    540a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000005410 <perception::linux_syscalls::set_thread_area(long)>:
#include "perception/threads.h"

namespace perception {
namespace linux_syscalls {

long set_thread_area(long thread_area) {
    5410:	48 83 ec 08          	sub    rsp,0x8
	perception::SetThreadSegment(static_cast<size_t>(thread_area));
    5414:	e8 77 0c 00 00       	call   6090 <perception::SetThreadSegment(unsigned long)>
	return 0;
}
    5419:	31 c0                	xor    eax,eax
    541b:	48 83 c4 08          	add    rsp,0x8
    541f:	c3                   	ret    

0000000000005420 <perception::linux_syscalls::set_tid_address(long)>:
#include "perception/threads.h"

namespace perception {
namespace linux_syscalls {

long set_tid_address(long tid_address) {
    5420:	48 83 ec 08          	sub    rsp,0x8
	SetAddressToClearOnThreadTermination(tid_address);
    5424:	e8 77 0c 00 00       	call   60a0 <perception::SetAddressToClearOnThreadTermination(unsigned long)>
	return GetThreadId();
}
    5429:	48 83 c4 08          	add    rsp,0x8
	return GetThreadId();
    542d:	e9 0e 0c 00 00       	jmp    6040 <perception::GetThreadId()>
    5432:	66 2e 0f 1f 84 00 00 00 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
    543c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

0000000000005440 <perception::linux_syscalls::setdomainname()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long setdomainname() {
    5440:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call setdomainname is unimplemented.\n";
    5444:	be d8 bb 00 00       	mov    esi,0xbbd8
    5449:	bf d8 d8 00 00       	mov    edi,0xd8d8
    544e:	e8 2d 0b 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    5453:	31 c0                	xor    eax,eax
    5455:	48 83 c4 08          	add    rsp,0x8
    5459:	c3                   	ret    
    545a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000005460 <perception::linux_syscalls::setfsgid()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long setfsgid() {
    5460:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call setfsgid is unimplemented.\n";
    5464:	be 08 bc 00 00       	mov    esi,0xbc08
    5469:	bf d8 d8 00 00       	mov    edi,0xd8d8
    546e:	e8 0d 0b 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    5473:	31 c0                	xor    eax,eax
    5475:	48 83 c4 08          	add    rsp,0x8
    5479:	c3                   	ret    
    547a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000005480 <perception::linux_syscalls::setfsuid()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long setfsuid() {
    5480:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call setfsuid is unimplemented.\n";
    5484:	be 30 bc 00 00       	mov    esi,0xbc30
    5489:	bf d8 d8 00 00       	mov    edi,0xd8d8
    548e:	e8 ed 0a 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    5493:	31 c0                	xor    eax,eax
    5495:	48 83 c4 08          	add    rsp,0x8
    5499:	c3                   	ret    
    549a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

00000000000054a0 <perception::linux_syscalls::setgid()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long setgid() {
    54a0:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call setgid is unimplemented.\n";
    54a4:	be 58 bc 00 00       	mov    esi,0xbc58
    54a9:	bf d8 d8 00 00       	mov    edi,0xd8d8
    54ae:	e8 cd 0a 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    54b3:	31 c0                	xor    eax,eax
    54b5:	48 83 c4 08          	add    rsp,0x8
    54b9:	c3                   	ret    
    54ba:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

00000000000054c0 <perception::linux_syscalls::setgroups()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long setgroups() {
    54c0:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call setgroups is unimplemented.\n";
    54c4:	be 80 bc 00 00       	mov    esi,0xbc80
    54c9:	bf d8 d8 00 00       	mov    edi,0xd8d8
    54ce:	e8 ad 0a 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    54d3:	31 c0                	xor    eax,eax
    54d5:	48 83 c4 08          	add    rsp,0x8
    54d9:	c3                   	ret    
    54da:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

00000000000054e0 <perception::linux_syscalls::sethostname()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long sethostname() {
    54e0:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call sethostname is unimplemented.\n";
    54e4:	be b0 bc 00 00       	mov    esi,0xbcb0
    54e9:	bf d8 d8 00 00       	mov    edi,0xd8d8
    54ee:	e8 8d 0a 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    54f3:	31 c0                	xor    eax,eax
    54f5:	48 83 c4 08          	add    rsp,0x8
    54f9:	c3                   	ret    
    54fa:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000005500 <perception::linux_syscalls::setitimer()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long setitimer() {
    5500:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call setitimer is unimplemented.\n";
    5504:	be e0 bc 00 00       	mov    esi,0xbce0
    5509:	bf d8 d8 00 00       	mov    edi,0xd8d8
    550e:	e8 6d 0a 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    5513:	31 c0                	xor    eax,eax
    5515:	48 83 c4 08          	add    rsp,0x8
    5519:	c3                   	ret    
    551a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000005520 <perception::linux_syscalls::setns()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long setns() {
    5520:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call setns is unimplemented.\n";
    5524:	be 10 bd 00 00       	mov    esi,0xbd10
    5529:	bf d8 d8 00 00       	mov    edi,0xd8d8
    552e:	e8 4d 0a 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    5533:	31 c0                	xor    eax,eax
    5535:	48 83 c4 08          	add    rsp,0x8
    5539:	c3                   	ret    
    553a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000005540 <perception::linux_syscalls::setpgid()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long setpgid() {
    5540:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call setpgid is unimplemented.\n";
    5544:	be 38 bd 00 00       	mov    esi,0xbd38
    5549:	bf d8 d8 00 00       	mov    edi,0xd8d8
    554e:	e8 2d 0a 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    5553:	31 c0                	xor    eax,eax
    5555:	48 83 c4 08          	add    rsp,0x8
    5559:	c3                   	ret    
    555a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000005560 <perception::linux_syscalls::setpriority()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long setpriority() {
    5560:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call setpriority is unimplemented.\n";
    5564:	be 60 bd 00 00       	mov    esi,0xbd60
    5569:	bf d8 d8 00 00       	mov    edi,0xd8d8
    556e:	e8 0d 0a 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    5573:	31 c0                	xor    eax,eax
    5575:	48 83 c4 08          	add    rsp,0x8
    5579:	c3                   	ret    
    557a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000005580 <perception::linux_syscalls::setregid()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long setregid() {
    5580:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call setregid is unimplemented.\n";
    5584:	be 90 bd 00 00       	mov    esi,0xbd90
    5589:	bf d8 d8 00 00       	mov    edi,0xd8d8
    558e:	e8 ed 09 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    5593:	31 c0                	xor    eax,eax
    5595:	48 83 c4 08          	add    rsp,0x8
    5599:	c3                   	ret    
    559a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

00000000000055a0 <perception::linux_syscalls::setresgid()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long setresgid() {
    55a0:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call setresgid is unimplemented.\n";
    55a4:	be b8 bd 00 00       	mov    esi,0xbdb8
    55a9:	bf d8 d8 00 00       	mov    edi,0xd8d8
    55ae:	e8 cd 09 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    55b3:	31 c0                	xor    eax,eax
    55b5:	48 83 c4 08          	add    rsp,0x8
    55b9:	c3                   	ret    
    55ba:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

00000000000055c0 <perception::linux_syscalls::setresuid()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long setresuid() {
    55c0:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call setresuid is unimplemented.\n";
    55c4:	be e8 bd 00 00       	mov    esi,0xbde8
    55c9:	bf d8 d8 00 00       	mov    edi,0xd8d8
    55ce:	e8 ad 09 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    55d3:	31 c0                	xor    eax,eax
    55d5:	48 83 c4 08          	add    rsp,0x8
    55d9:	c3                   	ret    
    55da:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

00000000000055e0 <perception::linux_syscalls::setreuid()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long setreuid() {
    55e0:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call setreuid is unimplemented.\n";
    55e4:	be 18 be 00 00       	mov    esi,0xbe18
    55e9:	bf d8 d8 00 00       	mov    edi,0xd8d8
    55ee:	e8 8d 09 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    55f3:	31 c0                	xor    eax,eax
    55f5:	48 83 c4 08          	add    rsp,0x8
    55f9:	c3                   	ret    
    55fa:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000005600 <perception::linux_syscalls::setrlimit()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long setrlimit() {
    5600:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call setrlimit is unimplemented.\n";
    5604:	be 40 be 00 00       	mov    esi,0xbe40
    5609:	bf d8 d8 00 00       	mov    edi,0xd8d8
    560e:	e8 6d 09 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    5613:	31 c0                	xor    eax,eax
    5615:	48 83 c4 08          	add    rsp,0x8
    5619:	c3                   	ret    
    561a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000005620 <perception::linux_syscalls::setsid()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long setsid() {
    5620:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call setsid is unimplemented.\n";
    5624:	be 70 be 00 00       	mov    esi,0xbe70
    5629:	bf d8 d8 00 00       	mov    edi,0xd8d8
    562e:	e8 4d 09 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    5633:	31 c0                	xor    eax,eax
    5635:	48 83 c4 08          	add    rsp,0x8
    5639:	c3                   	ret    
    563a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000005640 <perception::linux_syscalls::setsockopt()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long setsockopt() {
    5640:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call setsockopt is unimplemented.\n";
    5644:	be 98 be 00 00       	mov    esi,0xbe98
    5649:	bf d8 d8 00 00       	mov    edi,0xd8d8
    564e:	e8 2d 09 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    5653:	31 c0                	xor    eax,eax
    5655:	48 83 c4 08          	add    rsp,0x8
    5659:	c3                   	ret    
    565a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000005660 <perception::linux_syscalls::settimeofday()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long settimeofday() {
    5660:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call settimeofday is unimplemented.\n";
    5664:	be c8 be 00 00       	mov    esi,0xbec8
    5669:	bf d8 d8 00 00       	mov    edi,0xd8d8
    566e:	e8 0d 09 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    5673:	31 c0                	xor    eax,eax
    5675:	48 83 c4 08          	add    rsp,0x8
    5679:	c3                   	ret    
    567a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000005680 <perception::linux_syscalls::setuid()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long setuid() {
    5680:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call setuid is unimplemented.\n";
    5684:	be f8 be 00 00       	mov    esi,0xbef8
    5689:	bf d8 d8 00 00       	mov    edi,0xd8d8
    568e:	e8 ed 08 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    5693:	31 c0                	xor    eax,eax
    5695:	48 83 c4 08          	add    rsp,0x8
    5699:	c3                   	ret    
    569a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

00000000000056a0 <perception::linux_syscalls::setxattr()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long setxattr() {
    56a0:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call setxattr is unimplemented.\n";
    56a4:	be 20 bf 00 00       	mov    esi,0xbf20
    56a9:	bf d8 d8 00 00       	mov    edi,0xd8d8
    56ae:	e8 cd 08 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    56b3:	31 c0                	xor    eax,eax
    56b5:	48 83 c4 08          	add    rsp,0x8
    56b9:	c3                   	ret    
    56ba:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

00000000000056c0 <perception::linux_syscalls::shmat()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long shmat() {
    56c0:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call shmat is unimplemented.\n";
    56c4:	be 48 bf 00 00       	mov    esi,0xbf48
    56c9:	bf d8 d8 00 00       	mov    edi,0xd8d8
    56ce:	e8 ad 08 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    56d3:	31 c0                	xor    eax,eax
    56d5:	48 83 c4 08          	add    rsp,0x8
    56d9:	c3                   	ret    
    56da:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

00000000000056e0 <perception::linux_syscalls::shmctl()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long shmctl() {
    56e0:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call shmctl is unimplemented.\n";
    56e4:	be 70 bf 00 00       	mov    esi,0xbf70
    56e9:	bf d8 d8 00 00       	mov    edi,0xd8d8
    56ee:	e8 8d 08 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    56f3:	31 c0                	xor    eax,eax
    56f5:	48 83 c4 08          	add    rsp,0x8
    56f9:	c3                   	ret    
    56fa:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000005700 <perception::linux_syscalls::shmdt()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long shmdt() {
    5700:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call shmdt is unimplemented.\n";
    5704:	be 98 bf 00 00       	mov    esi,0xbf98
    5709:	bf d8 d8 00 00       	mov    edi,0xd8d8
    570e:	e8 6d 08 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    5713:	31 c0                	xor    eax,eax
    5715:	48 83 c4 08          	add    rsp,0x8
    5719:	c3                   	ret    
    571a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000005720 <perception::linux_syscalls::shmget()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long shmget() {
    5720:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call shmget is unimplemented.\n";
    5724:	be c0 bf 00 00       	mov    esi,0xbfc0
    5729:	bf d8 d8 00 00       	mov    edi,0xd8d8
    572e:	e8 4d 08 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    5733:	31 c0                	xor    eax,eax
    5735:	48 83 c4 08          	add    rsp,0x8
    5739:	c3                   	ret    
    573a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000005740 <perception::linux_syscalls::shutdown()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long shutdown() {
    5740:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call shutdown is unimplemented.\n";
    5744:	be e8 bf 00 00       	mov    esi,0xbfe8
    5749:	bf d8 d8 00 00       	mov    edi,0xd8d8
    574e:	e8 2d 08 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    5753:	31 c0                	xor    eax,eax
    5755:	48 83 c4 08          	add    rsp,0x8
    5759:	c3                   	ret    
    575a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000005760 <perception::linux_syscalls::sigaltstack()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long sigaltstack() {
    5760:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call sigaltstack is unimplemented.\n";
    5764:	be 10 c0 00 00       	mov    esi,0xc010
    5769:	bf d8 d8 00 00       	mov    edi,0xd8d8
    576e:	e8 0d 08 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    5773:	31 c0                	xor    eax,eax
    5775:	48 83 c4 08          	add    rsp,0x8
    5779:	c3                   	ret    
    577a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000005780 <perception::linux_syscalls::signalfd()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long signalfd() {
    5780:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call signalfd is unimplemented.\n";
    5784:	be 40 c0 00 00       	mov    esi,0xc040
    5789:	bf d8 d8 00 00       	mov    edi,0xd8d8
    578e:	e8 ed 07 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    5793:	31 c0                	xor    eax,eax
    5795:	48 83 c4 08          	add    rsp,0x8
    5799:	c3                   	ret    
    579a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

00000000000057a0 <perception::linux_syscalls::signalfd4()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long signalfd4() {
    57a0:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call signalfd4 is unimplemented.\n";
    57a4:	be 68 c0 00 00       	mov    esi,0xc068
    57a9:	bf d8 d8 00 00       	mov    edi,0xd8d8
    57ae:	e8 cd 07 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    57b3:	31 c0                	xor    eax,eax
    57b5:	48 83 c4 08          	add    rsp,0x8
    57b9:	c3                   	ret    
    57ba:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

00000000000057c0 <perception::linux_syscalls::socket()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long socket() {
    57c0:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call socket is unimplemented.\n";
    57c4:	be 98 c0 00 00       	mov    esi,0xc098
    57c9:	bf d8 d8 00 00       	mov    edi,0xd8d8
    57ce:	e8 ad 07 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    57d3:	31 c0                	xor    eax,eax
    57d5:	48 83 c4 08          	add    rsp,0x8
    57d9:	c3                   	ret    
    57da:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

00000000000057e0 <perception::linux_syscalls::socketpair()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long socketpair() {
    57e0:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call socketpair is unimplemented.\n";
    57e4:	be c0 c0 00 00       	mov    esi,0xc0c0
    57e9:	bf d8 d8 00 00       	mov    edi,0xd8d8
    57ee:	e8 8d 07 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    57f3:	31 c0                	xor    eax,eax
    57f5:	48 83 c4 08          	add    rsp,0x8
    57f9:	c3                   	ret    
    57fa:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000005800 <perception::linux_syscalls::splice()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long splice() {
    5800:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call splice is unimplemented.\n";
    5804:	be f0 c0 00 00       	mov    esi,0xc0f0
    5809:	bf d8 d8 00 00       	mov    edi,0xd8d8
    580e:	e8 6d 07 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    5813:	31 c0                	xor    eax,eax
    5815:	48 83 c4 08          	add    rsp,0x8
    5819:	c3                   	ret    
    581a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000005820 <perception::linux_syscalls::stat()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long stat() {
    5820:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call stat is unimplemented.\n";
    5824:	be 18 c1 00 00       	mov    esi,0xc118
    5829:	bf d8 d8 00 00       	mov    edi,0xd8d8
    582e:	e8 4d 07 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    5833:	31 c0                	xor    eax,eax
    5835:	48 83 c4 08          	add    rsp,0x8
    5839:	c3                   	ret    
    583a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000005840 <perception::linux_syscalls::statfs()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long statfs() {
    5840:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call statfs is unimplemented.\n";
    5844:	be 40 c1 00 00       	mov    esi,0xc140
    5849:	bf d8 d8 00 00       	mov    edi,0xd8d8
    584e:	e8 2d 07 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    5853:	31 c0                	xor    eax,eax
    5855:	48 83 c4 08          	add    rsp,0x8
    5859:	c3                   	ret    
    585a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000005860 <perception::linux_syscalls::statx()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long statx() {
    5860:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call statx is unimplemented.\n";
    5864:	be 68 c1 00 00       	mov    esi,0xc168
    5869:	bf d8 d8 00 00       	mov    edi,0xd8d8
    586e:	e8 0d 07 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    5873:	31 c0                	xor    eax,eax
    5875:	48 83 c4 08          	add    rsp,0x8
    5879:	c3                   	ret    
    587a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000005880 <perception::linux_syscalls::swapoff()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long swapoff() {
    5880:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call swapoff is unimplemented.\n";
    5884:	be 90 c1 00 00       	mov    esi,0xc190
    5889:	bf d8 d8 00 00       	mov    edi,0xd8d8
    588e:	e8 ed 06 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    5893:	31 c0                	xor    eax,eax
    5895:	48 83 c4 08          	add    rsp,0x8
    5899:	c3                   	ret    
    589a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

00000000000058a0 <perception::linux_syscalls::swapon()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long swapon() {
    58a0:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call swapon is unimplemented.\n";
    58a4:	be b8 c1 00 00       	mov    esi,0xc1b8
    58a9:	bf d8 d8 00 00       	mov    edi,0xd8d8
    58ae:	e8 cd 06 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    58b3:	31 c0                	xor    eax,eax
    58b5:	48 83 c4 08          	add    rsp,0x8
    58b9:	c3                   	ret    
    58ba:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

00000000000058c0 <perception::linux_syscalls::symlink()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long symlink() {
    58c0:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call symlink is unimplemented.\n";
    58c4:	be e0 c1 00 00       	mov    esi,0xc1e0
    58c9:	bf d8 d8 00 00       	mov    edi,0xd8d8
    58ce:	e8 ad 06 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    58d3:	31 c0                	xor    eax,eax
    58d5:	48 83 c4 08          	add    rsp,0x8
    58d9:	c3                   	ret    
    58da:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

00000000000058e0 <perception::linux_syscalls::symlinkat()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long symlinkat() {
    58e0:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call symlinkat is unimplemented.\n";
    58e4:	be 08 c2 00 00       	mov    esi,0xc208
    58e9:	bf d8 d8 00 00       	mov    edi,0xd8d8
    58ee:	e8 8d 06 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    58f3:	31 c0                	xor    eax,eax
    58f5:	48 83 c4 08          	add    rsp,0x8
    58f9:	c3                   	ret    
    58fa:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000005900 <perception::linux_syscalls::sync()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long sync() {
    5900:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call sync is unimplemented.\n";
    5904:	be 38 c2 00 00       	mov    esi,0xc238
    5909:	bf d8 d8 00 00       	mov    edi,0xd8d8
    590e:	e8 6d 06 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    5913:	31 c0                	xor    eax,eax
    5915:	48 83 c4 08          	add    rsp,0x8
    5919:	c3                   	ret    
    591a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000005920 <perception::linux_syscalls::sync_file_range()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long sync_file_range() {
    5920:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call sync_file_range is unimplemented.\n";
    5924:	be 60 c2 00 00       	mov    esi,0xc260
    5929:	bf d8 d8 00 00       	mov    edi,0xd8d8
    592e:	e8 4d 06 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    5933:	31 c0                	xor    eax,eax
    5935:	48 83 c4 08          	add    rsp,0x8
    5939:	c3                   	ret    
    593a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000005940 <perception::linux_syscalls::syncfs()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long syncfs() {
    5940:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call syncfs is unimplemented.\n";
    5944:	be 90 c2 00 00       	mov    esi,0xc290
    5949:	bf d8 d8 00 00       	mov    edi,0xd8d8
    594e:	e8 2d 06 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    5953:	31 c0                	xor    eax,eax
    5955:	48 83 c4 08          	add    rsp,0x8
    5959:	c3                   	ret    
    595a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000005960 <perception::linux_syscalls::sysfs()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long sysfs() {
    5960:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call sysfs is unimplemented.\n";
    5964:	be b8 c2 00 00       	mov    esi,0xc2b8
    5969:	bf d8 d8 00 00       	mov    edi,0xd8d8
    596e:	e8 0d 06 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    5973:	31 c0                	xor    eax,eax
    5975:	48 83 c4 08          	add    rsp,0x8
    5979:	c3                   	ret    
    597a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000005980 <perception::linux_syscalls::sysinfo()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long sysinfo() {
    5980:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call sysinfo is unimplemented.\n";
    5984:	be e0 c2 00 00       	mov    esi,0xc2e0
    5989:	bf d8 d8 00 00       	mov    edi,0xd8d8
    598e:	e8 ed 05 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    5993:	31 c0                	xor    eax,eax
    5995:	48 83 c4 08          	add    rsp,0x8
    5999:	c3                   	ret    
    599a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

00000000000059a0 <perception::linux_syscalls::syslog()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long syslog() {
    59a0:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call syslog is unimplemented.\n";
    59a4:	be 08 c3 00 00       	mov    esi,0xc308
    59a9:	bf d8 d8 00 00       	mov    edi,0xd8d8
    59ae:	e8 cd 05 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    59b3:	31 c0                	xor    eax,eax
    59b5:	48 83 c4 08          	add    rsp,0x8
    59b9:	c3                   	ret    
    59ba:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

00000000000059c0 <perception::linux_syscalls::tee()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long tee() {
    59c0:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call tee is unimplemented.\n";
    59c4:	be 30 c3 00 00       	mov    esi,0xc330
    59c9:	bf d8 d8 00 00       	mov    edi,0xd8d8
    59ce:	e8 ad 05 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    59d3:	31 c0                	xor    eax,eax
    59d5:	48 83 c4 08          	add    rsp,0x8
    59d9:	c3                   	ret    
    59da:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

00000000000059e0 <perception::linux_syscalls::tgkill()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long tgkill() {
    59e0:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call tgkill is unimplemented.\n";
    59e4:	be 58 c3 00 00       	mov    esi,0xc358
    59e9:	bf d8 d8 00 00       	mov    edi,0xd8d8
    59ee:	e8 8d 05 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    59f3:	31 c0                	xor    eax,eax
    59f5:	48 83 c4 08          	add    rsp,0x8
    59f9:	c3                   	ret    
    59fa:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000005a00 <perception::linux_syscalls::time()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long time() {
    5a00:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call time is unimplemented.\n";
    5a04:	be 80 c3 00 00       	mov    esi,0xc380
    5a09:	bf d8 d8 00 00       	mov    edi,0xd8d8
    5a0e:	e8 6d 05 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    5a13:	31 c0                	xor    eax,eax
    5a15:	48 83 c4 08          	add    rsp,0x8
    5a19:	c3                   	ret    
    5a1a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000005a20 <perception::linux_syscalls::timer_create()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long timer_create() {
    5a20:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call timer_create is unimplemented.\n";
    5a24:	be a8 c3 00 00       	mov    esi,0xc3a8
    5a29:	bf d8 d8 00 00       	mov    edi,0xd8d8
    5a2e:	e8 4d 05 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    5a33:	31 c0                	xor    eax,eax
    5a35:	48 83 c4 08          	add    rsp,0x8
    5a39:	c3                   	ret    
    5a3a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000005a40 <perception::linux_syscalls::timer_delete()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long timer_delete() {
    5a40:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call timer_delete is unimplemented.\n";
    5a44:	be d8 c3 00 00       	mov    esi,0xc3d8
    5a49:	bf d8 d8 00 00       	mov    edi,0xd8d8
    5a4e:	e8 2d 05 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    5a53:	31 c0                	xor    eax,eax
    5a55:	48 83 c4 08          	add    rsp,0x8
    5a59:	c3                   	ret    
    5a5a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000005a60 <perception::linux_syscalls::timer_getoverrun()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long timer_getoverrun() {
    5a60:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call timer_getoverrun is unimplemented.\n";
    5a64:	be 08 c4 00 00       	mov    esi,0xc408
    5a69:	bf d8 d8 00 00       	mov    edi,0xd8d8
    5a6e:	e8 0d 05 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    5a73:	31 c0                	xor    eax,eax
    5a75:	48 83 c4 08          	add    rsp,0x8
    5a79:	c3                   	ret    
    5a7a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000005a80 <perception::linux_syscalls::timer_gettime()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long timer_gettime() {
    5a80:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call timer_gettime is unimplemented.\n";
    5a84:	be 38 c4 00 00       	mov    esi,0xc438
    5a89:	bf d8 d8 00 00       	mov    edi,0xd8d8
    5a8e:	e8 ed 04 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    5a93:	31 c0                	xor    eax,eax
    5a95:	48 83 c4 08          	add    rsp,0x8
    5a99:	c3                   	ret    
    5a9a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000005aa0 <perception::linux_syscalls::timer_settime()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long timer_settime() {
    5aa0:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call timer_settime is unimplemented.\n";
    5aa4:	be 68 c4 00 00       	mov    esi,0xc468
    5aa9:	bf d8 d8 00 00       	mov    edi,0xd8d8
    5aae:	e8 cd 04 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    5ab3:	31 c0                	xor    eax,eax
    5ab5:	48 83 c4 08          	add    rsp,0x8
    5ab9:	c3                   	ret    
    5aba:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000005ac0 <perception::linux_syscalls::timerfd_create()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long timerfd_create() {
    5ac0:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call timerfd_create is unimplemented.\n";
    5ac4:	be 98 c4 00 00       	mov    esi,0xc498
    5ac9:	bf d8 d8 00 00       	mov    edi,0xd8d8
    5ace:	e8 ad 04 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    5ad3:	31 c0                	xor    eax,eax
    5ad5:	48 83 c4 08          	add    rsp,0x8
    5ad9:	c3                   	ret    
    5ada:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000005ae0 <perception::linux_syscalls::timerfd_gettime()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long timerfd_gettime() {
    5ae0:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call timerfd_gettime is unimplemented.\n";
    5ae4:	be c8 c4 00 00       	mov    esi,0xc4c8
    5ae9:	bf d8 d8 00 00       	mov    edi,0xd8d8
    5aee:	e8 8d 04 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    5af3:	31 c0                	xor    eax,eax
    5af5:	48 83 c4 08          	add    rsp,0x8
    5af9:	c3                   	ret    
    5afa:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000005b00 <perception::linux_syscalls::timerfd_settime()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long timerfd_settime() {
    5b00:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call timerfd_settime is unimplemented.\n";
    5b04:	be f8 c4 00 00       	mov    esi,0xc4f8
    5b09:	bf d8 d8 00 00       	mov    edi,0xd8d8
    5b0e:	e8 6d 04 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    5b13:	31 c0                	xor    eax,eax
    5b15:	48 83 c4 08          	add    rsp,0x8
    5b19:	c3                   	ret    
    5b1a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000005b20 <perception::linux_syscalls::times()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long times() {
    5b20:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call times is unimplemented.\n";
    5b24:	be 28 c5 00 00       	mov    esi,0xc528
    5b29:	bf d8 d8 00 00       	mov    edi,0xd8d8
    5b2e:	e8 4d 04 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    5b33:	31 c0                	xor    eax,eax
    5b35:	48 83 c4 08          	add    rsp,0x8
    5b39:	c3                   	ret    
    5b3a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000005b40 <perception::linux_syscalls::tkill()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long tkill() {
    5b40:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call tkill is unimplemented.\n";
    5b44:	be 50 c5 00 00       	mov    esi,0xc550
    5b49:	bf d8 d8 00 00       	mov    edi,0xd8d8
    5b4e:	e8 2d 04 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    5b53:	31 c0                	xor    eax,eax
    5b55:	48 83 c4 08          	add    rsp,0x8
    5b59:	c3                   	ret    
    5b5a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000005b60 <perception::linux_syscalls::truncate()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long truncate() {
    5b60:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call truncate is unimplemented.\n";
    5b64:	be 78 c5 00 00       	mov    esi,0xc578
    5b69:	bf d8 d8 00 00       	mov    edi,0xd8d8
    5b6e:	e8 0d 04 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    5b73:	31 c0                	xor    eax,eax
    5b75:	48 83 c4 08          	add    rsp,0x8
    5b79:	c3                   	ret    
    5b7a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000005b80 <perception::linux_syscalls::tuxcall()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long tuxcall() {
    5b80:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call tuxcall is unimplemented.\n";
    5b84:	be a0 c5 00 00       	mov    esi,0xc5a0
    5b89:	bf d8 d8 00 00       	mov    edi,0xd8d8
    5b8e:	e8 ed 03 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    5b93:	31 c0                	xor    eax,eax
    5b95:	48 83 c4 08          	add    rsp,0x8
    5b99:	c3                   	ret    
    5b9a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000005ba0 <perception::linux_syscalls::umask()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long umask() {
    5ba0:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call umask is unimplemented.\n";
    5ba4:	be c8 c5 00 00       	mov    esi,0xc5c8
    5ba9:	bf d8 d8 00 00       	mov    edi,0xd8d8
    5bae:	e8 cd 03 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    5bb3:	31 c0                	xor    eax,eax
    5bb5:	48 83 c4 08          	add    rsp,0x8
    5bb9:	c3                   	ret    
    5bba:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000005bc0 <perception::linux_syscalls::umount2()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long umount2() {
    5bc0:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call umount2 is unimplemented.\n";
    5bc4:	be f0 c5 00 00       	mov    esi,0xc5f0
    5bc9:	bf d8 d8 00 00       	mov    edi,0xd8d8
    5bce:	e8 ad 03 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    5bd3:	31 c0                	xor    eax,eax
    5bd5:	48 83 c4 08          	add    rsp,0x8
    5bd9:	c3                   	ret    
    5bda:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000005be0 <perception::linux_syscalls::uname()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long uname() {
    5be0:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call uname is unimplemented.\n";
    5be4:	be 18 c6 00 00       	mov    esi,0xc618
    5be9:	bf d8 d8 00 00       	mov    edi,0xd8d8
    5bee:	e8 8d 03 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    5bf3:	31 c0                	xor    eax,eax
    5bf5:	48 83 c4 08          	add    rsp,0x8
    5bf9:	c3                   	ret    
    5bfa:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000005c00 <perception::linux_syscalls::unlink()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long unlink() {
    5c00:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call unlink is unimplemented.\n";
    5c04:	be 40 c6 00 00       	mov    esi,0xc640
    5c09:	bf d8 d8 00 00       	mov    edi,0xd8d8
    5c0e:	e8 6d 03 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    5c13:	31 c0                	xor    eax,eax
    5c15:	48 83 c4 08          	add    rsp,0x8
    5c19:	c3                   	ret    
    5c1a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000005c20 <perception::linux_syscalls::unlinkat()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long unlinkat() {
    5c20:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call unlinkat is unimplemented.\n";
    5c24:	be 68 c6 00 00       	mov    esi,0xc668
    5c29:	bf d8 d8 00 00       	mov    edi,0xd8d8
    5c2e:	e8 4d 03 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    5c33:	31 c0                	xor    eax,eax
    5c35:	48 83 c4 08          	add    rsp,0x8
    5c39:	c3                   	ret    
    5c3a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000005c40 <perception::linux_syscalls::unshare()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long unshare() {
    5c40:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call unshare is unimplemented.\n";
    5c44:	be 90 c6 00 00       	mov    esi,0xc690
    5c49:	bf d8 d8 00 00       	mov    edi,0xd8d8
    5c4e:	e8 2d 03 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    5c53:	31 c0                	xor    eax,eax
    5c55:	48 83 c4 08          	add    rsp,0x8
    5c59:	c3                   	ret    
    5c5a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000005c60 <perception::linux_syscalls::uselib()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long uselib() {
    5c60:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call uselib is unimplemented.\n";
    5c64:	be b8 c6 00 00       	mov    esi,0xc6b8
    5c69:	bf d8 d8 00 00       	mov    edi,0xd8d8
    5c6e:	e8 0d 03 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    5c73:	31 c0                	xor    eax,eax
    5c75:	48 83 c4 08          	add    rsp,0x8
    5c79:	c3                   	ret    
    5c7a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000005c80 <perception::linux_syscalls::userfaultfd()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long userfaultfd() {
    5c80:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call userfaultfd is unimplemented.\n";
    5c84:	be e0 c6 00 00       	mov    esi,0xc6e0
    5c89:	bf d8 d8 00 00       	mov    edi,0xd8d8
    5c8e:	e8 ed 02 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    5c93:	31 c0                	xor    eax,eax
    5c95:	48 83 c4 08          	add    rsp,0x8
    5c99:	c3                   	ret    
    5c9a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000005ca0 <perception::linux_syscalls::ustat()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long ustat() {
    5ca0:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call ustat is unimplemented.\n";
    5ca4:	be 10 c7 00 00       	mov    esi,0xc710
    5ca9:	bf d8 d8 00 00       	mov    edi,0xd8d8
    5cae:	e8 cd 02 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    5cb3:	31 c0                	xor    eax,eax
    5cb5:	48 83 c4 08          	add    rsp,0x8
    5cb9:	c3                   	ret    
    5cba:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000005cc0 <perception::linux_syscalls::utime()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long utime() {
    5cc0:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call utime is unimplemented.\n";
    5cc4:	be 38 c7 00 00       	mov    esi,0xc738
    5cc9:	bf d8 d8 00 00       	mov    edi,0xd8d8
    5cce:	e8 ad 02 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    5cd3:	31 c0                	xor    eax,eax
    5cd5:	48 83 c4 08          	add    rsp,0x8
    5cd9:	c3                   	ret    
    5cda:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000005ce0 <perception::linux_syscalls::utimensat()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long utimensat() {
    5ce0:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call utimensat is unimplemented.\n";
    5ce4:	be 60 c7 00 00       	mov    esi,0xc760
    5ce9:	bf d8 d8 00 00       	mov    edi,0xd8d8
    5cee:	e8 8d 02 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    5cf3:	31 c0                	xor    eax,eax
    5cf5:	48 83 c4 08          	add    rsp,0x8
    5cf9:	c3                   	ret    
    5cfa:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000005d00 <perception::linux_syscalls::utimes()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long utimes() {
    5d00:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call utimes is unimplemented.\n";
    5d04:	be 90 c7 00 00       	mov    esi,0xc790
    5d09:	bf d8 d8 00 00       	mov    edi,0xd8d8
    5d0e:	e8 6d 02 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    5d13:	31 c0                	xor    eax,eax
    5d15:	48 83 c4 08          	add    rsp,0x8
    5d19:	c3                   	ret    
    5d1a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000005d20 <perception::linux_syscalls::vfork()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long vfork() {
    5d20:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call vfork is unimplemented.\n";
    5d24:	be b8 c7 00 00       	mov    esi,0xc7b8
    5d29:	bf d8 d8 00 00       	mov    edi,0xd8d8
    5d2e:	e8 4d 02 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    5d33:	31 c0                	xor    eax,eax
    5d35:	48 83 c4 08          	add    rsp,0x8
    5d39:	c3                   	ret    
    5d3a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000005d40 <perception::linux_syscalls::vhangup()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long vhangup() {
    5d40:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call vhangup is unimplemented.\n";
    5d44:	be e0 c7 00 00       	mov    esi,0xc7e0
    5d49:	bf d8 d8 00 00       	mov    edi,0xd8d8
    5d4e:	e8 2d 02 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    5d53:	31 c0                	xor    eax,eax
    5d55:	48 83 c4 08          	add    rsp,0x8
    5d59:	c3                   	ret    
    5d5a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000005d60 <perception::linux_syscalls::vmsplice()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long vmsplice() {
    5d60:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call vmsplice is unimplemented.\n";
    5d64:	be 08 c8 00 00       	mov    esi,0xc808
    5d69:	bf d8 d8 00 00       	mov    edi,0xd8d8
    5d6e:	e8 0d 02 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    5d73:	31 c0                	xor    eax,eax
    5d75:	48 83 c4 08          	add    rsp,0x8
    5d79:	c3                   	ret    
    5d7a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000005d80 <perception::linux_syscalls::vserver()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long vserver() {
    5d80:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call vserver is unimplemented.\n";
    5d84:	be 30 c8 00 00       	mov    esi,0xc830
    5d89:	bf d8 d8 00 00       	mov    edi,0xd8d8
    5d8e:	e8 ed 01 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    5d93:	31 c0                	xor    eax,eax
    5d95:	48 83 c4 08          	add    rsp,0x8
    5d99:	c3                   	ret    
    5d9a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000005da0 <perception::linux_syscalls::wait4()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long wait4() {
    5da0:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call wait4 is unimplemented.\n";
    5da4:	be 58 c8 00 00       	mov    esi,0xc858
    5da9:	bf d8 d8 00 00       	mov    edi,0xd8d8
    5dae:	e8 cd 01 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    5db3:	31 c0                	xor    eax,eax
    5db5:	48 83 c4 08          	add    rsp,0x8
    5db9:	c3                   	ret    
    5dba:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000005dc0 <perception::linux_syscalls::waitid()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long waitid() {
    5dc0:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call waitid is unimplemented.\n";
    5dc4:	be 80 c8 00 00       	mov    esi,0xc880
    5dc9:	bf d8 d8 00 00       	mov    edi,0xd8d8
    5dce:	e8 ad 01 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    5dd3:	31 c0                	xor    eax,eax
    5dd5:	48 83 c4 08          	add    rsp,0x8
    5dd9:	c3                   	ret    
    5dda:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000005de0 <perception::linux_syscalls::write()>:
#include "perception/debug.h"

namespace perception {
namespace linux_syscalls {

long write() {
    5de0:	48 83 ec 08          	sub    rsp,0x8
	perception::DebugPrinterSingleton << "System call write is unimplemented.\n";
    5de4:	be a8 c8 00 00       	mov    esi,0xc8a8
    5de9:	bf d8 d8 00 00       	mov    edi,0xd8d8
    5dee:	e8 8d 01 00 00       	call   5f80 <perception::DebugPrinter::operator<<(char const*)>
	return 0;
}
    5df3:	31 c0                	xor    eax,eax
    5df5:	48 83 c4 08          	add    rsp,0x8
    5df9:	c3                   	ret    
    5dfa:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000005e00 <perception::linux_syscalls::writev(long, iovec*, long)>:
namespace perception {
namespace linux_syscalls {

long writev(long file_descriptor, struct iovec* buffers, long buffer_count) {
	size_t bytes_written = 0;
	for (size_t i = 0; i < buffer_count; i++) {
    5e00:	48 85 d2             	test   rdx,rdx
    5e03:	74 61                	je     5e66 <perception::linux_syscalls::writev(long, iovec*, long)+0x66>
long writev(long file_descriptor, struct iovec* buffers, long buffer_count) {
    5e05:	41 56                	push   r14
    5e07:	48 c1 e2 04          	shl    rdx,0x4
    5e0b:	41 55                	push   r13
    5e0d:	4c 8d 34 16          	lea    r14,[rsi+rdx*1]
    5e11:	41 54                	push   r12
	size_t bytes_written = 0;
    5e13:	45 31 e4             	xor    r12d,r12d
long writev(long file_descriptor, struct iovec* buffers, long buffer_count) {
    5e16:	55                   	push   rbp
    5e17:	48 89 f5             	mov    rbp,rsi
    5e1a:	53                   	push   rbx
    5e1b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
		const auto& buffer = buffers[i];

		char* c = (char *)buffer.iov_base;
		for (size_t j = 0; j < buffer.iov_len; j++, c++, bytes_written++) {
    5e20:	48 83 7d 08 00       	cmp    QWORD PTR [rbp+0x8],0x0
		char* c = (char *)buffer.iov_base;
    5e25:	4c 8b 6d 00          	mov    r13,QWORD PTR [rbp+0x0]
		for (size_t j = 0; j < buffer.iov_len; j++, c++, bytes_written++) {
    5e29:	74 26                	je     5e51 <perception::linux_syscalls::writev(long, iovec*, long)+0x51>
    5e2b:	31 db                	xor    ebx,ebx
    5e2d:	0f 1f 00             	nop    DWORD PTR [rax]
			DebugPrinterSingleton << *c;
    5e30:	41 0f be 74 1d 00    	movsx  esi,BYTE PTR [r13+rbx*1+0x0]
    5e36:	bf d8 d8 00 00       	mov    edi,0xd8d8
		for (size_t j = 0; j < buffer.iov_len; j++, c++, bytes_written++) {
    5e3b:	48 83 c3 01          	add    rbx,0x1
			DebugPrinterSingleton << *c;
    5e3f:	e8 4c 00 00 00       	call   5e90 <perception::DebugPrinter::operator<<(char)>
		for (size_t j = 0; j < buffer.iov_len; j++, c++, bytes_written++) {
    5e44:	4a 8d 04 23          	lea    rax,[rbx+r12*1]
    5e48:	48 39 5d 08          	cmp    QWORD PTR [rbp+0x8],rbx
    5e4c:	77 e2                	ja     5e30 <perception::linux_syscalls::writev(long, iovec*, long)+0x30>
    5e4e:	49 89 c4             	mov    r12,rax
	for (size_t i = 0; i < buffer_count; i++) {
    5e51:	48 83 c5 10          	add    rbp,0x10
    5e55:	49 39 ee             	cmp    r14,rbp
    5e58:	75 c6                	jne    5e20 <perception::linux_syscalls::writev(long, iovec*, long)+0x20>
		}
	}
	return bytes_written;
}
    5e5a:	5b                   	pop    rbx
    5e5b:	4c 89 e0             	mov    rax,r12
    5e5e:	5d                   	pop    rbp
    5e5f:	41 5c                	pop    r12
    5e61:	41 5d                	pop    r13
    5e63:	41 5e                	pop    r14
    5e65:	c3                   	ret    
	for (size_t i = 0; i < buffer_count; i++) {
    5e66:	31 c0                	xor    eax,eax
}
    5e68:	c3                   	ret    
    5e69:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

0000000000005e70 <__set_thread_area>:
#include "pthread_impl.h"

extern void DebugPrint(char *str);

int __set_thread_area(void *p)
{
    5e70:	48 83 ec 08          	sub    rsp,0x8
    5e74:	48 89 fe             	mov    rsi,rdi
#ifdef SYS_set_thread_area
	return __syscall(SYS_set_thread_area, p);
    5e77:	bf cd 00 00 00       	mov    edi,0xcd
    5e7c:	e8 5f c8 ff ff       	call   26e0 <__syscall1>
#else
	return -ENOSYS;
#endif
}
    5e81:	48 83 c4 08          	add    rsp,0x8
    5e85:	c3                   	ret    
    5e86:	66 2e 0f 1f 84 00 00 00 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]

0000000000005e90 <perception::DebugPrinter::operator<<(char)>:
#include <iostream>
#endif

namespace perception {

DebugPrinter& DebugPrinter::operator<< (char c) {
    5e90:	49 89 f8             	mov    r8,rdi
#ifdef PERCEPTION
	register unsigned long long int syscall_num asm ("rdi") = 0;
	register unsigned long long int param asm ("rax") = c;
    5e93:	48 0f be c6          	movsx  rax,sil
	register unsigned long long int syscall_num asm ("rdi") = 0;
    5e97:	31 ff                	xor    edi,edi

	__asm__ ("syscall\n"::"r"(syscall_num), "r"(param): "rcx", "r11");
    5e99:	0f 05                	syscall 
#else
	std::cout << c;
#endif

	return *this;
}
    5e9b:	4c 89 c0             	mov    rax,r8
    5e9e:	c3                   	ret    
    5e9f:	90                   	nop

0000000000005ea0 <perception::DebugPrinter::operator<<(unsigned long)>:

DebugPrinter& DebugPrinter::operator<< (size_t number) {
    5ea0:	49 89 f9             	mov    r9,rdi
	if(number == 0) {
    5ea3:	48 85 f6             	test   rsi,rsi
    5ea6:	0f 84 94 00 00 00    	je     5f40 <perception::DebugPrinter::operator<<(unsigned long)+0xa0>
DebugPrinter& DebugPrinter::operator<< (size_t number) {
    5eac:	48 83 ec 28          	sub    rsp,0x28
    5eb0:	41 b8 14 00 00 00    	mov    r8d,0x14
    5eb6:	48 b9 cd cc cc cc cc cc cc cc 	movabs rcx,0xcccccccccccccccd
	char temp[20];
	size_t first_char = 20;

	while(number > 0) {
		first_char--;
		temp[first_char] = '0' + (char)(number % 10);
    5ec0:	48 89 f0             	mov    rax,rsi
    5ec3:	48 89 f7             	mov    rdi,rsi
		first_char--;
    5ec6:	49 83 e8 01          	sub    r8,0x1
		temp[first_char] = '0' + (char)(number % 10);
    5eca:	48 f7 e1             	mul    rcx
    5ecd:	48 c1 ea 03          	shr    rdx,0x3
    5ed1:	48 8d 04 92          	lea    rax,[rdx+rdx*4]
    5ed5:	48 01 c0             	add    rax,rax
    5ed8:	48 29 c7             	sub    rdi,rax
    5edb:	48 89 f8             	mov    rax,rdi
    5ede:	83 c0 30             	add    eax,0x30
    5ee1:	42 88 04 04          	mov    BYTE PTR [rsp+r8*1],al
		number /= 10;
    5ee5:	48 89 f0             	mov    rax,rsi
    5ee8:	48 89 d6             	mov    rsi,rdx
	while(number > 0) {
    5eeb:	48 83 f8 09          	cmp    rax,0x9
    5eef:	77 cf                	ja     5ec0 <perception::DebugPrinter::operator<<(unsigned long)+0x20>
	}

	size_t i;
	for(i = first_char; i < 20; i++) {
		*this << temp[i];
		if(i == 1 || i == 4 || i == 7 || i == 10 || i == 13 || i == 16)
    5ef1:	ba 92 24 01 00       	mov    edx,0x12492
	for(i = first_char; i < 20; i++) {
    5ef6:	49 83 f8 13          	cmp    r8,0x13
    5efa:	77 1d                	ja     5f19 <perception::DebugPrinter::operator<<(unsigned long)+0x79>
    5efc:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
	register unsigned long long int param asm ("rax") = c;
    5f00:	4a 0f be 04 04       	movsx  rax,BYTE PTR [rsp+r8*1]
	register unsigned long long int syscall_num asm ("rdi") = 0;
    5f05:	31 ff                	xor    edi,edi
	__asm__ ("syscall\n"::"r"(syscall_num), "r"(param): "rcx", "r11");
    5f07:	0f 05                	syscall 
		if(i == 1 || i == 4 || i == 7 || i == 10 || i == 13 || i == 16)
    5f09:	49 83 f8 10          	cmp    r8,0x10
    5f0d:	76 19                	jbe    5f28 <perception::DebugPrinter::operator<<(unsigned long)+0x88>
	for(i = first_char; i < 20; i++) {
    5f0f:	49 83 c0 01          	add    r8,0x1
    5f13:	49 83 f8 14          	cmp    r8,0x14
    5f17:	75 e7                	jne    5f00 <perception::DebugPrinter::operator<<(unsigned long)+0x60>
			*this << ',';

	}
	return *this;
}
    5f19:	4c 89 c8             	mov    rax,r9
    5f1c:	48 83 c4 28          	add    rsp,0x28
    5f20:	c3                   	ret    
    5f21:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
		if(i == 1 || i == 4 || i == 7 || i == 10 || i == 13 || i == 16)
    5f28:	4c 0f a3 c2          	bt     rdx,r8
    5f2c:	73 09                	jae    5f37 <perception::DebugPrinter::operator<<(unsigned long)+0x97>
	register unsigned long long int syscall_num asm ("rdi") = 0;
    5f2e:	31 ff                	xor    edi,edi
	register unsigned long long int param asm ("rax") = c;
    5f30:	b8 2c 00 00 00       	mov    eax,0x2c
	__asm__ ("syscall\n"::"r"(syscall_num), "r"(param): "rcx", "r11");
    5f35:	0f 05                	syscall 
	for(i = first_char; i < 20; i++) {
    5f37:	49 83 c0 01          	add    r8,0x1
    5f3b:	eb c3                	jmp    5f00 <perception::DebugPrinter::operator<<(unsigned long)+0x60>
    5f3d:	0f 1f 00             	nop    DWORD PTR [rax]
	register unsigned long long int syscall_num asm ("rdi") = 0;
    5f40:	31 ff                	xor    edi,edi
	register unsigned long long int param asm ("rax") = c;
    5f42:	b8 30 00 00 00       	mov    eax,0x30
	__asm__ ("syscall\n"::"r"(syscall_num), "r"(param): "rcx", "r11");
    5f47:	0f 05                	syscall 
}
    5f49:	4c 89 c8             	mov    rax,r9
    5f4c:	c3                   	ret    
    5f4d:	90                   	nop
    5f4e:	66 90                	xchg   ax,ax

0000000000005f50 <perception::DebugPrinter::operator<<(long long)>:

DebugPrinter& DebugPrinter::operator<< (int64 number) {
    5f50:	48 83 ec 08          	sub    rsp,0x8
    5f54:	49 89 fa             	mov    r10,rdi
	if (number < 0) {
    5f57:	48 85 f6             	test   rsi,rsi
    5f5a:	79 0c                	jns    5f68 <perception::DebugPrinter::operator<<(long long)+0x18>
	register unsigned long long int syscall_num asm ("rdi") = 0;
    5f5c:	31 ff                	xor    edi,edi
	register unsigned long long int param asm ("rax") = c;
    5f5e:	b8 2d 00 00 00       	mov    eax,0x2d
	__asm__ ("syscall\n"::"r"(syscall_num), "r"(param): "rcx", "r11");
    5f63:	0f 05                	syscall 
		*this << '-';
		number *= -1;
    5f65:	48 f7 de             	neg    rsi
	}
	*this << (size_t)number;
    5f68:	4c 89 d7             	mov    rdi,r10
    5f6b:	e8 30 ff ff ff       	call   5ea0 <perception::DebugPrinter::operator<<(unsigned long)>
	return *this;
}
    5f70:	48 83 c4 08          	add    rsp,0x8
    5f74:	4c 89 d0             	mov    rax,r10
    5f77:	c3                   	ret    
    5f78:	0f 1f 84 00 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]

0000000000005f80 <perception::DebugPrinter::operator<<(char const*)>:


DebugPrinter& DebugPrinter::operator<< (const char* str) {
	const char *c = (const char *)str;
	while(*c) {
    5f80:	48 0f be 06          	movsx  rax,BYTE PTR [rsi]
DebugPrinter& DebugPrinter::operator<< (const char* str) {
    5f84:	49 89 f8             	mov    r8,rdi
	while(*c) {
    5f87:	84 c0                	test   al,al
    5f89:	74 16                	je     5fa1 <perception::DebugPrinter::operator<<(char const*)+0x21>
    5f8b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
	register unsigned long long int syscall_num asm ("rdi") = 0;
    5f90:	31 ff                	xor    edi,edi
	__asm__ ("syscall\n"::"r"(syscall_num), "r"(param): "rcx", "r11");
    5f92:	0f 05                	syscall 
	while(*c) {
    5f94:	48 0f be 46 01       	movsx  rax,BYTE PTR [rsi+0x1]
		*this << *c;
		c++;
    5f99:	48 83 c6 01          	add    rsi,0x1
	while(*c) {
    5f9d:	84 c0                	test   al,al
    5f9f:	75 ef                	jne    5f90 <perception::DebugPrinter::operator<<(char const*)+0x10>
	}
	return *this;
}
    5fa1:	4c 89 c0             	mov    rax,r8
    5fa4:	c3                   	ret    
    5fa5:	90                   	nop
    5fa6:	66 2e 0f 1f 84 00 00 00 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]

0000000000005fb0 <perception::DebugPrinter::operator<<(bool)>:
DebugPrinter& DebugPrinter::operator<< (bool b) {
	*this << (b ? "true" : "false");
    5fb0:	40 80 fe 01          	cmp    sil,0x1
    5fb4:	ba cd c8 00 00       	mov    edx,0xc8cd
    5fb9:	b9 d2 c8 00 00       	mov    ecx,0xc8d2
DebugPrinter& DebugPrinter::operator<< (bool b) {
    5fbe:	49 89 f8             	mov    r8,rdi
	*this << (b ? "true" : "false");
    5fc1:	19 c0                	sbb    eax,eax
    5fc3:	83 e0 f2             	and    eax,0xfffffff2
    5fc6:	83 c0 74             	add    eax,0x74
    5fc9:	40 84 f6             	test   sil,sil
    5fcc:	48 0f 44 d1          	cmove  rdx,rcx
	register unsigned long long int syscall_num asm ("rdi") = 0;
    5fd0:	31 ff                	xor    edi,edi
	register unsigned long long int param asm ("rax") = c;
    5fd2:	48 0f be c0          	movsx  rax,al
	__asm__ ("syscall\n"::"r"(syscall_num), "r"(param): "rcx", "r11");
    5fd6:	0f 05                	syscall 
	while(*c) {
    5fd8:	0f b6 42 01          	movzx  eax,BYTE PTR [rdx+0x1]
		c++;
    5fdc:	48 83 c2 01          	add    rdx,0x1
	while(*c) {
    5fe0:	84 c0                	test   al,al
    5fe2:	75 ec                	jne    5fd0 <perception::DebugPrinter::operator<<(bool)+0x20>
	return *this;
}
    5fe4:	4c 89 c0             	mov    rax,r8
    5fe7:	c3                   	ret    
    5fe8:	0f 1f 84 00 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]

0000000000005ff0 <DebugPrint>:
	while(*c) {
    5ff0:	48 0f be 07          	movsx  rax,BYTE PTR [rdi]

DebugPrinter DebugPrinterSingleton;

extern "C" void DebugPrint(char *str) {
    5ff4:	48 89 fa             	mov    rdx,rdi
	while(*c) {
    5ff7:	84 c0                	test   al,al
    5ff9:	74 16                	je     6011 <DebugPrint+0x21>
    5ffb:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
	register unsigned long long int syscall_num asm ("rdi") = 0;
    6000:	31 ff                	xor    edi,edi
	__asm__ ("syscall\n"::"r"(syscall_num), "r"(param): "rcx", "r11");
    6002:	0f 05                	syscall 
	while(*c) {
    6004:	48 0f be 42 01       	movsx  rax,BYTE PTR [rdx+0x1]
		c++;
    6009:	48 83 c2 01          	add    rdx,0x1
	while(*c) {
    600d:	84 c0                	test   al,al
    600f:	75 ef                	jne    6000 <DebugPrint+0x10>
	DebugPrinterSingleton << str;
}
    6011:	c3                   	ret    
    6012:	66 66 2e 0f 1f 84 00 00 00 00 00 	data16 nop WORD PTR cs:[rax+rax*1+0x0]
    601d:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000006020 <DebugNumber>:

extern "C" void DebugNumber(long l) {
    6020:	48 89 fe             	mov    rsi,rdi
	DebugPrinterSingleton << (size_t)l;
    6023:	bf d8 d8 00 00       	mov    edi,0xd8d8
    6028:	e9 73 fe ff ff       	jmp    5ea0 <perception::DebugPrinter::operator<<(unsigned long)>
    602d:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000006030 <perception::CreateThread(void (*)(void*), void*)>:
#include <thread>
#endif

namespace perception {

ThreadId CreateThread(void (*entry_point)(void *), void* param) {
    6030:	53                   	push   rbx
    6031:	48 89 f8             	mov    rax,rdi
    6034:	48 89 f3             	mov    rbx,rsi
#ifdef PERCEPTION
	volatile register size_t syscall_num asm ("rdi") = 1;
    6037:	bf 01 00 00 00       	mov    edi,0x1
	volatile register size_t param1 asm ("rax") = (size_t)entry_point;
	volatile register size_t param2 asm ("rbx") = (size_t)param;
	volatile register size_t return_val asm ("rax");

	__asm__ __volatile__ ("syscall\n":"=r"(return_val):"r"(syscall_num), "r"(param1), "r"(param2): "rcx", "r11");
    603c:	0f 05                	syscall 
	return return_val;
#else
	std::cout << "You shouldn't manually call perception::CreateThread. Please use std::thread." << std::endl;
	return 0;
#endif
}
    603e:	5b                   	pop    rbx
    603f:	c3                   	ret    

0000000000006040 <perception::GetThreadId()>:

ThreadId GetThreadId() {
#ifdef PERCEPTION
	volatile register size_t syscall_num asm ("rdi") = 2;
    6040:	bf 02 00 00 00       	mov    edi,0x2
	volatile register size_t return_val asm ("rax");

	__asm__ __volatile__ ("syscall\n":"=r"(return_val):"r"(syscall_num): "rcx", "r11");
    6045:	0f 05                	syscall 
#else
	std::stringstream ss;
	ss << std::this_thread::get_id();
	return (ThreadId)std::stoi(ss.str());
#endif
}
    6047:	c3                   	ret    
    6048:	0f 1f 84 00 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]

0000000000006050 <perception::TerminateProcess()>:


void TerminateProcess() {
#ifdef PERCEPTION
	register size_t syscall_num asm ("rdi") = 6;
    6050:	bf 06 00 00 00       	mov    edi,0x6
	__asm__ ("syscall\n"::"r"(syscall_num): "rcx", "r11");
    6055:	0f 05                	syscall 
#else
	exit(0);
#endif
}
    6057:	c3                   	ret    
    6058:	0f 1f 84 00 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]

0000000000006060 <perception::TerminateThread()>:

void TerminateThread() {
#ifdef PERCEPTION
	register size_t syscall_num asm ("rdi") = 4;
    6060:	bf 04 00 00 00       	mov    edi,0x4
	__asm__ ("syscall\n"::"r"(syscall_num): "rcx", "r11");
    6065:	0f 05                	syscall 
#else
	std::cout << "You shouldn't manually call perception::TerminateThread. Please let the thread function return." << std::endl;
#endif
}
    6067:	c3                   	ret    
    6068:	0f 1f 84 00 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]

0000000000006070 <perception::TerminateThread(unsigned long)>:

void TerminateThread(ThreadId tid) {
    6070:	48 89 f8             	mov    rax,rdi
#ifdef PERCEPTION
	register size_t syscall_num asm ("rdi") = 5;
    6073:	bf 05 00 00 00       	mov    edi,0x5
	register size_t param asm ("rax") = tid;

	__asm__ ("syscall\n"::"r"(syscall_num), "r"(param): "rcx", "r11");
    6078:	0f 05                	syscall 
#else
	std::cout << "You shouldn't manually call perception::TerminateThread. Please let the thread function return." << std::endl;
#endif
}
    607a:	c3                   	ret    
    607b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

0000000000006080 <perception::Yield()>:

void Yield() {
#ifdef PERCEPTION
	register unsigned long long int syscall_num asm ("rdi") = 8;
    6080:	bf 08 00 00 00       	mov    edi,0x8
	__asm__ ("syscall\n"::"r"(syscall_num): "rcx", "r11");
    6085:	0f 05                	syscall 
#else
	(void)sched_yield();
#endif
}
    6087:	c3                   	ret    
    6088:	0f 1f 84 00 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]

0000000000006090 <perception::SetThreadSegment(unsigned long)>:

void SetThreadSegment(size_t segment_address) {
    6090:	48 89 f8             	mov    rax,rdi
#ifdef PERCEPTION
	register size_t syscall_num asm ("rdi") = 27;
    6093:	bf 1b 00 00 00       	mov    edi,0x1b
	register size_t param asm ("rax") = segment_address;

	__asm__ ("syscall\n"::"r"(syscall_num), "r"(param): "rcx", "r11");
    6098:	0f 05                	syscall 
#endif
}
    609a:	c3                   	ret    
    609b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

00000000000060a0 <perception::SetAddressToClearOnThreadTermination(unsigned long)>:

void SetAddressToClearOnThreadTermination(size_t address_to_clear) {
    60a0:	48 89 f8             	mov    rax,rdi
#ifdef PERCEPTION
	register size_t syscall_num asm ("rdi") = 28;
    60a3:	bf 1c 00 00 00       	mov    edi,0x1c
	register size_t param asm ("rax") = address_to_clear;

	__asm__ ("syscall\n"::"r"(syscall_num), "r"(param): "rcx", "r11");
    60a8:	0f 05                	syscall 
#endif
}
    60aa:	c3                   	ret    

Disassembly of section .text.startup:

00000000000060b0 <main>:

void Child(std::unique_ptr<Something> something) {
	std::cout << "I now own something" << std::endl;
}
*/
int main() {
    60b0:	48 83 ec 10          	sub    rsp,0x10

	volatile int a = 0;
    60b4:	c7 44 24 0c 00 00 00 00 	mov    DWORD PTR [rsp+0xc],0x0
    60bc:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
	while (true) { a++; }
    60c0:	8b 44 24 0c          	mov    eax,DWORD PTR [rsp+0xc]
    60c4:	83 c0 01             	add    eax,0x1
    60c7:	89 44 24 0c          	mov    DWORD PTR [rsp+0xc],eax
    60cb:	eb f3                	jmp    60c0 <main+0x10>
